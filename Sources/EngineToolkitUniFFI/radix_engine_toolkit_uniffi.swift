// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(radix_engine_toolkit_uniffiFFI)
    import radix_engine_toolkit_uniffiFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt16: FfiConverterPrimitive {
    typealias FfiType = Int16
    typealias SwiftType = Int16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int16, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol AddressProtocol {
    func addressString() -> String
    func asStr() -> String
    func bytes() -> [UInt8]
    func entityType() -> EntityType
    func isGlobal() -> Bool
    func isGlobalComponent() -> Bool
    func isGlobalConsensusManager() -> Bool
    func isGlobalFungibleResourceManager() -> Bool
    func isGlobalNonFungibleResourceManager() -> Bool
    func isGlobalPackage() -> Bool
    func isGlobalResourceManager() -> Bool
    func isGlobalVirtual() -> Bool
    func isInternal() -> Bool
    func isInternalFungibleVault() -> Bool
    func isInternalKvStore() -> Bool
    func isInternalNonFungibleVault() -> Bool
    func isInternalVault() -> Bool
    func networkId() -> UInt8
}

public class Address: AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(address: String) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new(
                FfiConverterString.lower(address), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_address(pointer, $0) }
    }

    public static func fromRaw(nodeIdBytes: [UInt8], networkId: UInt8) throws -> Address {
        return try Address(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw(
                FfiConverterSequenceUInt8.lower(nodeIdBytes),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public static func resourceAddressFromOlympiaResourceAddress(olympiaResourceAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
        return try Address(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address(
                FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public static func virtualAccountAddressFromOlympiaAddress(olympiaAccountAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
        return try Address(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address(
                FfiConverterTypeOlympiaAddress.lower(olympiaAccountAddress),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public static func virtualAccountAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
        return try Address(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public static func virtualIdentityAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
        return try Address(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public func addressString() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string(self.pointer, $0)
                }
        )
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str(self.pointer, $0)
                }
        )
    }

    public func bytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes(self.pointer, $0)
                }
        )
    }

    public func entityType() -> EntityType {
        return try! FfiConverterTypeEntityType.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type(self.pointer, $0)
                }
        )
    }

    public func isGlobal() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global(self.pointer, $0)
                }
        )
    }

    public func isGlobalComponent() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component(self.pointer, $0)
                }
        )
    }

    public func isGlobalConsensusManager() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager(self.pointer, $0)
                }
        )
    }

    public func isGlobalFungibleResourceManager() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager(self.pointer, $0)
                }
        )
    }

    public func isGlobalNonFungibleResourceManager() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager(self.pointer, $0)
                }
        )
    }

    public func isGlobalPackage() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package(self.pointer, $0)
                }
        )
    }

    public func isGlobalResourceManager() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager(self.pointer, $0)
                }
        )
    }

    public func isGlobalVirtual() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual(self.pointer, $0)
                }
        )
    }

    public func isInternal() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal(self.pointer, $0)
                }
        )
    }

    public func isInternalFungibleVault() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault(self.pointer, $0)
                }
        )
    }

    public func isInternalKvStore() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store(self.pointer, $0)
                }
        )
    }

    public func isInternalNonFungibleVault() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault(self.pointer, $0)
                }
        )
    }

    public func isInternalVault() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault(self.pointer, $0)
                }
        )
    }

    public func networkId() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}

public protocol DecimalProtocol {
    func abs() -> Decimal
    func add(other: Decimal) -> Decimal
    func asStr() -> String
    func cbrt() -> Decimal
    func ceiling() -> Decimal
    func div(other: Decimal) -> Decimal
    func equal(other: Decimal) -> Bool
    func floor() -> Decimal
    func greaterThan(other: Decimal) -> Bool
    func greaterThanOrEqual(other: Decimal) -> Bool
    func isNegative() -> Bool
    func isPositive() -> Bool
    func isZero() -> Bool
    func lessThan(other: Decimal) -> Bool
    func lessThanOrEqual(other: Decimal) -> Bool
    func mul(other: Decimal) -> Decimal
    func notEqual(other: Decimal) -> Bool
    func nthRoot(n: UInt32) -> Decimal?
    func powi(exp: Int64) -> Decimal
    func round(decimalPlaces: Int32, roundingMode: RoundingMode) -> Decimal
    func sqrt() -> Decimal?
    func sub(other: Decimal) -> Decimal
}

public class Decimal: DecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(value: String) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new(
                FfiConverterString.lower(value), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_decimal(pointer, $0) }
    }

    public static func max() -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max($0)
        })
    }

    public static func min() -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min($0)
        })
    }

    public static func one() -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one($0)
        })
    }

    public static func zero() -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero($0)
        })
    }

    public func abs() -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs(self.pointer, $0)
                }
        )
    }

    public func add(other: Decimal) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add(self.pointer,
                                                                             FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str(self.pointer, $0)
                }
        )
    }

    public func cbrt() -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt(self.pointer, $0)
                }
        )
    }

    public func ceiling() -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling(self.pointer, $0)
                }
        )
    }

    public func div(other: Decimal) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div(self.pointer,
                                                                             FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func equal(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal(self.pointer,
                                                                               FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func floor() -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor(self.pointer, $0)
                }
        )
    }

    public func greaterThan(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than(self.pointer,
                                                                                      FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func greaterThanOrEqual(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal(self.pointer,
                                                                                               FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func isNegative() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative(self.pointer, $0)
                }
        )
    }

    public func isPositive() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive(self.pointer, $0)
                }
        )
    }

    public func isZero() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero(self.pointer, $0)
                }
        )
    }

    public func lessThan(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than(self.pointer,
                                                                                   FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func lessThanOrEqual(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal(self.pointer,
                                                                                            FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func mul(other: Decimal) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul(self.pointer,
                                                                             FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func notEqual(other: Decimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal(self.pointer,
                                                                                   FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }

    public func nthRoot(n: UInt32) -> Decimal? {
        return try! FfiConverterOptionTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root(self.pointer,
                                                                                  FfiConverterUInt32.lower(n), $0)
                }
        )
    }

    public func powi(exp: Int64) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi(self.pointer,
                                                                              FfiConverterInt64.lower(exp), $0)
                }
        )
    }

    public func round(decimalPlaces: Int32, roundingMode: RoundingMode) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round(self.pointer,
                                                                               FfiConverterInt32.lower(decimalPlaces),
                                                                               FfiConverterTypeRoundingMode.lower(roundingMode), $0)
                }
        )
    }

    public func sqrt() -> Decimal? {
        return try! FfiConverterOptionTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt(self.pointer, $0)
                }
        )
    }

    public func sub(other: Decimal) -> Decimal {
        return try! FfiConverterTypeDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub(self.pointer,
                                                                             FfiConverterTypeDecimal.lower(other), $0)
                }
        )
    }
}

public struct FfiConverterTypeDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Decimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Decimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
        return Decimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Decimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
    return try FfiConverterTypeDecimal.lift(pointer)
}

public func FfiConverterTypeDecimal_lower(_ value: Decimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDecimal.lower(value)
}

public protocol HashProtocol {
    func asStr() -> String
    func bytes() -> [UInt8]
}

public class Hash: HashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(hash: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new(
                FfiConverterSequenceUInt8.lower(hash), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_hash(pointer, $0) }
    }

    public static func fromHexString(hash: String) throws -> Hash {
        return try Hash(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string(
                FfiConverterString.lower(hash), $0
            )
        })
    }

    public static func fromUnhashedBytes(bytes: [UInt8]) -> Hash {
        return Hash(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str(self.pointer, $0)
                }
        )
    }

    public func bytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Hash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
        return Hash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Hash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
    return try FfiConverterTypeHash.lift(pointer)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHash.lower(value)
}

public protocol InstructionsProtocol {
    func asStr() throws -> String
    func instructionsList() -> [Instruction]
    func networkId() -> UInt8
}

public class Instructions: InstructionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_instructions(pointer, $0) }
    }

    public static func fromInstructions(instructions: [Instruction], networkId: UInt8) throws -> Instructions {
        return try Instructions(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions(
                FfiConverterSequenceTypeInstruction.lower(instructions),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public static func fromString(string: String, networkId: UInt8) throws -> Instructions {
        return try Instructions(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string(
                FfiConverterString.lower(string),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public func asStr() throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str(self.pointer, $0)
            }
        )
    }

    public func instructionsList() -> [Instruction] {
        return try! FfiConverterSequenceTypeInstruction.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list(self.pointer, $0)
                }
        )
    }

    public func networkId() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeInstructions: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Instructions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Instructions {
        return Instructions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Instructions) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeInstructions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(pointer)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInstructions.lower(value)
}

public protocol IntentProtocol {
    func compile() throws -> [UInt8]
    func hash() throws -> TransactionHash
    func header() -> TransactionHeader
    func intentHash() throws -> TransactionHash
    func manifest() -> TransactionManifest
    func message() -> Message
    func staticallyValidate(validationConfig: ValidationConfig) throws
}

public class Intent: IntentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new(
                FfiConverterTypeTransactionHeader.lower(header),
                FfiConverterTypeTransactionManifest.lower(manifest),
                FfiConverterTypeMessage.lower(message), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_intent(pointer, $0) }
    }

    public static func decompile(compiledIntent: [UInt8]) throws -> Intent {
        return try Intent(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile(
                FfiConverterSequenceUInt8.lower(compiledIntent), $0
            )
        })
    }

    public func compile() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile(self.pointer, $0)
            }
        )
    }

    public func hash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash(self.pointer, $0)
            }
        )
    }

    public func header() -> TransactionHeader {
        return try! FfiConverterTypeTransactionHeader.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header(self.pointer, $0)
                }
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash(self.pointer, $0)
            }
        )
    }

    public func manifest() -> TransactionManifest {
        return try! FfiConverterTypeTransactionManifest.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest(self.pointer, $0)
                }
        )
    }

    public func message() -> Message {
        return try! FfiConverterTypeMessage.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message(self.pointer, $0)
                }
        )
    }

    public func staticallyValidate(validationConfig: ValidationConfig) throws {
        try
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate(self.pointer,
                                                                                        FfiConverterTypeValidationConfig.lower(validationConfig), $0)
            }
    }
}

public struct FfiConverterTypeIntent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Intent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Intent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Intent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Intent {
        return Intent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Intent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeIntent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Intent {
    return try FfiConverterTypeIntent.lift(pointer)
}

public func FfiConverterTypeIntent_lower(_ value: Intent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIntent.lower(value)
}

public protocol MessageValidationConfigProtocol {
    func maxDecryptors() -> UInt64
    func maxEncryptedMessageLength() -> UInt64
    func maxMimeTypeLength() -> UInt64
    func maxPlaintextMessageLength() -> UInt64
}

public class MessageValidationConfig: MessageValidationConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(maxPlaintextMessageLength: UInt64, maxEncryptedMessageLength: UInt64, maxMimeTypeLength: UInt64, maxDecryptors: UInt64) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new(
                FfiConverterUInt64.lower(maxPlaintextMessageLength),
                FfiConverterUInt64.lower(maxEncryptedMessageLength),
                FfiConverterUInt64.lower(maxMimeTypeLength),
                FfiConverterUInt64.lower(maxDecryptors), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig(pointer, $0) }
    }

    public static func `default`() -> MessageValidationConfig {
        return MessageValidationConfig(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default($0)
        })
    }

    public func maxDecryptors() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors(self.pointer, $0)
                }
        )
    }

    public func maxEncryptedMessageLength() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length(self.pointer, $0)
                }
        )
    }

    public func maxMimeTypeLength() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length(self.pointer, $0)
                }
        )
    }

    public func maxPlaintextMessageLength() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeMessageValidationConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MessageValidationConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageValidationConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MessageValidationConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageValidationConfig {
        return MessageValidationConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MessageValidationConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeMessageValidationConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageValidationConfig {
    return try FfiConverterTypeMessageValidationConfig.lift(pointer)
}

public func FfiConverterTypeMessageValidationConfig_lower(_ value: MessageValidationConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessageValidationConfig.lower(value)
}

public protocol NonFungibleGlobalIdProtocol {
    func asStr() -> String
    func localId() -> NonFungibleLocalId
    func resourceAddress() -> Address
}

public class NonFungibleGlobalId: NonFungibleGlobalIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(nonFungibleGlobalId: String) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new(
                FfiConverterString.lower(nonFungibleGlobalId), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid(pointer, $0) }
    }

    public static func fromParts(resourceAddress: Address, nonFungibleLocalId: NonFungibleLocalId) throws -> NonFungibleGlobalId {
        return try NonFungibleGlobalId(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts(
                FfiConverterTypeAddress.lower(resourceAddress),
                FfiConverterTypeNonFungibleLocalId.lower(nonFungibleLocalId), $0
            )
        })
    }

    public static func virtualSignatureBadge(publicKey: PublicKey, networkId: UInt8) throws -> NonFungibleGlobalId {
        return try NonFungibleGlobalId(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str(self.pointer, $0)
                }
        )
    }

    public func localId() -> NonFungibleLocalId {
        return try! FfiConverterTypeNonFungibleLocalId.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id(self.pointer, $0)
                }
        )
    }

    public func resourceAddress() -> Address {
        return try! FfiConverterTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NonFungibleGlobalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(pointer)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}

public protocol NotarizedTransactionProtocol {
    func compile() throws -> [UInt8]
    func hash() throws -> TransactionHash
    func intentHash() throws -> TransactionHash
    func notarizedTransactionHash() throws -> TransactionHash
    func notarySignature() -> Signature
    func signedIntent() -> SignedIntent
    func signedIntentHash() throws -> TransactionHash
    func staticallyValidate(validationConfig: ValidationConfig) throws
}

public class NotarizedTransaction: NotarizedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(signedIntent: SignedIntent, notarySignature: Signature) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new(
                FfiConverterTypeSignedIntent.lower(signedIntent),
                FfiConverterTypeSignature.lower(notarySignature), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction(pointer, $0) }
    }

    public static func decompile(compiledNotarizedTransaction: [UInt8]) throws -> NotarizedTransaction {
        return try NotarizedTransaction(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile(
                FfiConverterSequenceUInt8.lower(compiledNotarizedTransaction), $0
            )
        })
    }

    public func compile() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile(self.pointer, $0)
            }
        )
    }

    public func hash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash(self.pointer, $0)
            }
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash(self.pointer, $0)
            }
        )
    }

    public func notarizedTransactionHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash(self.pointer, $0)
            }
        )
    }

    public func notarySignature() -> Signature {
        return try! FfiConverterTypeSignature.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature(self.pointer, $0)
                }
        )
    }

    public func signedIntent() -> SignedIntent {
        return try! FfiConverterTypeSignedIntent.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent(self.pointer, $0)
                }
        )
    }

    public func signedIntentHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash(self.pointer, $0)
            }
        )
    }

    public func staticallyValidate(validationConfig: ValidationConfig) throws {
        try
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate(self.pointer,
                                                                                                      FfiConverterTypeValidationConfig.lower(validationConfig), $0)
            }
    }
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotarizedTransaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransaction {
        return NotarizedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotarizedTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeNotarizedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(pointer)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}

public protocol OlympiaAddressProtocol {
    func asStr() -> String
    func publicKey() throws -> PublicKey
}

public class OlympiaAddress: OlympiaAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(address: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new(
                FfiConverterString.lower(address), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress(pointer, $0) }
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str(self.pointer, $0)
                }
        )
    }

    public func publicKey() throws -> PublicKey {
        return try FfiConverterTypePublicKey.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeOlympiaAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlympiaAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlympiaAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
        return OlympiaAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeOlympiaAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
    return try FfiConverterTypeOlympiaAddress.lift(pointer)
}

public func FfiConverterTypeOlympiaAddress_lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlympiaAddress.lower(value)
}

public protocol PreciseDecimalProtocol {
    func abs() -> PreciseDecimal
    func add(other: PreciseDecimal) -> PreciseDecimal
    func asStr() -> String
    func cbrt() -> PreciseDecimal
    func ceiling() -> PreciseDecimal
    func div(other: PreciseDecimal) -> PreciseDecimal
    func equal(other: PreciseDecimal) -> Bool
    func floor() -> PreciseDecimal
    func greaterThan(other: PreciseDecimal) -> Bool
    func greaterThanOrEqual(other: PreciseDecimal) -> Bool
    func isNegative() -> Bool
    func isPositive() -> Bool
    func isZero() -> Bool
    func lessThan(other: PreciseDecimal) -> Bool
    func lessThanOrEqual(other: PreciseDecimal) -> Bool
    func mul(other: PreciseDecimal) -> PreciseDecimal
    func notEqual(other: PreciseDecimal) -> Bool
    func nthRoot(n: UInt32) -> PreciseDecimal?
    func powi(exp: Int64) -> PreciseDecimal
    func round(decimalPlaces: Int32, roundingMode: RoundingMode) -> PreciseDecimal
    func sqrt() -> PreciseDecimal?
    func sub(other: PreciseDecimal) -> PreciseDecimal
}

public class PreciseDecimal: PreciseDecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(value: String) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new(
                FfiConverterString.lower(value), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal(pointer, $0) }
    }

    public static func max() -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max($0)
        })
    }

    public static func min() -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min($0)
        })
    }

    public static func one() -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one($0)
        })
    }

    public static func zero() -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero($0)
        })
    }

    public func abs() -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs(self.pointer, $0)
                }
        )
    }

    public func add(other: PreciseDecimal) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add(self.pointer,
                                                                                    FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str(self.pointer, $0)
                }
        )
    }

    public func cbrt() -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt(self.pointer, $0)
                }
        )
    }

    public func ceiling() -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling(self.pointer, $0)
                }
        )
    }

    public func div(other: PreciseDecimal) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div(self.pointer,
                                                                                    FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func equal(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal(self.pointer,
                                                                                      FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func floor() -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor(self.pointer, $0)
                }
        )
    }

    public func greaterThan(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than(self.pointer,
                                                                                             FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func greaterThanOrEqual(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal(self.pointer,
                                                                                                      FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func isNegative() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative(self.pointer, $0)
                }
        )
    }

    public func isPositive() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive(self.pointer, $0)
                }
        )
    }

    public func isZero() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero(self.pointer, $0)
                }
        )
    }

    public func lessThan(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than(self.pointer,
                                                                                          FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func lessThanOrEqual(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal(self.pointer,
                                                                                                   FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func mul(other: PreciseDecimal) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul(self.pointer,
                                                                                    FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func notEqual(other: PreciseDecimal) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal(self.pointer,
                                                                                          FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }

    public func nthRoot(n: UInt32) -> PreciseDecimal? {
        return try! FfiConverterOptionTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root(self.pointer,
                                                                                         FfiConverterUInt32.lower(n), $0)
                }
        )
    }

    public func powi(exp: Int64) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi(self.pointer,
                                                                                     FfiConverterInt64.lower(exp), $0)
                }
        )
    }

    public func round(decimalPlaces: Int32, roundingMode: RoundingMode) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round(self.pointer,
                                                                                      FfiConverterInt32.lower(decimalPlaces),
                                                                                      FfiConverterTypeRoundingMode.lower(roundingMode), $0)
                }
        )
    }

    public func sqrt() -> PreciseDecimal? {
        return try! FfiConverterOptionTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt(self.pointer, $0)
                }
        )
    }

    public func sub(other: PreciseDecimal) -> PreciseDecimal {
        return try! FfiConverterTypePreciseDecimal.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub(self.pointer,
                                                                                    FfiConverterTypePreciseDecimal.lower(other), $0)
                }
        )
    }
}

public struct FfiConverterTypePreciseDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreciseDecimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreciseDecimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreciseDecimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypePreciseDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
    return try FfiConverterTypePreciseDecimal.lift(pointer)
}

public func FfiConverterTypePreciseDecimal_lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreciseDecimal.lower(value)
}

public protocol SignedIntentProtocol {
    func compile() throws -> [UInt8]
    func hash() throws -> TransactionHash
    func intent() -> Intent
    func intentHash() throws -> TransactionHash
    func intentSignatures() -> [SignatureWithPublicKey]
    func signedIntentHash() throws -> TransactionHash
    func staticallyValidate(validationConfig: ValidationConfig) throws
}

public class SignedIntent: SignedIntentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(intent: Intent, intentSignatures: [SignatureWithPublicKey]) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new(
                FfiConverterTypeIntent.lower(intent),
                FfiConverterSequenceTypeSignatureWithPublicKey.lower(intentSignatures), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent(pointer, $0) }
    }

    public static func decompile(compiledSignedIntent: [UInt8]) throws -> SignedIntent {
        return try SignedIntent(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile(
                FfiConverterSequenceUInt8.lower(compiledSignedIntent), $0
            )
        })
    }

    public func compile() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile(self.pointer, $0)
            }
        )
    }

    public func hash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash(self.pointer, $0)
            }
        )
    }

    public func intent() -> Intent {
        return try! FfiConverterTypeIntent.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent(self.pointer, $0)
                }
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash(self.pointer, $0)
            }
        )
    }

    public func intentSignatures() -> [SignatureWithPublicKey] {
        return try! FfiConverterSequenceTypeSignatureWithPublicKey.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures(self.pointer, $0)
                }
        )
    }

    public func signedIntentHash() throws -> TransactionHash {
        return try FfiConverterTypeTransactionHash.lift(
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash(self.pointer, $0)
            }
        )
    }

    public func staticallyValidate(validationConfig: ValidationConfig) throws {
        try
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate(self.pointer,
                                                                                              FfiConverterTypeValidationConfig.lower(validationConfig), $0)
            }
    }
}

public struct FfiConverterTypeSignedIntent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedIntent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedIntent {
        return SignedIntent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedIntent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeSignedIntent_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(pointer)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedIntent.lower(value)
}

public protocol TransactionHashProtocol {
    func asStr() -> String
    func bytes() -> [UInt8]
    func networkId() -> UInt8
}

public class TransactionHash: TransactionHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash(pointer, $0) }
    }

    public func asStr() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str(self.pointer, $0)
                }
        )
    }

    public func bytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes(self.pointer, $0)
                }
        )
    }

    public func networkId() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeTransactionHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
        return TransactionHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeTransactionHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
    return try FfiConverterTypeTransactionHash.lift(pointer)
}

public func FfiConverterTypeTransactionHash_lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionHash.lower(value)
}

public protocol TransactionManifestProtocol {
    func accountsDepositedInto() -> [Address]
    func accountsRequiringAuth() -> [Address]
    func accountsWithdrawnFrom() -> [Address]
    func blobs() -> [[UInt8]]
    func extractAddresses() -> [EntityType: [Address]]
    func identitiesRequiringAuth() -> [Address]
    func instructions() -> Instructions
    func staticallyValidate() throws
}

public class TransactionManifest: TransactionManifestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(instructions: Instructions, blobs: [[UInt8]]) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new(
                FfiConverterTypeInstructions.lower(instructions),
                FfiConverterSequenceSequenceUInt8.lower(blobs), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest(pointer, $0) }
    }

    public func accountsDepositedInto() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into(self.pointer, $0)
                }
        )
    }

    public func accountsRequiringAuth() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth(self.pointer, $0)
                }
        )
    }

    public func accountsWithdrawnFrom() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from(self.pointer, $0)
                }
        )
    }

    public func blobs() -> [[UInt8]] {
        return try! FfiConverterSequenceSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs(self.pointer, $0)
                }
        )
    }

    public func extractAddresses() -> [EntityType: [Address]] {
        return try! FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses(self.pointer, $0)
                }
        )
    }

    public func identitiesRequiringAuth() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth(self.pointer, $0)
                }
        )
    }

    public func instructions() -> Instructions {
        return try! FfiConverterTypeInstructions.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions(self.pointer, $0)
                }
        )
    }

    public func staticallyValidate() throws {
        try
            rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
                uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate(self.pointer, $0)
            }
    }
}

public struct FfiConverterTypeTransactionManifest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionManifest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifest {
        return TransactionManifest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionManifest) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeTransactionManifest_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(pointer)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionManifest.lower(value)
}

public protocol ValidationConfigProtocol {
    func maxCostUnitLimit() -> UInt32
    func maxEpochRange() -> UInt64
    func maxNotarizedPayloadSize() -> UInt64
    func maxTipPercentage() -> UInt16
    func messageValidation() -> MessageValidationConfig
    func minCostUnitLimit() -> UInt32
    func minTipPercentage() -> UInt16
    func networkId() -> UInt8
}

public class ValidationConfig: ValidationConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(networkId: UInt8, maxNotarizedPayloadSize: UInt64, minCostUnitLimit: UInt32, maxCostUnitLimit: UInt32, minTipPercentage: UInt16, maxTipPercentage: UInt16, maxEpochRange: UInt64, messageValidation: MessageValidationConfig) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new(
                FfiConverterUInt8.lower(networkId),
                FfiConverterUInt64.lower(maxNotarizedPayloadSize),
                FfiConverterUInt32.lower(minCostUnitLimit),
                FfiConverterUInt32.lower(maxCostUnitLimit),
                FfiConverterUInt16.lower(minTipPercentage),
                FfiConverterUInt16.lower(maxTipPercentage),
                FfiConverterUInt64.lower(maxEpochRange),
                FfiConverterTypeMessageValidationConfig.lower(messageValidation), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig(pointer, $0) }
    }

    public static func `default`(networkId: UInt8) -> ValidationConfig {
        return ValidationConfig(unsafeFromRawPointer: try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default(
                FfiConverterUInt8.lower(networkId), $0
            )
        })
    }

    public func maxCostUnitLimit() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_cost_unit_limit(self.pointer, $0)
                }
        )
    }

    public func maxEpochRange() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range(self.pointer, $0)
                }
        )
    }

    public func maxNotarizedPayloadSize() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size(self.pointer, $0)
                }
        )
    }

    public func maxTipPercentage() -> UInt16 {
        return try! FfiConverterUInt16.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage(self.pointer, $0)
                }
        )
    }

    public func messageValidation() -> MessageValidationConfig {
        return try! FfiConverterTypeMessageValidationConfig.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation(self.pointer, $0)
                }
        )
    }

    public func minCostUnitLimit() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_cost_unit_limit(self.pointer, $0)
                }
        )
    }

    public func minTipPercentage() -> UInt16 {
        return try! FfiConverterUInt16.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage(self.pointer, $0)
                }
        )
    }

    public func networkId() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeValidationConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ValidationConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ValidationConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ValidationConfig {
        return ValidationConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ValidationConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeValidationConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> ValidationConfig {
    return try FfiConverterTypeValidationConfig.lift(pointer)
}

public func FfiConverterTypeValidationConfig_lower(_ value: ValidationConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeValidationConfig.lower(value)
}

public struct BuildInformation {
    public var version: String
    public var scryptoDependency: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: String, scryptoDependency: DependencyInformation) {
        self.version = version
        self.scryptoDependency = scryptoDependency
    }
}

extension BuildInformation: Equatable, Hashable {
    public static func == (lhs: BuildInformation, rhs: BuildInformation) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.scryptoDependency != rhs.scryptoDependency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(scryptoDependency)
    }
}

public struct FfiConverterTypeBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildInformation {
        return try BuildInformation(
            version: FfiConverterString.read(from: &buf),
            scryptoDependency: FfiConverterTypeDependencyInformation.read(from: &buf)
        )
    }

    public static func write(_ value: BuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoDependency, into: &buf)
    }
}

public func FfiConverterTypeBuildInformation_lift(_ buf: RustBuffer) throws -> BuildInformation {
    return try FfiConverterTypeBuildInformation.lift(buf)
}

public func FfiConverterTypeBuildInformation_lower(_ value: BuildInformation) -> RustBuffer {
    return FfiConverterTypeBuildInformation.lower(value)
}

public struct ComponentAddresses {
    public var consensusManager: Address
    public var genesisHelper: Address
    public var faucet: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(consensusManager: Address, genesisHelper: Address, faucet: Address) {
        self.consensusManager = consensusManager
        self.genesisHelper = genesisHelper
        self.faucet = faucet
    }
}

public struct FfiConverterTypeComponentAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddresses {
        return try ComponentAddresses(
            consensusManager: FfiConverterTypeAddress.read(from: &buf),
            genesisHelper: FfiConverterTypeAddress.read(from: &buf),
            faucet: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ComponentAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.consensusManager, into: &buf)
        FfiConverterTypeAddress.write(value.genesisHelper, into: &buf)
        FfiConverterTypeAddress.write(value.faucet, into: &buf)
    }
}

public func FfiConverterTypeComponentAddresses_lift(_ buf: RustBuffer) throws -> ComponentAddresses {
    return try FfiConverterTypeComponentAddresses.lift(buf)
}

public func FfiConverterTypeComponentAddresses_lower(_ value: ComponentAddresses) -> RustBuffer {
    return FfiConverterTypeComponentAddresses.lower(value)
}

public struct Ed25519PublicKey {
    public var value: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [UInt8]) {
        self.value = value
    }
}

extension Ed25519PublicKey: Equatable, Hashable {
    public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return try Ed25519PublicKey(
            value: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}

public struct EncryptedMessage {
    public var encrypted: [UInt8]
    public var decryptorsByCurve: [CurveType: DecryptorsByCurve]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encrypted: [UInt8], decryptorsByCurve: [CurveType: DecryptorsByCurve]) {
        self.encrypted = encrypted
        self.decryptorsByCurve = decryptorsByCurve
    }
}

extension EncryptedMessage: Equatable, Hashable {
    public static func == (lhs: EncryptedMessage, rhs: EncryptedMessage) -> Bool {
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.decryptorsByCurve != rhs.decryptorsByCurve {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encrypted)
        hasher.combine(decryptorsByCurve)
    }
}

public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        return try EncryptedMessage(
            encrypted: FfiConverterSequenceUInt8.read(from: &buf),
            decryptorsByCurve: FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.encrypted, into: &buf)
        FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve.write(value.decryptorsByCurve, into: &buf)
    }
}

public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}

public struct ExecutionAnalysis {
    public var feeLocks: FeeLocks
    public var feeSummary: FeeSummary
    public var transactionType: TransactionType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(feeLocks: FeeLocks, feeSummary: FeeSummary, transactionType: TransactionType) {
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
        self.transactionType = transactionType
    }
}

public struct FfiConverterTypeExecutionAnalysis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionAnalysis {
        return try ExecutionAnalysis(
            feeLocks: FfiConverterTypeFeeLocks.read(from: &buf),
            feeSummary: FfiConverterTypeFeeSummary.read(from: &buf),
            transactionType: FfiConverterTypeTransactionType.read(from: &buf)
        )
    }

    public static func write(_ value: ExecutionAnalysis, into buf: inout [UInt8]) {
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
        FfiConverterTypeTransactionType.write(value.transactionType, into: &buf)
    }
}

public func FfiConverterTypeExecutionAnalysis_lift(_ buf: RustBuffer) throws -> ExecutionAnalysis {
    return try FfiConverterTypeExecutionAnalysis.lift(buf)
}

public func FfiConverterTypeExecutionAnalysis_lower(_ value: ExecutionAnalysis) -> RustBuffer {
    return FfiConverterTypeExecutionAnalysis.lower(value)
}

public struct FeeLocks {
    public var lock: Decimal
    public var contingentLock: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal, contingentLock: Decimal) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}

public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return try FeeLocks(
            lock: FfiConverterTypeDecimal.read(from: &buf),
            contingentLock: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.lock, into: &buf)
        FfiConverterTypeDecimal.write(value.contingentLock, into: &buf)
    }
}

public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}

public struct FeeSummary {
    public var networkFee: Decimal
    public var royaltyFee: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkFee: Decimal, royaltyFee: Decimal) {
        self.networkFee = networkFee
        self.royaltyFee = royaltyFee
    }
}

public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return try FeeSummary(
            networkFee: FfiConverterTypeDecimal.read(from: &buf),
            royaltyFee: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.networkFee, into: &buf)
        FfiConverterTypeDecimal.write(value.royaltyFee, into: &buf)
    }
}

public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}

public struct KnownAddresses {
    public var resourceAddresses: ResourceAddresses
    public var packageAddresses: PackageAddresses
    public var componentAddresses: ComponentAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddresses: ResourceAddresses, packageAddresses: PackageAddresses, componentAddresses: ComponentAddresses) {
        self.resourceAddresses = resourceAddresses
        self.packageAddresses = packageAddresses
        self.componentAddresses = componentAddresses
    }
}

public struct FfiConverterTypeKnownAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnownAddresses {
        return try KnownAddresses(
            resourceAddresses: FfiConverterTypeResourceAddresses.read(from: &buf),
            packageAddresses: FfiConverterTypePackageAddresses.read(from: &buf),
            componentAddresses: FfiConverterTypeComponentAddresses.read(from: &buf)
        )
    }

    public static func write(_ value: KnownAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddresses.write(value.resourceAddresses, into: &buf)
        FfiConverterTypePackageAddresses.write(value.packageAddresses, into: &buf)
        FfiConverterTypeComponentAddresses.write(value.componentAddresses, into: &buf)
    }
}

public func FfiConverterTypeKnownAddresses_lift(_ buf: RustBuffer) throws -> KnownAddresses {
    return try FfiConverterTypeKnownAddresses.lift(buf)
}

public func FfiConverterTypeKnownAddresses_lower(_ value: KnownAddresses) -> RustBuffer {
    return FfiConverterTypeKnownAddresses.lower(value)
}

public struct ManifestAddressReservation {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}

extension ManifestAddressReservation: Equatable, Hashable {
    public static func == (lhs: ManifestAddressReservation, rhs: ManifestAddressReservation) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeManifestAddressReservation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddressReservation {
        return try ManifestAddressReservation(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestAddressReservation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeManifestAddressReservation_lift(_ buf: RustBuffer) throws -> ManifestAddressReservation {
    return try FfiConverterTypeManifestAddressReservation.lift(buf)
}

public func FfiConverterTypeManifestAddressReservation_lower(_ value: ManifestAddressReservation) -> RustBuffer {
    return FfiConverterTypeManifestAddressReservation.lower(value)
}

public struct ManifestBlobRef {
    public var value: Hash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Hash) {
        self.value = value
    }
}

public struct FfiConverterTypeManifestBlobRef: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBlobRef {
        return try ManifestBlobRef(
            value: FfiConverterTypeHash.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBlobRef, into buf: inout [UInt8]) {
        FfiConverterTypeHash.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeManifestBlobRef_lift(_ buf: RustBuffer) throws -> ManifestBlobRef {
    return try FfiConverterTypeManifestBlobRef.lift(buf)
}

public func FfiConverterTypeManifestBlobRef_lower(_ value: ManifestBlobRef) -> RustBuffer {
    return FfiConverterTypeManifestBlobRef.lower(value)
}

public struct ManifestBucket {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}

extension ManifestBucket: Equatable, Hashable {
    public static func == (lhs: ManifestBucket, rhs: ManifestBucket) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeManifestBucket: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBucket {
        return try ManifestBucket(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBucket, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeManifestBucket_lift(_ buf: RustBuffer) throws -> ManifestBucket {
    return try FfiConverterTypeManifestBucket.lift(buf)
}

public func FfiConverterTypeManifestBucket_lower(_ value: ManifestBucket) -> RustBuffer {
    return FfiConverterTypeManifestBucket.lower(value)
}

public struct ManifestProof {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}

extension ManifestProof: Equatable, Hashable {
    public static func == (lhs: ManifestProof, rhs: ManifestProof) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeManifestProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestProof {
        return try ManifestProof(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestProof, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeManifestProof_lift(_ buf: RustBuffer) throws -> ManifestProof {
    return try FfiConverterTypeManifestProof.lift(buf)
}

public func FfiConverterTypeManifestProof_lower(_ value: ManifestProof) -> RustBuffer {
    return FfiConverterTypeManifestProof.lower(value)
}

public struct MapEntry {
    public var key: ManifestValue
    public var value: ManifestValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: ManifestValue, value: ManifestValue) {
        self.key = key
        self.value = value
    }
}

public struct FfiConverterTypeMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MapEntry {
        return try MapEntry(
            key: FfiConverterTypeManifestValue.read(from: &buf),
            value: FfiConverterTypeManifestValue.read(from: &buf)
        )
    }

    public static func write(_ value: MapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeManifestValue.write(value.key, into: &buf)
        FfiConverterTypeManifestValue.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeMapEntry_lift(_ buf: RustBuffer) throws -> MapEntry {
    return try FfiConverterTypeMapEntry.lift(buf)
}

public func FfiConverterTypeMapEntry_lower(_ value: MapEntry) -> RustBuffer {
    return FfiConverterTypeMapEntry.lower(value)
}

public struct PackageAddresses {
    public var packagePackage: Address
    public var resourcePackage: Address
    public var accountPackage: Address
    public var identityPackage: Address
    public var consensusManagerPackage: Address
    public var accessControllerPackage: Address
    public var poolPackage: Address
    public var transactionProcessorPackage: Address
    public var metadataModulePackage: Address
    public var royaltyModulePackage: Address
    public var accessRulesModulePackage: Address
    public var genesisHelperPackage: Address
    public var faucetPackage: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(packagePackage: Address, resourcePackage: Address, accountPackage: Address, identityPackage: Address, consensusManagerPackage: Address, accessControllerPackage: Address, poolPackage: Address, transactionProcessorPackage: Address, metadataModulePackage: Address, royaltyModulePackage: Address, accessRulesModulePackage: Address, genesisHelperPackage: Address, faucetPackage: Address) {
        self.packagePackage = packagePackage
        self.resourcePackage = resourcePackage
        self.accountPackage = accountPackage
        self.identityPackage = identityPackage
        self.consensusManagerPackage = consensusManagerPackage
        self.accessControllerPackage = accessControllerPackage
        self.poolPackage = poolPackage
        self.transactionProcessorPackage = transactionProcessorPackage
        self.metadataModulePackage = metadataModulePackage
        self.royaltyModulePackage = royaltyModulePackage
        self.accessRulesModulePackage = accessRulesModulePackage
        self.genesisHelperPackage = genesisHelperPackage
        self.faucetPackage = faucetPackage
    }
}

public struct FfiConverterTypePackageAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddresses {
        return try PackageAddresses(
            packagePackage: FfiConverterTypeAddress.read(from: &buf),
            resourcePackage: FfiConverterTypeAddress.read(from: &buf),
            accountPackage: FfiConverterTypeAddress.read(from: &buf),
            identityPackage: FfiConverterTypeAddress.read(from: &buf),
            consensusManagerPackage: FfiConverterTypeAddress.read(from: &buf),
            accessControllerPackage: FfiConverterTypeAddress.read(from: &buf),
            poolPackage: FfiConverterTypeAddress.read(from: &buf),
            transactionProcessorPackage: FfiConverterTypeAddress.read(from: &buf),
            metadataModulePackage: FfiConverterTypeAddress.read(from: &buf),
            royaltyModulePackage: FfiConverterTypeAddress.read(from: &buf),
            accessRulesModulePackage: FfiConverterTypeAddress.read(from: &buf),
            genesisHelperPackage: FfiConverterTypeAddress.read(from: &buf),
            faucetPackage: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PackageAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.packagePackage, into: &buf)
        FfiConverterTypeAddress.write(value.resourcePackage, into: &buf)
        FfiConverterTypeAddress.write(value.accountPackage, into: &buf)
        FfiConverterTypeAddress.write(value.identityPackage, into: &buf)
        FfiConverterTypeAddress.write(value.consensusManagerPackage, into: &buf)
        FfiConverterTypeAddress.write(value.accessControllerPackage, into: &buf)
        FfiConverterTypeAddress.write(value.poolPackage, into: &buf)
        FfiConverterTypeAddress.write(value.transactionProcessorPackage, into: &buf)
        FfiConverterTypeAddress.write(value.metadataModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.royaltyModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.accessRulesModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.genesisHelperPackage, into: &buf)
        FfiConverterTypeAddress.write(value.faucetPackage, into: &buf)
    }
}

public func FfiConverterTypePackageAddresses_lift(_ buf: RustBuffer) throws -> PackageAddresses {
    return try FfiConverterTypePackageAddresses.lift(buf)
}

public func FfiConverterTypePackageAddresses_lower(_ value: PackageAddresses) -> RustBuffer {
    return FfiConverterTypePackageAddresses.lower(value)
}

public struct PlainTextMessage {
    public var mimeType: String
    public var message: MessageContent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContent) {
        self.mimeType = mimeType
        self.message = message
    }
}

extension PlainTextMessage: Equatable, Hashable {
    public static func == (lhs: PlainTextMessage, rhs: PlainTextMessage) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}

public struct FfiConverterTypePlainTextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlainTextMessage {
        return try PlainTextMessage(
            mimeType: FfiConverterString.read(from: &buf),
            message: FfiConverterTypeMessageContent.read(from: &buf)
        )
    }

    public static func write(_ value: PlainTextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContent.write(value.message, into: &buf)
    }
}

public func FfiConverterTypePlainTextMessage_lift(_ buf: RustBuffer) throws -> PlainTextMessage {
    return try FfiConverterTypePlainTextMessage.lift(buf)
}

public func FfiConverterTypePlainTextMessage_lower(_ value: PlainTextMessage) -> RustBuffer {
    return FfiConverterTypePlainTextMessage.lower(value)
}

public struct ResourceAddresses {
    public var xrd: Address
    public var secp256k1SignatureVirtualBadge: Address
    public var ed25519SignatureVirtualBadge: Address
    public var packageOfDirectCallerVirtualBadge: Address
    public var globalCallerVirtualBadge: Address
    public var systemTransactionBadge: Address
    public var packageOwnerBadge: Address
    public var validatorOwnerBadge: Address
    public var accountOwnerBadge: Address
    public var identityOwnerBadge: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(xrd: Address, secp256k1SignatureVirtualBadge: Address, ed25519SignatureVirtualBadge: Address, packageOfDirectCallerVirtualBadge: Address, globalCallerVirtualBadge: Address, systemTransactionBadge: Address, packageOwnerBadge: Address, validatorOwnerBadge: Address, accountOwnerBadge: Address, identityOwnerBadge: Address) {
        self.xrd = xrd
        self.secp256k1SignatureVirtualBadge = secp256k1SignatureVirtualBadge
        self.ed25519SignatureVirtualBadge = ed25519SignatureVirtualBadge
        self.packageOfDirectCallerVirtualBadge = packageOfDirectCallerVirtualBadge
        self.globalCallerVirtualBadge = globalCallerVirtualBadge
        self.systemTransactionBadge = systemTransactionBadge
        self.packageOwnerBadge = packageOwnerBadge
        self.validatorOwnerBadge = validatorOwnerBadge
        self.accountOwnerBadge = accountOwnerBadge
        self.identityOwnerBadge = identityOwnerBadge
    }
}

public struct FfiConverterTypeResourceAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddresses {
        return try ResourceAddresses(
            xrd: FfiConverterTypeAddress.read(from: &buf),
            secp256k1SignatureVirtualBadge: FfiConverterTypeAddress.read(from: &buf),
            ed25519SignatureVirtualBadge: FfiConverterTypeAddress.read(from: &buf),
            packageOfDirectCallerVirtualBadge: FfiConverterTypeAddress.read(from: &buf),
            globalCallerVirtualBadge: FfiConverterTypeAddress.read(from: &buf),
            systemTransactionBadge: FfiConverterTypeAddress.read(from: &buf),
            packageOwnerBadge: FfiConverterTypeAddress.read(from: &buf),
            validatorOwnerBadge: FfiConverterTypeAddress.read(from: &buf),
            accountOwnerBadge: FfiConverterTypeAddress.read(from: &buf),
            identityOwnerBadge: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.xrd, into: &buf)
        FfiConverterTypeAddress.write(value.secp256k1SignatureVirtualBadge, into: &buf)
        FfiConverterTypeAddress.write(value.ed25519SignatureVirtualBadge, into: &buf)
        FfiConverterTypeAddress.write(value.packageOfDirectCallerVirtualBadge, into: &buf)
        FfiConverterTypeAddress.write(value.globalCallerVirtualBadge, into: &buf)
        FfiConverterTypeAddress.write(value.systemTransactionBadge, into: &buf)
        FfiConverterTypeAddress.write(value.packageOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.validatorOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.accountOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.identityOwnerBadge, into: &buf)
    }
}

public func FfiConverterTypeResourceAddresses_lift(_ buf: RustBuffer) throws -> ResourceAddresses {
    return try FfiConverterTypeResourceAddresses.lift(buf)
}

public func FfiConverterTypeResourceAddresses_lower(_ value: ResourceAddresses) -> RustBuffer {
    return FfiConverterTypeResourceAddresses.lower(value)
}

public struct Schema {
    public var localTypeIndex: LocalTypeIndex
    public var schema: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localTypeIndex: LocalTypeIndex, schema: [UInt8]) {
        self.localTypeIndex = localTypeIndex
        self.schema = schema
    }
}

extension Schema: Equatable, Hashable {
    public static func == (lhs: Schema, rhs: Schema) -> Bool {
        if lhs.localTypeIndex != rhs.localTypeIndex {
            return false
        }
        if lhs.schema != rhs.schema {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localTypeIndex)
        hasher.combine(schema)
    }
}

public struct FfiConverterTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Schema {
        return try Schema(
            localTypeIndex: FfiConverterTypeLocalTypeIndex.read(from: &buf),
            schema: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Schema, into buf: inout [UInt8]) {
        FfiConverterTypeLocalTypeIndex.write(value.localTypeIndex, into: &buf)
        FfiConverterSequenceUInt8.write(value.schema, into: &buf)
    }
}

public func FfiConverterTypeSchema_lift(_ buf: RustBuffer) throws -> Schema {
    return try FfiConverterTypeSchema.lift(buf)
}

public func FfiConverterTypeSchema_lower(_ value: Schema) -> RustBuffer {
    return FfiConverterTypeSchema.lower(value)
}

public struct Secp256k1PublicKey {
    public var value: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [UInt8]) {
        self.value = value
    }
}

extension Secp256k1PublicKey: Equatable, Hashable {
    public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return try Secp256k1PublicKey(
            value: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}

public struct TransactionHeader {
    public var networkId: UInt8
    public var startEpochInclusive: UInt64
    public var endEpochExclusive: UInt64
    public var nonce: UInt32
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: UInt8, startEpochInclusive: UInt64, endEpochExclusive: UInt64, nonce: UInt32, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}

extension TransactionHeader: Equatable, Hashable {
    public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}

public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return try TransactionHeader(
            networkId: FfiConverterUInt8.read(from: &buf),
            startEpochInclusive: FfiConverterUInt64.read(from: &buf),
            endEpochExclusive: FfiConverterUInt64.read(from: &buf),
            nonce: FfiConverterUInt32.read(from: &buf),
            notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
            notaryIsSignatory: FfiConverterBool.read(from: &buf),
            tipPercentage: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.networkId, into: &buf)
        FfiConverterUInt64.write(value.startEpochInclusive, into: &buf)
        FfiConverterUInt64.write(value.endEpochExclusive, into: &buf)
        FfiConverterUInt32.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CurveType {
    case ed25519
    case secp256k1
}

public struct FfiConverterTypeCurveType: FfiConverterRustBuffer {
    typealias SwiftType = CurveType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurveType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .ed25519

        case 2: return .secp256k1

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CurveType, into buf: inout [UInt8]) {
        switch value {
        case .ed25519:
            writeInt(&buf, Int32(1))

        case .secp256k1:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeCurveType_lift(_ buf: RustBuffer) throws -> CurveType {
    return try FfiConverterTypeCurveType.lift(buf)
}

public func FfiConverterTypeCurveType_lower(_ value: CurveType) -> RustBuffer {
    return FfiConverterTypeCurveType.lower(value)
}

extension CurveType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecryptorsByCurve {
    case ed25519(dhEphemeralPublicKey: Ed25519PublicKey, decryptors: [[UInt8]: [UInt8]])
    case secp256k1(dhEphemeralPublicKey: Secp256k1PublicKey, decryptors: [[UInt8]: [UInt8]])
}

public struct FfiConverterTypeDecryptorsByCurve: FfiConverterRustBuffer {
    typealias SwiftType = DecryptorsByCurve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptorsByCurve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(
                dhEphemeralPublicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                decryptors: FfiConverterDictionarySequenceUInt8SequenceUInt8.read(from: &buf)
            )

        case 2: return try .secp256k1(
                dhEphemeralPublicKey: FfiConverterTypeSecp256k1PublicKey.read(from: &buf),
                decryptors: FfiConverterDictionarySequenceUInt8SequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptorsByCurve, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(dhEphemeralPublicKey, decryptors):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionarySequenceUInt8SequenceUInt8.write(decryptors, into: &buf)

        case let .secp256k1(dhEphemeralPublicKey, decryptors):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionarySequenceUInt8SequenceUInt8.write(decryptors, into: &buf)
        }
    }
}

public func FfiConverterTypeDecryptorsByCurve_lift(_ buf: RustBuffer) throws -> DecryptorsByCurve {
    return try FfiConverterTypeDecryptorsByCurve.lift(buf)
}

public func FfiConverterTypeDecryptorsByCurve_lower(_ value: DecryptorsByCurve) -> RustBuffer {
    return FfiConverterTypeDecryptorsByCurve.lower(value)
}

extension DecryptorsByCurve: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DependencyInformation {
    case version(value: String)
    case tag(value: String)
    case branch(value: String)
    case rev(value: String)
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version(
                value: FfiConverterString.read(from: &buf)
            )

        case 2: return try .tag(
                value: FfiConverterString.read(from: &buf)
            )

        case 3: return try .branch(
                value: FfiConverterString.read(from: &buf)
            )

        case 4: return try .rev(
                value: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        case let .version(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)

        case let .tag(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)

        case let .branch(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)

        case let .rev(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}

extension DependencyInformation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EntityType {
    case globalPackage
    case globalFungibleResourceManager
    case globalNonFungibleResourceManager
    case globalConsensusManager
    case globalValidator
    case globalAccessController
    case globalAccount
    case globalIdentity
    case globalGenericComponent
    case globalVirtualSecp256k1Account
    case globalVirtualEd25519Account
    case globalVirtualSecp256k1Identity
    case globalVirtualEd25519Identity
    case globalOneResourcePool
    case globalTwoResourcePool
    case globalMultiResourcePool
    case globalTransactionTracker
    case internalFungibleVault
    case internalNonFungibleVault
    case internalAccount
    case internalGenericComponent
    case internalKeyValueStore
}

public struct FfiConverterTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = EntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .globalPackage

        case 2: return .globalFungibleResourceManager

        case 3: return .globalNonFungibleResourceManager

        case 4: return .globalConsensusManager

        case 5: return .globalValidator

        case 6: return .globalAccessController

        case 7: return .globalAccount

        case 8: return .globalIdentity

        case 9: return .globalGenericComponent

        case 10: return .globalVirtualSecp256k1Account

        case 11: return .globalVirtualEd25519Account

        case 12: return .globalVirtualSecp256k1Identity

        case 13: return .globalVirtualEd25519Identity

        case 14: return .globalOneResourcePool

        case 15: return .globalTwoResourcePool

        case 16: return .globalMultiResourcePool

        case 17: return .globalTransactionTracker

        case 18: return .internalFungibleVault

        case 19: return .internalNonFungibleVault

        case 20: return .internalAccount

        case 21: return .internalGenericComponent

        case 22: return .internalKeyValueStore

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityType, into buf: inout [UInt8]) {
        switch value {
        case .globalPackage:
            writeInt(&buf, Int32(1))

        case .globalFungibleResourceManager:
            writeInt(&buf, Int32(2))

        case .globalNonFungibleResourceManager:
            writeInt(&buf, Int32(3))

        case .globalConsensusManager:
            writeInt(&buf, Int32(4))

        case .globalValidator:
            writeInt(&buf, Int32(5))

        case .globalAccessController:
            writeInt(&buf, Int32(6))

        case .globalAccount:
            writeInt(&buf, Int32(7))

        case .globalIdentity:
            writeInt(&buf, Int32(8))

        case .globalGenericComponent:
            writeInt(&buf, Int32(9))

        case .globalVirtualSecp256k1Account:
            writeInt(&buf, Int32(10))

        case .globalVirtualEd25519Account:
            writeInt(&buf, Int32(11))

        case .globalVirtualSecp256k1Identity:
            writeInt(&buf, Int32(12))

        case .globalVirtualEd25519Identity:
            writeInt(&buf, Int32(13))

        case .globalOneResourcePool:
            writeInt(&buf, Int32(14))

        case .globalTwoResourcePool:
            writeInt(&buf, Int32(15))

        case .globalMultiResourcePool:
            writeInt(&buf, Int32(16))

        case .globalTransactionTracker:
            writeInt(&buf, Int32(17))

        case .internalFungibleVault:
            writeInt(&buf, Int32(18))

        case .internalNonFungibleVault:
            writeInt(&buf, Int32(19))

        case .internalAccount:
            writeInt(&buf, Int32(20))

        case .internalGenericComponent:
            writeInt(&buf, Int32(21))

        case .internalKeyValueStore:
            writeInt(&buf, Int32(22))
        }
    }
}

public func FfiConverterTypeEntityType_lift(_ buf: RustBuffer) throws -> EntityType {
    return try FfiConverterTypeEntityType.lift(buf)
}

public func FfiConverterTypeEntityType_lower(_ value: EntityType) -> RustBuffer {
    return FfiConverterTypeEntityType.lower(value)
}

extension EntityType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Instruction {
    case takeAllFromWorktop(resourceAddress: Address)
    case takeFromWorktop(resourceAddress: Address, amount: Decimal)
    case takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId])
    case returnToWorktop(bucketId: ManifestBucket)
    case assertWorktopContains(resourceAddress: Address, amount: Decimal)
    case assertWorktopContainsAny(resourceAddress: Address)
    case assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case popFromAuthZone
    case pushToAuthZone(proofId: ManifestProof)
    case clearAuthZone
    case createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal)
    case createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case createProofFromAuthZoneOfAll(resourceAddress: Address)
    case clearSignatureProofs
    case createProofFromBucketOfAmount(bucketId: ManifestBucket, amount: Decimal)
    case createProofFromBucketOfNonFungibles(bucketId: ManifestBucket, ids: [NonFungibleLocalId])
    case createProofFromBucketOfAll(bucketId: ManifestBucket)
    case burnResource(bucketId: ManifestBucket)
    case cloneProof(proofId: ManifestProof)
    case dropProof(proofId: ManifestProof)
    case callFunction(packageAddress: ManifestAddress, blueprintName: String, functionName: String, args: ManifestValue)
    case callMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callRoyaltyMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callMetadataMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callAccessRulesMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callDirectVaultMethod(address: Address, methodName: String, args: ManifestValue)
    case dropAllProofs
    case allocateGlobalAddress(packageAddress: Address, blueprintName: String)
}

public struct FfiConverterTypeInstruction: FfiConverterRustBuffer {
    typealias SwiftType = Instruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .takeAllFromWorktop(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf)
            )

        case 2: return try .takeFromWorktop(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 3: return try .takeNonFungiblesFromWorktop(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        case 4: return try .returnToWorktop(
                bucketId: FfiConverterTypeManifestBucket.read(from: &buf)
            )

        case 5: return try .assertWorktopContains(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 6: return try .assertWorktopContainsAny(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf)
            )

        case 7: return try .assertWorktopContainsNonFungibles(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        case 8: return .popFromAuthZone

        case 9: return try .pushToAuthZone(
                proofId: FfiConverterTypeManifestProof.read(from: &buf)
            )

        case 10: return .clearAuthZone

        case 11: return try .createProofFromAuthZoneOfAmount(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 12: return try .createProofFromAuthZoneOfNonFungibles(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        case 13: return try .createProofFromAuthZoneOfAll(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf)
            )

        case 14: return .clearSignatureProofs

        case 15: return try .createProofFromBucketOfAmount(
                bucketId: FfiConverterTypeManifestBucket.read(from: &buf),
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 16: return try .createProofFromBucketOfNonFungibles(
                bucketId: FfiConverterTypeManifestBucket.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        case 17: return try .createProofFromBucketOfAll(
                bucketId: FfiConverterTypeManifestBucket.read(from: &buf)
            )

        case 18: return try .burnResource(
                bucketId: FfiConverterTypeManifestBucket.read(from: &buf)
            )

        case 19: return try .cloneProof(
                proofId: FfiConverterTypeManifestProof.read(from: &buf)
            )

        case 20: return try .dropProof(
                proofId: FfiConverterTypeManifestProof.read(from: &buf)
            )

        case 21: return try .callFunction(
                packageAddress: FfiConverterTypeManifestAddress.read(from: &buf),
                blueprintName: FfiConverterString.read(from: &buf),
                functionName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 22: return try .callMethod(
                address: FfiConverterTypeManifestAddress.read(from: &buf),
                methodName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 23: return try .callRoyaltyMethod(
                address: FfiConverterTypeManifestAddress.read(from: &buf),
                methodName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 24: return try .callMetadataMethod(
                address: FfiConverterTypeManifestAddress.read(from: &buf),
                methodName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 25: return try .callAccessRulesMethod(
                address: FfiConverterTypeManifestAddress.read(from: &buf),
                methodName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 26: return try .callDirectVaultMethod(
                address: FfiConverterTypeAddress.read(from: &buf),
                methodName: FfiConverterString.read(from: &buf),
                args: FfiConverterTypeManifestValue.read(from: &buf)
            )

        case 27: return .dropAllProofs

        case 28: return try .allocateGlobalAddress(
                packageAddress: FfiConverterTypeAddress.read(from: &buf),
                blueprintName: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Instruction, into buf: inout [UInt8]) {
        switch value {
        case let .takeAllFromWorktop(resourceAddress):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)

        case let .takeFromWorktop(resourceAddress, amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .takeNonFungiblesFromWorktop(resourceAddress, ids):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)

        case let .returnToWorktop(bucketId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)

        case let .assertWorktopContains(resourceAddress, amount):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .assertWorktopContainsAny(resourceAddress):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)

        case let .assertWorktopContainsNonFungibles(resourceAddress, ids):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)

        case .popFromAuthZone:
            writeInt(&buf, Int32(8))

        case let .pushToAuthZone(proofId):
            writeInt(&buf, Int32(9))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)

        case .clearAuthZone:
            writeInt(&buf, Int32(10))

        case let .createProofFromAuthZoneOfAmount(resourceAddress, amount):
            writeInt(&buf, Int32(11))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .createProofFromAuthZoneOfNonFungibles(resourceAddress, ids):
            writeInt(&buf, Int32(12))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)

        case let .createProofFromAuthZoneOfAll(resourceAddress):
            writeInt(&buf, Int32(13))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)

        case .clearSignatureProofs:
            writeInt(&buf, Int32(14))

        case let .createProofFromBucketOfAmount(bucketId, amount):
            writeInt(&buf, Int32(15))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .createProofFromBucketOfNonFungibles(bucketId, ids):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)

        case let .createProofFromBucketOfAll(bucketId):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)

        case let .burnResource(bucketId):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)

        case let .cloneProof(proofId):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)

        case let .dropProof(proofId):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)

        case let .callFunction(packageAddress, blueprintName, functionName, args):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            FfiConverterString.write(functionName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case let .callMethod(address, methodName, args):
            writeInt(&buf, Int32(22))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case let .callRoyaltyMethod(address, methodName, args):
            writeInt(&buf, Int32(23))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case let .callMetadataMethod(address, methodName, args):
            writeInt(&buf, Int32(24))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case let .callAccessRulesMethod(address, methodName, args):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case let .callDirectVaultMethod(address, methodName, args):
            writeInt(&buf, Int32(26))
            FfiConverterTypeAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)

        case .dropAllProofs:
            writeInt(&buf, Int32(27))

        case let .allocateGlobalAddress(packageAddress, blueprintName):
            writeInt(&buf, Int32(28))
            FfiConverterTypeAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
        }
    }
}

public func FfiConverterTypeInstruction_lift(_ buf: RustBuffer) throws -> Instruction {
    return try FfiConverterTypeInstruction.lift(buf)
}

public func FfiConverterTypeInstruction_lower(_ value: Instruction) -> RustBuffer {
    return FfiConverterTypeInstruction.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTypeIndex {
    case wellKnown(value: UInt8)
    case schemaLocalIndex(value: UInt64)
}

public struct FfiConverterTypeLocalTypeIndex: FfiConverterRustBuffer {
    typealias SwiftType = LocalTypeIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalTypeIndex {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .wellKnown(
                value: FfiConverterUInt8.read(from: &buf)
            )

        case 2: return try .schemaLocalIndex(
                value: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LocalTypeIndex, into buf: inout [UInt8]) {
        switch value {
        case let .wellKnown(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt8.write(value, into: &buf)

        case let .schemaLocalIndex(value):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeLocalTypeIndex_lift(_ buf: RustBuffer) throws -> LocalTypeIndex {
    return try FfiConverterTypeLocalTypeIndex.lift(buf)
}

public func FfiConverterTypeLocalTypeIndex_lower(_ value: LocalTypeIndex) -> RustBuffer {
    return FfiConverterTypeLocalTypeIndex.lower(value)
}

extension LocalTypeIndex: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestAddress {
    case named(value: UInt32)
    case `static`(value: Address)
}

public struct FfiConverterTypeManifestAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .named(
                value: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return try .static(
                value: FfiConverterTypeAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestAddress, into buf: inout [UInt8]) {
        switch value {
        case let .named(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(value, into: &buf)

        case let .static(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeManifestAddress_lift(_ buf: RustBuffer) throws -> ManifestAddress {
    return try FfiConverterTypeManifestAddress.lift(buf)
}

public func FfiConverterTypeManifestAddress_lower(_ value: ManifestAddress) -> RustBuffer {
    return FfiConverterTypeManifestAddress.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestExpression {
    case entireWorktop
    case entireAuthZone
}

public struct FfiConverterTypeManifestExpression: FfiConverterRustBuffer {
    typealias SwiftType = ManifestExpression

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestExpression {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .entireWorktop

        case 2: return .entireAuthZone

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestExpression, into buf: inout [UInt8]) {
        switch value {
        case .entireWorktop:
            writeInt(&buf, Int32(1))

        case .entireAuthZone:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeManifestExpression_lift(_ buf: RustBuffer) throws -> ManifestExpression {
    return try FfiConverterTypeManifestExpression.lift(buf)
}

public func FfiConverterTypeManifestExpression_lower(_ value: ManifestExpression) -> RustBuffer {
    return FfiConverterTypeManifestExpression.lower(value)
}

extension ManifestExpression: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestSborStringRepresentation {
    case manifestString
    case json(value: SerializationMode)
}

public struct FfiConverterTypeManifestSborStringRepresentation: FfiConverterRustBuffer {
    typealias SwiftType = ManifestSborStringRepresentation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSborStringRepresentation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .manifestString

        case 2: return try .json(
                value: FfiConverterTypeSerializationMode.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestSborStringRepresentation, into buf: inout [UInt8]) {
        switch value {
        case .manifestString:
            writeInt(&buf, Int32(1))

        case let .json(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSerializationMode.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeManifestSborStringRepresentation_lift(_ buf: RustBuffer) throws -> ManifestSborStringRepresentation {
    return try FfiConverterTypeManifestSborStringRepresentation.lift(buf)
}

public func FfiConverterTypeManifestSborStringRepresentation_lower(_ value: ManifestSborStringRepresentation) -> RustBuffer {
    return FfiConverterTypeManifestSborStringRepresentation.lower(value)
}

extension ManifestSborStringRepresentation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValue {
    case boolValue(value: Bool)
    case i8Value(value: Int8)
    case i16Value(value: Int16)
    case i32Value(value: Int32)
    case i64Value(value: Int64)
    case i128Value(value: String)
    case u8Value(value: UInt8)
    case u16Value(value: UInt16)
    case u32Value(value: UInt32)
    case u64Value(value: UInt64)
    case u128Value(value: String)
    case stringValue(value: String)
    case enumValue(discriminator: UInt8, fields: [ManifestValue])
    case arrayValue(elementValueKind: ManifestValueKind, elements: [ManifestValue])
    case tupleValue(fields: [ManifestValue])
    case mapValue(keyValueKind: ManifestValueKind, valueValueKind: ManifestValueKind, entries: [MapEntry])
    case addressValue(value: ManifestAddress)
    case bucketValue(value: ManifestBucket)
    case proofValue(value: ManifestProof)
    case expressionValue(value: ManifestExpression)
    case blobValue(value: ManifestBlobRef)
    case decimalValue(value: Decimal)
    case preciseDecimalValue(value: PreciseDecimal)
    case nonFungibleLocalIdValue(value: NonFungibleLocalId)
    case addressReservationValue(value: ManifestAddressReservation)
}

public struct FfiConverterTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .boolValue(
                value: FfiConverterBool.read(from: &buf)
            )

        case 2: return try .i8Value(
                value: FfiConverterInt8.read(from: &buf)
            )

        case 3: return try .i16Value(
                value: FfiConverterInt16.read(from: &buf)
            )

        case 4: return try .i32Value(
                value: FfiConverterInt32.read(from: &buf)
            )

        case 5: return try .i64Value(
                value: FfiConverterInt64.read(from: &buf)
            )

        case 6: return try .i128Value(
                value: FfiConverterString.read(from: &buf)
            )

        case 7: return try .u8Value(
                value: FfiConverterUInt8.read(from: &buf)
            )

        case 8: return try .u16Value(
                value: FfiConverterUInt16.read(from: &buf)
            )

        case 9: return try .u32Value(
                value: FfiConverterUInt32.read(from: &buf)
            )

        case 10: return try .u64Value(
                value: FfiConverterUInt64.read(from: &buf)
            )

        case 11: return try .u128Value(
                value: FfiConverterString.read(from: &buf)
            )

        case 12: return try .stringValue(
                value: FfiConverterString.read(from: &buf)
            )

        case 13: return try .enumValue(
                discriminator: FfiConverterUInt8.read(from: &buf),
                fields: FfiConverterSequenceTypeManifestValue.read(from: &buf)
            )

        case 14: return try .arrayValue(
                elementValueKind: FfiConverterTypeManifestValueKind.read(from: &buf),
                elements: FfiConverterSequenceTypeManifestValue.read(from: &buf)
            )

        case 15: return try .tupleValue(
                fields: FfiConverterSequenceTypeManifestValue.read(from: &buf)
            )

        case 16: return try .mapValue(
                keyValueKind: FfiConverterTypeManifestValueKind.read(from: &buf),
                valueValueKind: FfiConverterTypeManifestValueKind.read(from: &buf),
                entries: FfiConverterSequenceTypeMapEntry.read(from: &buf)
            )

        case 17: return try .addressValue(
                value: FfiConverterTypeManifestAddress.read(from: &buf)
            )

        case 18: return try .bucketValue(
                value: FfiConverterTypeManifestBucket.read(from: &buf)
            )

        case 19: return try .proofValue(
                value: FfiConverterTypeManifestProof.read(from: &buf)
            )

        case 20: return try .expressionValue(
                value: FfiConverterTypeManifestExpression.read(from: &buf)
            )

        case 21: return try .blobValue(
                value: FfiConverterTypeManifestBlobRef.read(from: &buf)
            )

        case 22: return try .decimalValue(
                value: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 23: return try .preciseDecimalValue(
                value: FfiConverterTypePreciseDecimal.read(from: &buf)
            )

        case 24: return try .nonFungibleLocalIdValue(
                value: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )

        case 25: return try .addressReservationValue(
                value: FfiConverterTypeManifestAddressReservation.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValue, into buf: inout [UInt8]) {
        switch value {
        case let .boolValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(value, into: &buf)

        case let .i8Value(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(value, into: &buf)

        case let .i16Value(value):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(value, into: &buf)

        case let .i32Value(value):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(value, into: &buf)

        case let .i64Value(value):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(value, into: &buf)

        case let .i128Value(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)

        case let .u8Value(value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(value, into: &buf)

        case let .u16Value(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(value, into: &buf)

        case let .u32Value(value):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(value, into: &buf)

        case let .u64Value(value):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(value, into: &buf)

        case let .u128Value(value):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(value, into: &buf)

        case let .stringValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(value, into: &buf)

        case let .enumValue(discriminator, fields):
            writeInt(&buf, Int32(13))
            FfiConverterUInt8.write(discriminator, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(fields, into: &buf)

        case let .arrayValue(elementValueKind, elements):
            writeInt(&buf, Int32(14))
            FfiConverterTypeManifestValueKind.write(elementValueKind, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(elements, into: &buf)

        case let .tupleValue(fields):
            writeInt(&buf, Int32(15))
            FfiConverterSequenceTypeManifestValue.write(fields, into: &buf)

        case let .mapValue(keyValueKind, valueValueKind, entries):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestValueKind.write(keyValueKind, into: &buf)
            FfiConverterTypeManifestValueKind.write(valueValueKind, into: &buf)
            FfiConverterSequenceTypeMapEntry.write(entries, into: &buf)

        case let .addressValue(value):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestAddress.write(value, into: &buf)

        case let .bucketValue(value):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(value, into: &buf)

        case let .proofValue(value):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestProof.write(value, into: &buf)

        case let .expressionValue(value):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestExpression.write(value, into: &buf)

        case let .blobValue(value):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBlobRef.write(value, into: &buf)

        case let .decimalValue(value):
            writeInt(&buf, Int32(22))
            FfiConverterTypeDecimal.write(value, into: &buf)

        case let .preciseDecimalValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterTypePreciseDecimal.write(value, into: &buf)

        case let .nonFungibleLocalIdValue(value):
            writeInt(&buf, Int32(24))
            FfiConverterTypeNonFungibleLocalId.write(value, into: &buf)

        case let .addressReservationValue(value):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddressReservation.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeManifestValue_lift(_ buf: RustBuffer) throws -> ManifestValue {
    return try FfiConverterTypeManifestValue.lift(buf)
}

public func FfiConverterTypeManifestValue_lower(_ value: ManifestValue) -> RustBuffer {
    return FfiConverterTypeManifestValue.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValueKind {
    case boolValue
    case i8Value
    case i16Value
    case i32Value
    case i64Value
    case i128Value
    case u8Value
    case u16Value
    case u32Value
    case u64Value
    case u128Value
    case stringValue
    case enumValue
    case arrayValue
    case tupleValue
    case mapValue
    case addressValue
    case bucketValue
    case proofValue
    case expressionValue
    case blobValue
    case decimalValue
    case preciseDecimalValue
    case nonFungibleLocalIdValue
    case addressReservationValue
}

public struct FfiConverterTypeManifestValueKind: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValueKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValueKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .boolValue

        case 2: return .i8Value

        case 3: return .i16Value

        case 4: return .i32Value

        case 5: return .i64Value

        case 6: return .i128Value

        case 7: return .u8Value

        case 8: return .u16Value

        case 9: return .u32Value

        case 10: return .u64Value

        case 11: return .u128Value

        case 12: return .stringValue

        case 13: return .enumValue

        case 14: return .arrayValue

        case 15: return .tupleValue

        case 16: return .mapValue

        case 17: return .addressValue

        case 18: return .bucketValue

        case 19: return .proofValue

        case 20: return .expressionValue

        case 21: return .blobValue

        case 22: return .decimalValue

        case 23: return .preciseDecimalValue

        case 24: return .nonFungibleLocalIdValue

        case 25: return .addressReservationValue

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValueKind, into buf: inout [UInt8]) {
        switch value {
        case .boolValue:
            writeInt(&buf, Int32(1))

        case .i8Value:
            writeInt(&buf, Int32(2))

        case .i16Value:
            writeInt(&buf, Int32(3))

        case .i32Value:
            writeInt(&buf, Int32(4))

        case .i64Value:
            writeInt(&buf, Int32(5))

        case .i128Value:
            writeInt(&buf, Int32(6))

        case .u8Value:
            writeInt(&buf, Int32(7))

        case .u16Value:
            writeInt(&buf, Int32(8))

        case .u32Value:
            writeInt(&buf, Int32(9))

        case .u64Value:
            writeInt(&buf, Int32(10))

        case .u128Value:
            writeInt(&buf, Int32(11))

        case .stringValue:
            writeInt(&buf, Int32(12))

        case .enumValue:
            writeInt(&buf, Int32(13))

        case .arrayValue:
            writeInt(&buf, Int32(14))

        case .tupleValue:
            writeInt(&buf, Int32(15))

        case .mapValue:
            writeInt(&buf, Int32(16))

        case .addressValue:
            writeInt(&buf, Int32(17))

        case .bucketValue:
            writeInt(&buf, Int32(18))

        case .proofValue:
            writeInt(&buf, Int32(19))

        case .expressionValue:
            writeInt(&buf, Int32(20))

        case .blobValue:
            writeInt(&buf, Int32(21))

        case .decimalValue:
            writeInt(&buf, Int32(22))

        case .preciseDecimalValue:
            writeInt(&buf, Int32(23))

        case .nonFungibleLocalIdValue:
            writeInt(&buf, Int32(24))

        case .addressReservationValue:
            writeInt(&buf, Int32(25))
        }
    }
}

public func FfiConverterTypeManifestValueKind_lift(_ buf: RustBuffer) throws -> ManifestValueKind {
    return try FfiConverterTypeManifestValueKind.lift(buf)
}

public func FfiConverterTypeManifestValueKind_lower(_ value: ManifestValueKind) -> RustBuffer {
    return FfiConverterTypeManifestValueKind.lower(value)
}

extension ManifestValueKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Message {
    case none
    case plainText(value: PlainTextMessage)
    case encrypted(value: EncryptedMessage)
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return try .plainText(
                value: FfiConverterTypePlainTextMessage.read(from: &buf)
            )

        case 3: return try .encrypted(
                value: FfiConverterTypeEncryptedMessage.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case let .plainText(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypePlainTextMessage.write(value, into: &buf)

        case let .encrypted(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEncryptedMessage.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

extension Message: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageContent {
    case str(value: String)
    case bytes(value: [UInt8])
}

public struct FfiConverterTypeMessageContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .str(
                value: FfiConverterString.read(from: &buf)
            )

        case 2: return try .bytes(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContent, into buf: inout [UInt8]) {
        switch value {
        case let .str(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeMessageContent_lift(_ buf: RustBuffer) throws -> MessageContent {
    return try FfiConverterTypeMessageContent.lift(buf)
}

public func FfiConverterTypeMessageContent_lower(_ value: MessageContent) -> RustBuffer {
    return FfiConverterTypeMessageContent.lower(value)
}

extension MessageContent: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MetadataValue {
    case stringValue(value: String)
    case boolValue(value: Bool)
    case u8Value(value: UInt8)
    case u32Value(value: UInt32)
    case u64Value(value: UInt64)
    case i32Value(value: Int32)
    case i64Value(value: Int64)
    case decimalValue(value: Decimal)
    case globalAddressValue(value: Address)
    case publicKeyValue(value: PublicKey)
    case nonFungibleGlobalIdValue(value: NonFungibleGlobalId)
    case nonFungibleLocalIdValue(value: NonFungibleLocalId)
    case instantValue(value: Int64)
    case urlValue(value: String)
    case originValue(value: String)
    case publicKeyHashValue(value: PublicKeyHash)
    case stringArrayValue(value: [String])
    case boolArrayValue(value: [Bool])
    case u8ArrayValue(value: [UInt8])
    case u32ArrayValue(value: [UInt32])
    case u64ArrayValue(value: [UInt64])
    case i32ArrayValue(value: [Int32])
    case i64ArrayValue(value: [Int64])
    case decimalArrayValue(value: [Decimal])
    case globalAddressArrayValue(value: [Address])
    case publicKeyArrayValue(value: [PublicKey])
    case nonFungibleGlobalIdArrayValue(value: [NonFungibleGlobalId])
    case nonFungibleLocalIdArrayValue(value: [NonFungibleLocalId])
    case instantArrayValue(value: [Int64])
    case urlArrayValue(value: [String])
    case originArrayValue(value: [String])
    case publicKeyHashArrayValue(value: [PublicKeyHash])
}

public struct FfiConverterTypeMetadataValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .stringValue(
                value: FfiConverterString.read(from: &buf)
            )

        case 2: return try .boolValue(
                value: FfiConverterBool.read(from: &buf)
            )

        case 3: return try .u8Value(
                value: FfiConverterUInt8.read(from: &buf)
            )

        case 4: return try .u32Value(
                value: FfiConverterUInt32.read(from: &buf)
            )

        case 5: return try .u64Value(
                value: FfiConverterUInt64.read(from: &buf)
            )

        case 6: return try .i32Value(
                value: FfiConverterInt32.read(from: &buf)
            )

        case 7: return try .i64Value(
                value: FfiConverterInt64.read(from: &buf)
            )

        case 8: return try .decimalValue(
                value: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 9: return try .globalAddressValue(
                value: FfiConverterTypeAddress.read(from: &buf)
            )

        case 10: return try .publicKeyValue(
                value: FfiConverterTypePublicKey.read(from: &buf)
            )

        case 11: return try .nonFungibleGlobalIdValue(
                value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            )

        case 12: return try .nonFungibleLocalIdValue(
                value: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )

        case 13: return try .instantValue(
                value: FfiConverterInt64.read(from: &buf)
            )

        case 14: return try .urlValue(
                value: FfiConverterString.read(from: &buf)
            )

        case 15: return try .originValue(
                value: FfiConverterString.read(from: &buf)
            )

        case 16: return try .publicKeyHashValue(
                value: FfiConverterTypePublicKeyHash.read(from: &buf)
            )

        case 17: return try .stringArrayValue(
                value: FfiConverterSequenceString.read(from: &buf)
            )

        case 18: return try .boolArrayValue(
                value: FfiConverterSequenceBool.read(from: &buf)
            )

        case 19: return try .u8ArrayValue(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 20: return try .u32ArrayValue(
                value: FfiConverterSequenceUInt32.read(from: &buf)
            )

        case 21: return try .u64ArrayValue(
                value: FfiConverterSequenceUInt64.read(from: &buf)
            )

        case 22: return try .i32ArrayValue(
                value: FfiConverterSequenceInt32.read(from: &buf)
            )

        case 23: return try .i64ArrayValue(
                value: FfiConverterSequenceInt64.read(from: &buf)
            )

        case 24: return try .decimalArrayValue(
                value: FfiConverterSequenceTypeDecimal.read(from: &buf)
            )

        case 25: return try .globalAddressArrayValue(
                value: FfiConverterSequenceTypeAddress.read(from: &buf)
            )

        case 26: return try .publicKeyArrayValue(
                value: FfiConverterSequenceTypePublicKey.read(from: &buf)
            )

        case 27: return try .nonFungibleGlobalIdArrayValue(
                value: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf)
            )

        case 28: return try .nonFungibleLocalIdArrayValue(
                value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        case 29: return try .instantArrayValue(
                value: FfiConverterSequenceInt64.read(from: &buf)
            )

        case 30: return try .urlArrayValue(
                value: FfiConverterSequenceString.read(from: &buf)
            )

        case 31: return try .originArrayValue(
                value: FfiConverterSequenceString.read(from: &buf)
            )

        case 32: return try .publicKeyHashArrayValue(
                value: FfiConverterSequenceTypePublicKeyHash.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MetadataValue, into buf: inout [UInt8]) {
        switch value {
        case let .stringValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)

        case let .boolValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(value, into: &buf)

        case let .u8Value(value):
            writeInt(&buf, Int32(3))
            FfiConverterUInt8.write(value, into: &buf)

        case let .u32Value(value):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(value, into: &buf)

        case let .u64Value(value):
            writeInt(&buf, Int32(5))
            FfiConverterUInt64.write(value, into: &buf)

        case let .i32Value(value):
            writeInt(&buf, Int32(6))
            FfiConverterInt32.write(value, into: &buf)

        case let .i64Value(value):
            writeInt(&buf, Int32(7))
            FfiConverterInt64.write(value, into: &buf)

        case let .decimalValue(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeDecimal.write(value, into: &buf)

        case let .globalAddressValue(value):
            writeInt(&buf, Int32(9))
            FfiConverterTypeAddress.write(value, into: &buf)

        case let .publicKeyValue(value):
            writeInt(&buf, Int32(10))
            FfiConverterTypePublicKey.write(value, into: &buf)

        case let .nonFungibleGlobalIdValue(value):
            writeInt(&buf, Int32(11))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)

        case let .nonFungibleLocalIdValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterTypeNonFungibleLocalId.write(value, into: &buf)

        case let .instantValue(value):
            writeInt(&buf, Int32(13))
            FfiConverterInt64.write(value, into: &buf)

        case let .urlValue(value):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(value, into: &buf)

        case let .originValue(value):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(value, into: &buf)

        case let .publicKeyHashValue(value):
            writeInt(&buf, Int32(16))
            FfiConverterTypePublicKeyHash.write(value, into: &buf)

        case let .stringArrayValue(value):
            writeInt(&buf, Int32(17))
            FfiConverterSequenceString.write(value, into: &buf)

        case let .boolArrayValue(value):
            writeInt(&buf, Int32(18))
            FfiConverterSequenceBool.write(value, into: &buf)

        case let .u8ArrayValue(value):
            writeInt(&buf, Int32(19))
            FfiConverterSequenceUInt8.write(value, into: &buf)

        case let .u32ArrayValue(value):
            writeInt(&buf, Int32(20))
            FfiConverterSequenceUInt32.write(value, into: &buf)

        case let .u64ArrayValue(value):
            writeInt(&buf, Int32(21))
            FfiConverterSequenceUInt64.write(value, into: &buf)

        case let .i32ArrayValue(value):
            writeInt(&buf, Int32(22))
            FfiConverterSequenceInt32.write(value, into: &buf)

        case let .i64ArrayValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterSequenceInt64.write(value, into: &buf)

        case let .decimalArrayValue(value):
            writeInt(&buf, Int32(24))
            FfiConverterSequenceTypeDecimal.write(value, into: &buf)

        case let .globalAddressArrayValue(value):
            writeInt(&buf, Int32(25))
            FfiConverterSequenceTypeAddress.write(value, into: &buf)

        case let .publicKeyArrayValue(value):
            writeInt(&buf, Int32(26))
            FfiConverterSequenceTypePublicKey.write(value, into: &buf)

        case let .nonFungibleGlobalIdArrayValue(value):
            writeInt(&buf, Int32(27))
            FfiConverterSequenceTypeNonFungibleGlobalId.write(value, into: &buf)

        case let .nonFungibleLocalIdArrayValue(value):
            writeInt(&buf, Int32(28))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)

        case let .instantArrayValue(value):
            writeInt(&buf, Int32(29))
            FfiConverterSequenceInt64.write(value, into: &buf)

        case let .urlArrayValue(value):
            writeInt(&buf, Int32(30))
            FfiConverterSequenceString.write(value, into: &buf)

        case let .originArrayValue(value):
            writeInt(&buf, Int32(31))
            FfiConverterSequenceString.write(value, into: &buf)

        case let .publicKeyHashArrayValue(value):
            writeInt(&buf, Int32(32))
            FfiConverterSequenceTypePublicKeyHash.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeMetadataValue_lift(_ buf: RustBuffer) throws -> MetadataValue {
    return try FfiConverterTypeMetadataValue.lift(buf)
}

public func FfiConverterTypeMetadataValue_lower(_ value: MetadataValue) -> RustBuffer {
    return FfiConverterTypeMetadataValue.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleLocalId {
    case integer(value: UInt64)
    case str(value: String)
    case bytes(value: [UInt8])
    case ruid(value: [UInt8])
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .integer(
                value: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .str(
                value: FfiConverterString.read(from: &buf)
            )

        case 3: return try .bytes(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 4: return try .ruid(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)

        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceUInt8.write(value, into: &buf)

        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}

extension NonFungibleLocalId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OlympiaNetwork {
    case mainnet
    case stokenet
    case releasenet
    case rcNet
    case milestonenet
    case devopsnet
    case sandpitnet
    case localnet
}

public struct FfiConverterTypeOlympiaNetwork: FfiConverterRustBuffer {
    typealias SwiftType = OlympiaNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainnet

        case 2: return .stokenet

        case 3: return .releasenet

        case 4: return .rcNet

        case 5: return .milestonenet

        case 6: return .devopsnet

        case 7: return .sandpitnet

        case 8: return .localnet

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OlympiaNetwork, into buf: inout [UInt8]) {
        switch value {
        case .mainnet:
            writeInt(&buf, Int32(1))

        case .stokenet:
            writeInt(&buf, Int32(2))

        case .releasenet:
            writeInt(&buf, Int32(3))

        case .rcNet:
            writeInt(&buf, Int32(4))

        case .milestonenet:
            writeInt(&buf, Int32(5))

        case .devopsnet:
            writeInt(&buf, Int32(6))

        case .sandpitnet:
            writeInt(&buf, Int32(7))

        case .localnet:
            writeInt(&buf, Int32(8))
        }
    }
}

public func FfiConverterTypeOlympiaNetwork_lift(_ buf: RustBuffer) throws -> OlympiaNetwork {
    return try FfiConverterTypeOlympiaNetwork.lift(buf)
}

public func FfiConverterTypeOlympiaNetwork_lower(_ value: OlympiaNetwork) -> RustBuffer {
    return FfiConverterTypeOlympiaNetwork.lower(value)
}

extension OlympiaNetwork: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKey {
    case secp256k1(value: [UInt8])
    case ed25519(value: [UInt8])
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .ed25519(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

extension PublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKeyHash {
    case secp256k1(value: [UInt8])
    case ed25519(value: [UInt8])
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .ed25519(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}

extension PublicKeyHash: Equatable, Hashable {}

public enum RadixEngineToolkitError {
    case InvalidLength(expected: UInt64, actual: UInt64, data: [UInt8])
    case FailedToExtractNetwork(address: String)
    case Bech32DecodeError(error: String)
    case ParseError(typeName: String, error: String)
    case NonFungibleContentValidationError(error: String)
    case EntityTypeMismatchError(expected: [EntityType], actual: EntityType)
    case DerivationError(error: String)
    case InvalidPublicKey
    case CompileError(error: String)
    case DecompileError(error: String)
    case PrepareError(error: String)
    case EncodeError(error: String)
    case DecodeError(error: String)
    case TransactionValidationFailed(error: String)
    case ExecutionModuleError(error: String)
    case ManifestSborError(error: String)
    case ScryptoSborError(error: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRadixEngineToolkitError.lift(error)
    }
}

public struct FfiConverterTypeRadixEngineToolkitError: FfiConverterRustBuffer {
    typealias SwiftType = RadixEngineToolkitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixEngineToolkitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .InvalidLength(
                expected: FfiConverterUInt64.read(from: &buf),
                actual: FfiConverterUInt64.read(from: &buf),
                data: FfiConverterSequenceUInt8.read(from: &buf)
            )
        case 2: return try .FailedToExtractNetwork(
                address: FfiConverterString.read(from: &buf)
            )
        case 3: return try .Bech32DecodeError(
                error: FfiConverterString.read(from: &buf)
            )
        case 4: return try .ParseError(
                typeName: FfiConverterString.read(from: &buf),
                error: FfiConverterString.read(from: &buf)
            )
        case 5: return try .NonFungibleContentValidationError(
                error: FfiConverterString.read(from: &buf)
            )
        case 6: return try .EntityTypeMismatchError(
                expected: FfiConverterSequenceTypeEntityType.read(from: &buf),
                actual: FfiConverterTypeEntityType.read(from: &buf)
            )
        case 7: return try .DerivationError(
                error: FfiConverterString.read(from: &buf)
            )
        case 8: return .InvalidPublicKey
        case 9: return try .CompileError(
                error: FfiConverterString.read(from: &buf)
            )
        case 10: return try .DecompileError(
                error: FfiConverterString.read(from: &buf)
            )
        case 11: return try .PrepareError(
                error: FfiConverterString.read(from: &buf)
            )
        case 12: return try .EncodeError(
                error: FfiConverterString.read(from: &buf)
            )
        case 13: return try .DecodeError(
                error: FfiConverterString.read(from: &buf)
            )
        case 14: return try .TransactionValidationFailed(
                error: FfiConverterString.read(from: &buf)
            )
        case 15: return try .ExecutionModuleError(
                error: FfiConverterString.read(from: &buf)
            )
        case 16: return try .ManifestSborError(
                error: FfiConverterString.read(from: &buf)
            )
        case 17: return try .ScryptoSborError(
                error: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixEngineToolkitError, into buf: inout [UInt8]) {
        switch value {
        case let .InvalidLength(expected, actual, data):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(actual, into: &buf)
            FfiConverterSequenceUInt8.write(data, into: &buf)

        case let .FailedToExtractNetwork(address):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(address, into: &buf)

        case let .Bech32DecodeError(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)

        case let .ParseError(typeName, error):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(typeName, into: &buf)
            FfiConverterString.write(error, into: &buf)

        case let .NonFungibleContentValidationError(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)

        case let .EntityTypeMismatchError(expected, actual):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeEntityType.write(expected, into: &buf)
            FfiConverterTypeEntityType.write(actual, into: &buf)

        case let .DerivationError(error):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(error, into: &buf)

        case .InvalidPublicKey:
            writeInt(&buf, Int32(8))

        case let .CompileError(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)

        case let .DecompileError(error):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(error, into: &buf)

        case let .PrepareError(error):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(error, into: &buf)

        case let .EncodeError(error):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(error, into: &buf)

        case let .DecodeError(error):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(error, into: &buf)

        case let .TransactionValidationFailed(error):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(error, into: &buf)

        case let .ExecutionModuleError(error):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(error, into: &buf)

        case let .ManifestSborError(error):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(error, into: &buf)

        case let .ScryptoSborError(error):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(error, into: &buf)
        }
    }
}

extension RadixEngineToolkitError: Equatable, Hashable {}

extension RadixEngineToolkitError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceSpecifier {
    case amount(resourceAddress: Address, amount: Decimal)
    case ids(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .amount(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 2: return try .ids(
                resourceAddress: FfiConverterTypeAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        case let .amount(resourceAddress, amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .ids(resourceAddress, ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Resources {
    case amount(amount: Decimal)
    case ids(ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeResources: FfiConverterRustBuffer {
    typealias SwiftType = Resources

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Resources {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .amount(
                amount: FfiConverterTypeDecimal.read(from: &buf)
            )

        case 2: return try .ids(
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Resources, into buf: inout [UInt8]) {
        switch value {
        case let .amount(amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(amount, into: &buf)

        case let .ids(ids):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeResources_lift(_ buf: RustBuffer) throws -> Resources {
    return try FfiConverterTypeResources.lift(buf)
}

public func FfiConverterTypeResources_lower(_ value: Resources) -> RustBuffer {
    return FfiConverterTypeResources.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoundingMode {
    case toPositiveInfinity
    case toNegativeInfinity
    case toZero
    case awayFromZero
    case toNearestMidpointTowardZero
    case toNearestMidpointAwayFromZero
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .toPositiveInfinity

        case 2: return .toNegativeInfinity

        case 3: return .toZero

        case 4: return .awayFromZero

        case 5: return .toNearestMidpointTowardZero

        case 6: return .toNearestMidpointAwayFromZero

        case 7: return .toNearestMidpointToEven

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))

        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))

        case .toZero:
            writeInt(&buf, Int32(3))

        case .awayFromZero:
            writeInt(&buf, Int32(4))

        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))

        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))

        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}

extension RoundingMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SerializationMode {
    case programmatic
    case natural
}

public struct FfiConverterTypeSerializationMode: FfiConverterRustBuffer {
    typealias SwiftType = SerializationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerializationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .programmatic

        case 2: return .natural

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerializationMode, into buf: inout [UInt8]) {
        switch value {
        case .programmatic:
            writeInt(&buf, Int32(1))

        case .natural:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeSerializationMode_lift(_ buf: RustBuffer) throws -> SerializationMode {
    return try FfiConverterTypeSerializationMode.lift(buf)
}

public func FfiConverterTypeSerializationMode_lower(_ value: SerializationMode) -> RustBuffer {
    return FfiConverterTypeSerializationMode.lower(value)
}

extension SerializationMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Signature {
    case secp256k1(value: [UInt8])
    case ed25519(value: [UInt8])
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .ed25519(
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}

extension Signature: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureWithPublicKey {
    case secp256k1(signature: [UInt8])
    case ed25519(signature: [UInt8], publicKey: [UInt8])
}

public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(
                signature: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .ed25519(
                signature: FfiConverterSequenceUInt8.read(from: &buf),
                publicKey: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(signature):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(signature, into: &buf)

        case let .ed25519(signature, publicKey):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(signature, into: &buf)
            FfiConverterSequenceUInt8.write(publicKey, into: &buf)
        }
    }
}

public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}

extension SignatureWithPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Source {
    case guaranteed(value: ResourceSpecifier)
    case predicted(instructionIndex: UInt64, value: ResourceSpecifier)
}

public struct FfiConverterTypeSource: FfiConverterRustBuffer {
    typealias SwiftType = Source

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Source {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .guaranteed(
                value: FfiConverterTypeResourceSpecifier.read(from: &buf)
            )

        case 2: return try .predicted(
                instructionIndex: FfiConverterUInt64.read(from: &buf),
                value: FfiConverterTypeResourceSpecifier.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Source, into buf: inout [UInt8]) {
        switch value {
        case let .guaranteed(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceSpecifier.write(value, into: &buf)

        case let .predicted(instructionIndex, value):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(instructionIndex, into: &buf)
            FfiConverterTypeResourceSpecifier.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSource_lift(_ buf: RustBuffer) throws -> Source {
    return try FfiConverterTypeSource.lift(buf)
}

public func FfiConverterTypeSource_lower(_ value: Source) -> RustBuffer {
    return FfiConverterTypeSource.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransactionType {
    case simpleTransfer(from: Address, to: Address, transferred: ResourceSpecifier)
    case transfer(from: Address, transfers: [String: [String: Resources]])
    case generalTransaction(accountProofs: [Address], accountWithdraws: [String: [ResourceSpecifier]], accountDeposits: [String: [Source]], addressesInManifest: [EntityType: [Address]], metadataOfNewlyCreatedEntities: [String: [String: MetadataValue]], dataOfNewlyMintedNonFungibles: [String: [NonFungibleLocalId: [UInt8]]])
    case nonConforming
}

public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .simpleTransfer(
                from: FfiConverterTypeAddress.read(from: &buf),
                to: FfiConverterTypeAddress.read(from: &buf),
                transferred: FfiConverterTypeResourceSpecifier.read(from: &buf)
            )

        case 2: return try .transfer(
                from: FfiConverterTypeAddress.read(from: &buf),
                transfers: FfiConverterDictionaryStringDictionaryStringTypeResources.read(from: &buf)
            )

        case 3: return try .generalTransaction(
                accountProofs: FfiConverterSequenceTypeAddress.read(from: &buf),
                accountWithdraws: FfiConverterDictionaryStringSequenceTypeResourceSpecifier.read(from: &buf),
                accountDeposits: FfiConverterDictionaryStringSequenceTypeSource.read(from: &buf),
                addressesInManifest: FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.read(from: &buf),
                metadataOfNewlyCreatedEntities: FfiConverterDictionaryStringDictionaryStringTypeMetadataValue.read(from: &buf),
                dataOfNewlyMintedNonFungibles: FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8.read(from: &buf)
            )

        case 4: return .nonConforming

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        case let .simpleTransfer(from, to, transferred):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(from, into: &buf)
            FfiConverterTypeAddress.write(to, into: &buf)
            FfiConverterTypeResourceSpecifier.write(transferred, into: &buf)

        case let .transfer(from, transfers):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(from, into: &buf)
            FfiConverterDictionaryStringDictionaryStringTypeResources.write(transfers, into: &buf)

        case let .generalTransaction(accountProofs, accountWithdraws, accountDeposits, addressesInManifest, metadataOfNewlyCreatedEntities, dataOfNewlyMintedNonFungibles):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeAddress.write(accountProofs, into: &buf)
            FfiConverterDictionaryStringSequenceTypeResourceSpecifier.write(accountWithdraws, into: &buf)
            FfiConverterDictionaryStringSequenceTypeSource.write(accountDeposits, into: &buf)
            FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.write(addressesInManifest, into: &buf)
            FfiConverterDictionaryStringDictionaryStringTypeMetadataValue.write(metadataOfNewlyCreatedEntities, into: &buf)
            FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8.write(dataOfNewlyMintedNonFungibles, into: &buf)

        case .nonConforming:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}

private struct FfiConverterOptionTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = Decimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePreciseDecimal: FfiConverterRustBuffer {
    typealias SwiftType = PreciseDecimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePreciseDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePreciseDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSchema: FfiConverterRustBuffer {
    typealias SwiftType = Schema?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSchema.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSchema.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceInt64: FfiConverterRustBuffer {
    typealias SwiftType = [Int64]

    public static func write(_ value: [Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int64] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt64.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = [Decimal]

    public static func write(_ value: [Decimal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDecimal.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Decimal] {
        let len: Int32 = try readInt(&buf)
        var seq = [Decimal]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDecimal.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [MapEntry]

    public static func write(_ value: [MapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [MapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeMapEntry.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = [EntityType]

    public static func write(_ value: [EntityType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityType.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [Instruction]

    public static func write(_ value: [Instruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Instruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Instruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeInstruction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestValue]

    public static func write(_ value: [ManifestValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeManifestValue.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceSpecifier]

    public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceSpecifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceSpecifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceSpecifier.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [SignatureWithPublicKey]

    public static func write(_ value: [SignatureWithPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSignatureWithPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SignatureWithPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [SignatureWithPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSignatureWithPublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSource: FfiConverterRustBuffer {
    typealias SwiftType = [Source]

    public static func write(_ value: [Source], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Source] {
        let len: Int32 = try readInt(&buf)
        var seq = [Source]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]

    public static func write(_ value: [[UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt8]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetadataValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetadataValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetadataValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeResources: FfiConverterRustBuffer {
    public static func write(_ value: [String: Resources], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeResources.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Resources] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Resources]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeResources.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ResourceSpecifier]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeResourceSpecifier.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ResourceSpecifier]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ResourceSpecifier]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceSpecifier.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringSequenceTypeSource: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Source]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeSource.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Source]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Source]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeSource.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringDictionaryStringTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MetadataValue]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MetadataValue]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MetadataValue]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringDictionaryStringTypeResources: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: Resources]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeResources.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: Resources]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: Resources]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeResources.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [String: [NonFungibleLocalId: [UInt8]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [NonFungibleLocalId: [UInt8]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [NonFungibleLocalId: [UInt8]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve: FfiConverterRustBuffer {
    public static func write(_ value: [CurveType: DecryptorsByCurve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeCurveType.write(key, into: &buf)
            FfiConverterTypeDecryptorsByCurve.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CurveType: DecryptorsByCurve] {
        let len: Int32 = try readInt(&buf)
        var dict = [CurveType: DecryptorsByCurve]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeCurveType.read(from: &buf)
            let value = try FfiConverterTypeDecryptorsByCurve.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress: FfiConverterRustBuffer {
    public static func write(_ value: [EntityType: [Address]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeEntityType.write(key, into: &buf)
            FfiConverterSequenceTypeAddress.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType: [Address]] {
        let len: Int32 = try readInt(&buf)
        var dict = [EntityType: [Address]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeEntityType.read(from: &buf)
            let value = try FfiConverterSequenceTypeAddress.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleLocalId: [UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleLocalId.write(key, into: &buf)
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId: [UInt8]] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleLocalId: [UInt8]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            let value = try FfiConverterSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionarySequenceUInt8SequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [[UInt8]: [UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterSequenceUInt8.write(key, into: &buf)
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]: [UInt8]] {
        let len: Int32 = try readInt(&buf)
        var dict = [[UInt8]: [UInt8]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterSequenceUInt8.read(from: &buf)
            let value = try FfiConverterSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func buildInformation() -> BuildInformation {
    return try! FfiConverterTypeBuildInformation.lift(
        try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_func_build_information($0)
        }
    )
}

public func deriveOlympiaAccountAddressFromPublicKey(publicKey: PublicKey, olympiaNetwork: OlympiaNetwork) throws -> OlympiaAddress {
    return try FfiConverterTypeOlympiaAddress.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterTypeOlympiaNetwork.lower(olympiaNetwork), $0
            )
        }
    )
}

public func derivePublicKeyFromOlympiaAccountAddress(olympiaResourceAddress: OlympiaAddress) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address(
                FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress), $0
            )
        }
    )
}

public func deriveResourceAddressFromOlympiaResourceAddress(olympiaResourceAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
    return try FfiConverterTypeAddress.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address(
                FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func deriveVirtualAccountAddressFromOlympiaAccountAddress(olympiaAccountAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
    return try FfiConverterTypeAddress.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address(
                FfiConverterTypeOlympiaAddress.lower(olympiaAccountAddress),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func deriveVirtualAccountAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
    return try FfiConverterTypeAddress.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func deriveVirtualIdentityAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
    return try FfiConverterTypeAddress.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func deriveVirtualSignatureNonFungibleGlobalIdFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func hash(data: [UInt8]) -> Hash {
    return try! FfiConverterTypeHash.lift(
        try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_func_hash(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        }
    )
}

public func knownAddresses(networkId: UInt8) -> KnownAddresses {
    return try! FfiConverterTypeKnownAddresses.lift(
        try! rustCall {
            uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses(
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func manifestSborDecodeToStringRepresentation(bytes: [UInt8], representation: ManifestSborStringRepresentation, networkId: UInt8, schema: Schema?) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation(
                FfiConverterSequenceUInt8.lower(bytes),
                FfiConverterTypeManifestSborStringRepresentation.lower(representation),
                FfiConverterUInt8.lower(networkId),
                FfiConverterOptionTypeSchema.lower(schema), $0
            )
        }
    )
}

public func sborDecodeToMetadataValue(bytes: [UInt8], networkId: UInt8) throws -> MetadataValue {
    return try FfiConverterTypeMetadataValue.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_metadata_value(
                FfiConverterSequenceUInt8.lower(bytes),
                FfiConverterUInt8.lower(networkId), $0
            )
        }
    )
}

public func sborDecodeToStringRepresentation(bytes: [UInt8], representation: SerializationMode, networkId: UInt8, schema: Schema?) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation(
                FfiConverterSequenceUInt8.lower(bytes),
                FfiConverterTypeSerializationMode.lower(representation),
                FfiConverterUInt8.lower(networkId),
                FfiConverterOptionTypeSchema.lower(schema), $0
            )
        }
    )
}

public func scryptoSborDecodeToStringRepresentation(bytes: [UInt8], representation: SerializationMode, networkId: UInt8, schema: Schema?) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
            uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation(
                FfiConverterSequenceUInt8.lower(bytes),
                FfiConverterTypeSerializationMode.lower(representation),
                FfiConverterUInt8.lower(networkId),
                FfiConverterOptionTypeSchema.lower(schema), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information() != 17662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key() != 19647 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address() != 45205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address() != 11639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address() != 24509 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key() != 36758 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key() != 11003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key() != 61146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_hash() != 16303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses() != 16813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation() != 19578 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_metadata_value() != 36777 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation() != 11831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation() != 50232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string() != 5709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type() != 40172 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global() != 25808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component() != 58252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager() != 48841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager() != 55847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager() != 16959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package() != 10761 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager() != 34705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual() != 44552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal() != 34745 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault() != 26605 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store() != 4366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault() != 30524 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault() != 10507 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id() != 20026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 47552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 29792 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 31267 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling() != 53104 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 7427 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 17697 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than() != 16609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal() != 3170 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative() != 27762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive() != 15349 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero() != 27694 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than() != 30546 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal() != 2387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 52430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal() != 61801 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root() != 6178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 11213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 685 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 15109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str() != 2403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list() != 45845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id() != 55489 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile() != 31325 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash() != 993 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header() != 49719 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash() != 63530 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest() != 60823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message() != 49610 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate() != 18502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors() != 45350 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length() != 10753 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length() != 15824 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length() != 53437 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str() != 12617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id() != 42729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address() != 26038 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile() != 65183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash() != 64270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash() != 51688 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash() != 17757 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature() != 46873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent() != 11409 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash() != 60604 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate() != 11188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str() != 211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key() != 33649 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs() != 2924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add() != 36087 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str() != 50135 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt() != 60153 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling() != 35397 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div() != 55154 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal() != 35658 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor() != 37447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than() != 21292 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal() != 34931 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative() != 11588 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive() != 30868 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero() != 41566 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than() != 50862 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal() != 33893 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul() != 61496 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal() != 17368 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root() != 60037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi() != 1798 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round() != 38035 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt() != 18565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub() != 15847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile() != 26394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash() != 60260 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent() != 19540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash() != 9462 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures() != 46037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash() != 20757 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate() != 27682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str() != 9829 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes() != 40875 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id() != 4187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into() != 33560 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth() != 31236 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from() != 1186 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs() != 55127 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses() != 5474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth() != 1239 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions() != 3783 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate() != 42656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_cost_unit_limit() != 3389 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range() != 31430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size() != 39564 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage() != 28981 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation() != 52946 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_cost_unit_limit() != 51406 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage() != 2069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id() != 63098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw() != 43797 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new() != 37549 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address() != 64771 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address() != 31070 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key() != 738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key() != 32432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max() != 38313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min() != 18079 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new() != 15617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one() != 42470 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero() != 39451 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string() != 64410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes() != 17030 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions() != 51039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string() != 47420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile() != 565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new() != 4284 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default() != 54905 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new() != 60275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts() != 36478 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new() != 58056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge() != 22546 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile() != 58667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new() != 56154 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new() != 12724 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max() != 49495 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min() != 4453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new() != 34846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one() != 9121 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero() != 5648 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile() != 12765 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new() != 36392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new() != 62865 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default() != 1435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new() != 20792 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
