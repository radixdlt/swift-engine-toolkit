// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(RadixEngineToolkit)
import RadixEngineToolkit
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt16: FfiConverterPrimitive {
    typealias FfiType = Int16
    typealias SwiftType = Int16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int16, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


public protocol AccessRuleProtocol {
    func and(other: AccessRule)   -> AccessRule
    func or(other: AccessRule)   -> AccessRule
    
}

public class AccessRule: AccessRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule(pointer, $0) }
    }

    

    public static func allowAll()  -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all($0)
})
    }

    

    public static func denyAll()  -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all($0)
})
    }

    

    public static func require(resourceOrNonFungible: ResourceOrNonFungible) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require(
        FfiConverterTypeResourceOrNonFungible.lower(resourceOrNonFungible),$0)
})
    }

    

    public static func requireAllOf(resources: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of(
        FfiConverterSequenceTypeResourceOrNonFungible.lower(resources),$0)
})
    }

    

    public static func requireAmount(amount: Decimal, resource: Address) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount(
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeAddress.lower(resource),$0)
})
    }

    

    public static func requireAnyOf(resources: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of(
        FfiConverterSequenceTypeResourceOrNonFungible.lower(resources),$0)
})
    }

    

    public static func requireCountOf(count: UInt8, resources: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of(
        FfiConverterUInt8.lower(count),
        FfiConverterSequenceTypeResourceOrNonFungible.lower(resources),$0)
})
    }

    

    public static func requireSignature(publicKey: PublicKey) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_signature(
        FfiConverterTypePublicKey.lower(publicKey),$0)
})
    }

    

    
    

    public func and(other: AccessRule)  -> AccessRule {
        return try!  FfiConverterTypeAccessRule.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and(self.pointer, 
        FfiConverterTypeAccessRule.lower(other),$0
    )
}
        )
    }

    public func or(other: AccessRule)  -> AccessRule {
        return try!  FfiConverterTypeAccessRule.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or(self.pointer, 
        FfiConverterTypeAccessRule.lower(other),$0
    )
}
        )
    }
}

public struct FfiConverterTypeAccessRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AccessRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AccessRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AccessRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAccessRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> AccessRule {
    return try FfiConverterTypeAccessRule.lift(pointer)
}

public func FfiConverterTypeAccessRule_lower(_ value: AccessRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAccessRule.lower(value)
}


public protocol AddressProtocol {
    func addressString()   -> String
    func asStr()   -> String
    func bytes()   -> Data
    func entityType()   -> EntityType
    func isGlobal()   -> Bool
    func isGlobalComponent()   -> Bool
    func isGlobalConsensusManager()   -> Bool
    func isGlobalFungibleResourceManager()   -> Bool
    func isGlobalNonFungibleResourceManager()   -> Bool
    func isGlobalPackage()   -> Bool
    func isGlobalPreallocated()   -> Bool
    func isGlobalResourceManager()   -> Bool
    func isInternal()   -> Bool
    func isInternalFungibleVault()   -> Bool
    func isInternalKvStore()   -> Bool
    func isInternalNonFungibleVault()   -> Bool
    func isInternalVault()   -> Bool
    func networkId()   -> UInt8
    
}

public class Address: AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(address: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new(
        FfiConverterString.lower(address),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_address(pointer, $0) }
    }

    

    public static func fromRaw(nodeIdBytes: Data, networkId: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw(
        FfiConverterData.lower(nodeIdBytes),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func preallocatedAccountAddressFromOlympiaAddress(olympiaAccountAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_preallocated_account_address_from_olympia_address(
        FfiConverterTypeOlympiaAddress.lower(olympiaAccountAddress),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func preallocatedAccountAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_preallocated_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func preallocatedIdentityAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_preallocated_identity_address_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func resourceAddressFromOlympiaResourceAddress(olympiaResourceAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address(
        FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func addressString()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string(self.pointer, $0
    )
}
        )
    }

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str(self.pointer, $0
    )
}
        )
    }

    public func bytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes(self.pointer, $0
    )
}
        )
    }

    public func entityType()  -> EntityType {
        return try!  FfiConverterTypeEntityType.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type(self.pointer, $0
    )
}
        )
    }

    public func isGlobal()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global(self.pointer, $0
    )
}
        )
    }

    public func isGlobalComponent()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component(self.pointer, $0
    )
}
        )
    }

    public func isGlobalConsensusManager()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager(self.pointer, $0
    )
}
        )
    }

    public func isGlobalFungibleResourceManager()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func isGlobalNonFungibleResourceManager()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func isGlobalPackage()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package(self.pointer, $0
    )
}
        )
    }

    public func isGlobalPreallocated()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_preallocated(self.pointer, $0
    )
}
        )
    }

    public func isGlobalResourceManager()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func isInternal()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal(self.pointer, $0
    )
}
        )
    }

    public func isInternalFungibleVault()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault(self.pointer, $0
    )
}
        )
    }

    public func isInternalKvStore()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store(self.pointer, $0
    )
}
        )
    }

    public func isInternalNonFungibleVault()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault(self.pointer, $0
    )
}
        )
    }

    public func isInternalVault()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault(self.pointer, $0
    )
}
        )
    }

    public func networkId()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}


public protocol DecimalProtocol {
    func abs()  throws -> Decimal
    func add(other: Decimal)  throws -> Decimal
    func asStr()   -> String
    func cbrt()  throws -> Decimal
    func ceiling()  throws -> Decimal
    func div(other: Decimal)  throws -> Decimal
    func equal(other: Decimal)   -> Bool
    func floor()  throws -> Decimal
    func greaterThan(other: Decimal)   -> Bool
    func greaterThanOrEqual(other: Decimal)   -> Bool
    func isNegative()   -> Bool
    func isPositive()   -> Bool
    func isZero()   -> Bool
    func lessThan(other: Decimal)   -> Bool
    func lessThanOrEqual(other: Decimal)   -> Bool
    func mantissa()   -> String
    func mul(other: Decimal)  throws -> Decimal
    func notEqual(other: Decimal)   -> Bool
    func nthRoot(n: UInt32)   -> Decimal?
    func powi(exp: Int64)  throws -> Decimal
    func round(decimalPlaces: Int32, roundingMode: RoundingMode)  throws -> Decimal
    func sqrt()   -> Decimal?
    func sub(other: Decimal)  throws -> Decimal
    func toLeBytes()   -> Data
    
}

public class Decimal: DecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(value: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new(
        FfiConverterString.lower(value),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_decimal(pointer, $0) }
    }

    

    public static func fromLeBytes(value: Data)  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_from_le_bytes(
        FfiConverterData.lower(value),$0)
})
    }

    

    public static func max()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max($0)
})
    }

    

    public static func min()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min($0)
})
    }

    

    public static func one()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one($0)
})
    }

    

    public static func zero()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero($0)
})
    }

    

    
    

    public func abs() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs(self.pointer, $0
    )
}
        )
    }

    public func add(other: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str(self.pointer, $0
    )
}
        )
    }

    public func cbrt() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt(self.pointer, $0
    )
}
        )
    }

    public func ceiling() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling(self.pointer, $0
    )
}
        )
    }

    public func div(other: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func equal(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func floor() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor(self.pointer, $0
    )
}
        )
    }

    public func greaterThan(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func greaterThanOrEqual(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func isNegative()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative(self.pointer, $0
    )
}
        )
    }

    public func isPositive()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive(self.pointer, $0
    )
}
        )
    }

    public func isZero()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero(self.pointer, $0
    )
}
        )
    }

    public func lessThan(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func lessThanOrEqual(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func mantissa()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa(self.pointer, $0
    )
}
        )
    }

    public func mul(other: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func notEqual(other: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func nthRoot(n: UInt32)  -> Decimal? {
        return try!  FfiConverterOptionTypeDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root(self.pointer, 
        FfiConverterUInt32.lower(n),$0
    )
}
        )
    }

    public func powi(exp: Int64) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi(self.pointer, 
        FfiConverterInt64.lower(exp),$0
    )
}
        )
    }

    public func round(decimalPlaces: Int32, roundingMode: RoundingMode) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round(self.pointer, 
        FfiConverterInt32.lower(decimalPlaces),
        FfiConverterTypeRoundingMode.lower(roundingMode),$0
    )
}
        )
    }

    public func sqrt()  -> Decimal? {
        return try!  FfiConverterOptionTypeDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt(self.pointer, $0
    )
}
        )
    }

    public func sub(other: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub(self.pointer, 
        FfiConverterTypeDecimal.lower(other),$0
    )
}
        )
    }

    public func toLeBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_to_le_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Decimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Decimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
        return Decimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Decimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
    return try FfiConverterTypeDecimal.lift(pointer)
}

public func FfiConverterTypeDecimal_lower(_ value: Decimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDecimal.lower(value)
}


public protocol HashProtocol {
    func asStr()   -> String
    func bytes()   -> Data
    
}

public class Hash: HashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(hash: Data) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new(
        FfiConverterData.lower(hash),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_hash(pointer, $0) }
    }

    

    public static func fromHexString(hash: String) throws -> Hash {
        return Hash(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string(
        FfiConverterString.lower(hash),$0)
})
    }

    

    public static func fromUnhashedBytes(bytes: Data)  -> Hash {
        return Hash(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes(
        FfiConverterData.lower(bytes),$0)
})
    }

    

    public static func sborDecode(bytes: Data) throws -> Hash {
        return Hash(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_sbor_decode(
        FfiConverterData.lower(bytes),$0)
})
    }

    

    
    

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str(self.pointer, $0
    )
}
        )
    }

    public func bytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Hash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
        return Hash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Hash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
    return try FfiConverterTypeHash.lift(pointer)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHash.lower(value)
}


public protocol InstructionsV1Protocol {
    func asStr()  throws -> String
    func instructionsList()   -> [InstructionV1]
    func networkId()   -> UInt8
    
}

public class InstructionsV1: InstructionsV1Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_instructionsv1(pointer, $0) }
    }

    

    public static func fromInstructions(instructions: [InstructionV1], networkId: UInt8) throws -> InstructionsV1 {
        return InstructionsV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructionsv1_from_instructions(
        FfiConverterSequenceTypeInstructionV1.lower(instructions),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func fromString(string: String, networkId: UInt8) throws -> InstructionsV1 {
        return InstructionsV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructionsv1_from_string(
        FfiConverterString.lower(string),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func asStr() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv1_as_str(self.pointer, $0
    )
}
        )
    }

    public func instructionsList()  -> [InstructionV1] {
        return try!  FfiConverterSequenceTypeInstructionV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv1_instructions_list(self.pointer, $0
    )
}
        )
    }

    public func networkId()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv1_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeInstructionsV1: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InstructionsV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionsV1 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InstructionsV1, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InstructionsV1 {
        return InstructionsV1(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InstructionsV1) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeInstructionsV1_lift(_ pointer: UnsafeMutableRawPointer) throws -> InstructionsV1 {
    return try FfiConverterTypeInstructionsV1.lift(pointer)
}

public func FfiConverterTypeInstructionsV1_lower(_ value: InstructionsV1) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInstructionsV1.lower(value)
}


public protocol InstructionsV2Protocol {
    func asStr()  throws -> String
    func instructionsList()   -> [InstructionV2]
    func networkId()   -> UInt8
    
}

public class InstructionsV2: InstructionsV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_instructionsv2(pointer, $0) }
    }

    

    public static func fromInstructions(instructions: [InstructionV2], networkId: UInt8) throws -> InstructionsV2 {
        return InstructionsV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructionsv2_from_instructions(
        FfiConverterSequenceTypeInstructionV2.lower(instructions),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func fromString(string: String, networkId: UInt8) throws -> InstructionsV2 {
        return InstructionsV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructionsv2_from_string(
        FfiConverterString.lower(string),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func asStr() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv2_as_str(self.pointer, $0
    )
}
        )
    }

    public func instructionsList()  -> [InstructionV2] {
        return try!  FfiConverterSequenceTypeInstructionV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv2_instructions_list(self.pointer, $0
    )
}
        )
    }

    public func networkId()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructionsv2_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeInstructionsV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InstructionsV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionsV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InstructionsV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InstructionsV2 {
        return InstructionsV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InstructionsV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeInstructionsV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> InstructionsV2 {
    return try FfiConverterTypeInstructionsV2.lift(pointer)
}

public func FfiConverterTypeInstructionsV2_lower(_ value: InstructionsV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInstructionsV2.lower(value)
}


public protocol IntentCoreV2Protocol {
    func blobs()   -> [Data]
    func children()   -> [Hash]
    func header()   -> IntentHeaderV2
    func instructions()   -> InstructionsV2
    func intoSubintent()   -> SubintentV2
    func message()   -> MessageV2
    
}

public class IntentCoreV2: IntentCoreV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(header: IntentHeaderV2, blobs: [Data], message: MessageV2, children: [Hash], instructions: InstructionsV2)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_intentcorev2_new(
        FfiConverterTypeIntentHeaderV2.lower(header),
        FfiConverterSequenceData.lower(blobs),
        FfiConverterTypeMessageV2.lower(message),
        FfiConverterSequenceTypeHash.lower(children),
        FfiConverterTypeInstructionsV2.lower(instructions),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_intentcorev2(pointer, $0) }
    }

    

    
    

    public func blobs()  -> [Data] {
        return try!  FfiConverterSequenceData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_blobs(self.pointer, $0
    )
}
        )
    }

    public func children()  -> [Hash] {
        return try!  FfiConverterSequenceTypeHash.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_children(self.pointer, $0
    )
}
        )
    }

    public func header()  -> IntentHeaderV2 {
        return try!  FfiConverterTypeIntentHeaderV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_header(self.pointer, $0
    )
}
        )
    }

    public func instructions()  -> InstructionsV2 {
        return try!  FfiConverterTypeInstructionsV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_instructions(self.pointer, $0
    )
}
        )
    }

    public func intoSubintent()  -> SubintentV2 {
        return try!  FfiConverterTypeSubintentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_into_subintent(self.pointer, $0
    )
}
        )
    }

    public func message()  -> MessageV2 {
        return try!  FfiConverterTypeMessageV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentcorev2_message(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeIntentCoreV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IntentCoreV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentCoreV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IntentCoreV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IntentCoreV2 {
        return IntentCoreV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IntentCoreV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeIntentCoreV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> IntentCoreV2 {
    return try FfiConverterTypeIntentCoreV2.lift(pointer)
}

public func FfiConverterTypeIntentCoreV2_lower(_ value: IntentCoreV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIntentCoreV2.lower(value)
}


public protocol IntentV1Protocol {
    func hash()  throws -> TransactionHash
    func header()   -> TransactionHeaderV1
    func intentHash()  throws -> TransactionHash
    func manifest()   -> TransactionManifestV1
    func message()   -> MessageV1
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class IntentV1: IntentV1Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(header: TransactionHeaderV1, manifest: TransactionManifestV1, message: MessageV1)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_intentv1_new(
        FfiConverterTypeTransactionHeaderV1.lower(header),
        FfiConverterTypeTransactionManifestV1.lower(manifest),
        FfiConverterTypeMessageV1.lower(message),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_intentv1(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledIntent: Data) throws -> IntentV1 {
        return IntentV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_intentv1_from_payload_bytes(
        FfiConverterData.lower(compiledIntent),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_hash(self.pointer, $0
    )
}
        )
    }

    public func header()  -> TransactionHeaderV1 {
        return try!  FfiConverterTypeTransactionHeaderV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_header(self.pointer, $0
    )
}
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func manifest()  -> TransactionManifestV1 {
        return try!  FfiConverterTypeTransactionManifestV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_manifest(self.pointer, $0
    )
}
        )
    }

    public func message()  -> MessageV1 {
        return try!  FfiConverterTypeMessageV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_message(self.pointer, $0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intentv1_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeIntentV1: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IntentV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentV1 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IntentV1, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IntentV1 {
        return IntentV1(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IntentV1) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeIntentV1_lift(_ pointer: UnsafeMutableRawPointer) throws -> IntentV1 {
    return try FfiConverterTypeIntentV1.lift(pointer)
}

public func FfiConverterTypeIntentV1_lower(_ value: IntentV1) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIntentV1.lower(value)
}


public protocol ManifestV1BuilderProtocol {
    func accessControllerCancelPrimaryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV1Builder
    func accessControllerCancelPrimaryRoleRecoveryProposal(address: Address)  throws -> ManifestV1Builder
    func accessControllerCancelRecoveryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV1Builder
    func accessControllerCancelRecoveryRoleRecoveryProposal(address: Address)  throws -> ManifestV1Builder
    func accessControllerCreate(controlledAsset: ManifestBuilderBucket, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func accessControllerCreateProof(address: Address)  throws -> ManifestV1Builder
    func accessControllerCreateWithSecurityStructure(controlledAsset: ManifestBuilderBucket, primaryRole: SecurityStructureRole, recoveryRole: SecurityStructureRole, confirmationRole: SecurityStructureRole, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func accessControllerInitiateBadgeWithdrawAsPrimary(address: Address)  throws -> ManifestV1Builder
    func accessControllerInitiateBadgeWithdrawAsRecovery(address: Address)  throws -> ManifestV1Builder
    func accessControllerInitiateRecoveryAsPrimary(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerInitiateRecoveryAsRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerLockPrimaryRole(address: Address)  throws -> ManifestV1Builder
    func accessControllerMintRecoveryBadges(address: Address, nonFungibleLocalIds: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accessControllerNewFromPublicKeys(controlledAsset: ManifestBuilderBucket, primaryRole: PublicKey, recoveryRole: PublicKey, confirmationRole: PublicKey, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func accessControllerQuickConfirmPrimaryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV1Builder
    func accessControllerQuickConfirmPrimaryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerQuickConfirmRecoveryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV1Builder
    func accessControllerQuickConfirmRecoveryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerStopTimedRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerTimedConfirmRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV1Builder
    func accessControllerUnlockPrimaryRole(address: Address)  throws -> ManifestV1Builder
    func accountAddAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible)  throws -> ManifestV1Builder
    func accountBurn(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountBurnNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accountCreate()  throws -> ManifestV1Builder
    func accountCreateAdvanced(ownerRole: OwnerRole, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func accountCreateProofOfAmount(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountCreateProofOfNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accountDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func accountDepositBatch(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV1Builder
    func accountDepositEntireWorktop(accountAddress: Address)  throws -> ManifestV1Builder
    func accountLockContingentFee(address: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountLockFee(address: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountLockFeeAndWithdraw(address: Address, amountToLock: Decimal, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountLockFeeAndWithdrawNonFungibles(address: Address, amountToLock: Decimal, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accountLockerAirdrop(address: Address, claimants: [String: ResourceSpecifier], bucket: ManifestBuilderBucket, tryDirectSend: Bool)  throws -> ManifestV1Builder
    func accountLockerClaim(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountLockerClaimNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accountLockerGetAmount(address: Address, claimant: Address, resourceAddress: Address)  throws -> ManifestV1Builder
    func accountLockerGetNonFungibleLocalIds(address: Address, claimant: Address, resourceAddress: Address, limit: UInt32)  throws -> ManifestV1Builder
    func accountLockerInstantiate(ownerRole: OwnerRole, storerRole: AccessRule, storerUpdaterRole: AccessRule, recovererRole: AccessRule, recovererUpdaterRole: AccessRule, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func accountLockerInstantiateSimple(allowRecover: Bool)  throws -> ManifestV1Builder
    func accountLockerRecover(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountLockerRecoverNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func accountLockerStore(address: Address, claimant: Address, bucket: ManifestBuilderBucket, tryDirectSend: Bool)  throws -> ManifestV1Builder
    func accountRemoveAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible)  throws -> ManifestV1Builder
    func accountRemoveResourcePreference(address: Address, resourceAddress: Address)  throws -> ManifestV1Builder
    func accountSecurify(address: Address)  throws -> ManifestV1Builder
    func accountSetDefaultDepositRule(address: Address, defaultDepositRule: AccountDefaultDepositRule)  throws -> ManifestV1Builder
    func accountSetResourcePreference(address: Address, resourceAddress: Address, resourcePreference: ResourcePreference)  throws -> ManifestV1Builder
    func accountTryDepositBatchOrAbort(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountTryDepositBatchOrRefund(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountTryDepositEntireWorktopOrAbort(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountTryDepositEntireWorktopOrRefund(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountTryDepositOrAbort(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountTryDepositOrRefund(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV1Builder
    func accountWithdraw(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func accountWithdrawNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func allocateGlobalAddress(packageAddress: Address, blueprintName: String, intoAddressReservation: ManifestBuilderAddressReservation, intoNamedAddress: ManifestBuilderNamedAddress)  throws -> ManifestV1Builder
    func assertWorktopContains(resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func assertWorktopContainsAny(resourceAddress: Address)  throws -> ManifestV1Builder
    func assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV1Builder
    func build(networkId: UInt8)   -> TransactionManifestV1
    func burnResource(bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func callAccessRulesMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func callDirectVaultMethod(address: Address, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func callFunction(address: ManifestBuilderAddress, blueprintName: String, functionName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func callMetadataMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func callMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func callRoyaltyMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV1Builder
    func cloneProof(proof: ManifestBuilderProof, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createFungibleResourceManager(ownerRole: OwnerRole, trackTotalSupply: Bool, divisibility: UInt8, initialSupply: Decimal?, resourceRoles: FungibleResourceRoles, metadata: MetadataModuleConfig, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func createProofFromAuthZoneOfAll(resourceAddress: Address, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId], intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createProofFromBucketOfAll(bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createProofFromBucketOfAmount(amount: Decimal, bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func createProofFromBucketOfNonFungibles(ids: [NonFungibleLocalId], bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func dropAllProofs()  throws -> ManifestV1Builder
    func dropAuthZoneProofs()  throws -> ManifestV1Builder
    func dropAuthZoneSignatureProofs()  throws -> ManifestV1Builder
    func dropProof(proof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func faucetFreeXrd()  throws -> ManifestV1Builder
    func faucetLockFee()  throws -> ManifestV1Builder
    func identityCreate()  throws -> ManifestV1Builder
    func identityCreateAdvanced(ownerRole: OwnerRole)  throws -> ManifestV1Builder
    func identitySecurify(address: Address)  throws -> ManifestV1Builder
    func metadataGet(address: Address, key: String)  throws -> ManifestV1Builder
    func metadataLock(address: Address, key: String)  throws -> ManifestV1Builder
    func metadataRemove(address: Address, key: String)  throws -> ManifestV1Builder
    func metadataSet(address: Address, key: String, value: MetadataValue)  throws -> ManifestV1Builder
    func mintFungible(resourceAddress: Address, amount: Decimal)  throws -> ManifestV1Builder
    func multiResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV1Builder
    func multiResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV1Builder
    func multiResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV1Builder
    func multiResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func multiResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func multiResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV1Builder
    func multiResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func oneResourcePoolContribute(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func oneResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV1Builder
    func oneResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV1Builder
    func oneResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddress: Address, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func oneResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func oneResourcePoolProtectedWithdraw(address: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV1Builder
    func oneResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func packageClaimRoyalty(address: Address)  throws -> ManifestV1Builder
    func packagePublish(code: Data, definition: Data, metadata: [String: MetadataInitEntry])  throws -> ManifestV1Builder
    func packagePublishAdvanced(ownerRole: OwnerRole, code: Data, definition: Data, metadata: [String: MetadataInitEntry], packageAddress: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func popFromAuthZone(intoProof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func pushToAuthZone(proof: ManifestBuilderProof)  throws -> ManifestV1Builder
    func returnToWorktop(bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func roleAssignmentGet(address: Address, module: ModuleId, roleKey: String)  throws -> ManifestV1Builder
    func roleAssignmentLockOwner(address: Address)  throws -> ManifestV1Builder
    func roleAssignmentSet(address: Address, module: ModuleId, roleKey: String, rule: AccessRule)  throws -> ManifestV1Builder
    func roleAssignmentSetOwner(address: Address, rule: AccessRule)  throws -> ManifestV1Builder
    func royaltyClaim(address: Address)  throws -> ManifestV1Builder
    func royaltyLock(address: Address, method: String)  throws -> ManifestV1Builder
    func royaltySet(address: Address, method: String, amount: RoyaltyAmount)  throws -> ManifestV1Builder
    func takeAllFromWorktop(resourceAddress: Address, intoBucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func takeFromWorktop(resourceAddress: Address, amount: Decimal, intoBucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId], intoBucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func twoResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV1Builder
    func twoResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV1Builder
    func twoResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV1Builder
    func twoResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV1Builder
    func twoResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func twoResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV1Builder
    func twoResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorAcceptsDelegatedStake(address: Address)  throws -> ManifestV1Builder
    func validatorClaimXrd(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorFinishUnlockOwnerStakeUnits(address: Address)  throws -> ManifestV1Builder
    func validatorGetProtocolUpdateReadiness(address: Address)  throws -> ManifestV1Builder
    func validatorGetRedemptionValue(address: Address, amountOfStakeUnits: Decimal)  throws -> ManifestV1Builder
    func validatorLockOwnerStakeUnits(address: Address, stakeUnitBucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorRegister(address: Address)  throws -> ManifestV1Builder
    func validatorSignalProtocolUpdateReadiness(address: Address, vote: String)  throws -> ManifestV1Builder
    func validatorStake(address: Address, stake: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorStakeAsOwner(address: Address, stake: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorStartUnlockOwnerStakeUnits(address: Address, requestedStakeUnitAmount: Decimal)  throws -> ManifestV1Builder
    func validatorTotalStakeUnitSupply(address: Address)  throws -> ManifestV1Builder
    func validatorTotalStakeXrdAmount(address: Address)  throws -> ManifestV1Builder
    func validatorUnregister(address: Address)  throws -> ManifestV1Builder
    func validatorUnstake(address: Address, stakeUnitBucket: ManifestBuilderBucket)  throws -> ManifestV1Builder
    func validatorUpdateAcceptDelegatedStake(address: Address, acceptDelegatedStake: Bool)  throws -> ManifestV1Builder
    func validatorUpdateFee(address: Address, newFeeFactor: Decimal)  throws -> ManifestV1Builder
    func validatorUpdateKey(address: Address, key: PublicKey)  throws -> ManifestV1Builder
    
}

public class ManifestV1Builder: ManifestV1BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestv1builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_manifestv1builder(pointer, $0) }
    }

    

    
    

    public func accessControllerCancelPrimaryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_cancel_primary_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelPrimaryRoleRecoveryProposal(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_cancel_primary_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelRecoveryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_cancel_recovery_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelRecoveryRoleRecoveryProposal(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_cancel_recovery_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCreate(controlledAsset: ManifestBuilderBucket, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_create(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerCreateProof(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_create_proof(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCreateWithSecurityStructure(controlledAsset: ManifestBuilderBucket, primaryRole: SecurityStructureRole, recoveryRole: SecurityStructureRole, confirmationRole: SecurityStructureRole, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_create_with_security_structure(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypeSecurityStructureRole.lower(primaryRole),
        FfiConverterTypeSecurityStructureRole.lower(recoveryRole),
        FfiConverterTypeSecurityStructureRole.lower(confirmationRole),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerInitiateBadgeWithdrawAsPrimary(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_initiate_badge_withdraw_as_primary(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerInitiateBadgeWithdrawAsRecovery(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_initiate_badge_withdraw_as_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerInitiateRecoveryAsPrimary(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_initiate_recovery_as_primary(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerInitiateRecoveryAsRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_initiate_recovery_as_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerLockPrimaryRole(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_lock_primary_role(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerMintRecoveryBadges(address: Address, nonFungibleLocalIds: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_mint_recovery_badges(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(nonFungibleLocalIds),$0
    )
}
        )
    }

    public func accessControllerNewFromPublicKeys(controlledAsset: ManifestBuilderBucket, primaryRole: PublicKey, recoveryRole: PublicKey, confirmationRole: PublicKey, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_new_from_public_keys(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypePublicKey.lower(primaryRole),
        FfiConverterTypePublicKey.lower(recoveryRole),
        FfiConverterTypePublicKey.lower(confirmationRole),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmPrimaryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmPrimaryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_quick_confirm_primary_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmRecoveryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmRecoveryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_quick_confirm_recovery_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerStopTimedRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_stop_timed_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerTimedConfirmRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_timed_confirm_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerUnlockPrimaryRole(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_access_controller_unlock_primary_role(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accountAddAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_add_authorized_depositor(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeResourceOrNonFungible.lower(badge),$0
    )
}
        )
    }

    public func accountBurn(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_burn(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountBurnNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_burn_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountCreate() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_create(self.pointer, $0
    )
}
        )
    }

    public func accountCreateAdvanced(ownerRole: OwnerRole, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_create_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accountCreateProofOfAmount(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_create_proof_of_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountCreateProofOfNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_create_proof_of_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func accountDepositBatch(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_deposit_batch(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func accountDepositEntireWorktop(accountAddress: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_deposit_entire_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),$0
    )
}
        )
    }

    public func accountLockContingentFee(address: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_lock_contingent_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFee(address: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_lock_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFeeAndWithdraw(address: Address, amountToLock: Decimal, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_lock_fee_and_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountToLock),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFeeAndWithdrawNonFungibles(address: Address, amountToLock: Decimal, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_lock_fee_and_withdraw_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountToLock),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerAirdrop(address: Address, claimants: [String: ResourceSpecifier], bucket: ManifestBuilderBucket, tryDirectSend: Bool) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_airdrop(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterDictionaryStringTypeResourceSpecifier.lower(claimants),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterBool.lower(tryDirectSend),$0
    )
}
        )
    }

    public func accountLockerClaim(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_claim(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockerClaimNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_claim_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerGetAmount(address: Address, claimant: Address, resourceAddress: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_get_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func accountLockerGetNonFungibleLocalIds(address: Address, claimant: Address, resourceAddress: Address, limit: UInt32) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_get_non_fungible_local_ids(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterUInt32.lower(limit),$0
    )
}
        )
    }

    public func accountLockerInstantiate(ownerRole: OwnerRole, storerRole: AccessRule, storerUpdaterRole: AccessRule, recovererRole: AccessRule, recovererUpdaterRole: AccessRule, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(storerRole),
        FfiConverterTypeAccessRule.lower(storerUpdaterRole),
        FfiConverterTypeAccessRule.lower(recovererRole),
        FfiConverterTypeAccessRule.lower(recovererUpdaterRole),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accountLockerInstantiateSimple(allowRecover: Bool) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_instantiate_simple(self.pointer, 
        FfiConverterBool.lower(allowRecover),$0
    )
}
        )
    }

    public func accountLockerRecover(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_recover(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockerRecoverNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_recover_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerStore(address: Address, claimant: Address, bucket: ManifestBuilderBucket, tryDirectSend: Bool) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_locker_store(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterBool.lower(tryDirectSend),$0
    )
}
        )
    }

    public func accountRemoveAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_remove_authorized_depositor(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeResourceOrNonFungible.lower(badge),$0
    )
}
        )
    }

    public func accountRemoveResourcePreference(address: Address, resourceAddress: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_remove_resource_preference(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func accountSecurify(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_securify(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accountSetDefaultDepositRule(address: Address, defaultDepositRule: AccountDefaultDepositRule) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_set_default_deposit_rule(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAccountDefaultDepositRule.lower(defaultDepositRule),$0
    )
}
        )
    }

    public func accountSetResourcePreference(address: Address, resourceAddress: Address, resourcePreference: ResourcePreference) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_set_resource_preference(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeResourcePreference.lower(resourcePreference),$0
    )
}
        )
    }

    public func accountTryDepositBatchOrAbort(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_batch_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositBatchOrRefund(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_batch_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositEntireWorktopOrAbort(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_entire_worktop_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositEntireWorktopOrRefund(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_entire_worktop_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositOrAbort(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositOrRefund(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_try_deposit_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountWithdraw(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountWithdrawNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_account_withdraw_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func allocateGlobalAddress(packageAddress: Address, blueprintName: String, intoAddressReservation: ManifestBuilderAddressReservation, intoNamedAddress: ManifestBuilderNamedAddress) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_allocate_global_address(self.pointer, 
        FfiConverterTypeAddress.lower(packageAddress),
        FfiConverterString.lower(blueprintName),
        FfiConverterTypeManifestBuilderAddressReservation.lower(intoAddressReservation),
        FfiConverterTypeManifestBuilderNamedAddress.lower(intoNamedAddress),$0
    )
}
        )
    }

    public func assertWorktopContains(resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_assert_worktop_contains(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func assertWorktopContainsAny(resourceAddress: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_assert_worktop_contains_any(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_assert_worktop_contains_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func build(networkId: UInt8)  -> TransactionManifestV1 {
        return try!  FfiConverterTypeTransactionManifestV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_build(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func burnResource(bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_burn_resource(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func callAccessRulesMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_access_rules_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callDirectVaultMethod(address: Address, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_direct_vault_method(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callFunction(address: ManifestBuilderAddress, blueprintName: String, functionName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_function(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(blueprintName),
        FfiConverterString.lower(functionName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callMetadataMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_metadata_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callRoyaltyMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_call_royalty_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func cloneProof(proof: ManifestBuilderProof, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_clone_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createFungibleResourceManager(ownerRole: OwnerRole, trackTotalSupply: Bool, divisibility: UInt8, initialSupply: Decimal?, resourceRoles: FungibleResourceRoles, metadata: MetadataModuleConfig, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_fungible_resource_manager(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterBool.lower(trackTotalSupply),
        FfiConverterUInt8.lower(divisibility),
        FfiConverterOptionTypeDecimal.lower(initialSupply),
        FfiConverterTypeFungibleResourceRoles.lower(resourceRoles),
        FfiConverterTypeMetadataModuleConfig.lower(metadata),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfAll(resourceAddress: Address, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_auth_zone_of_all(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_auth_zone_of_amount(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId], intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_auth_zone_of_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfAll(bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_bucket_of_all(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfAmount(amount: Decimal, bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_bucket_of_amount(self.pointer, 
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfNonFungibles(ids: [NonFungibleLocalId], bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_create_proof_from_bucket_of_non_fungibles(self.pointer, 
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func dropAllProofs() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_drop_all_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropAuthZoneProofs() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_drop_auth_zone_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropAuthZoneSignatureProofs() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_drop_auth_zone_signature_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropProof(proof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_drop_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),$0
    )
}
        )
    }

    public func faucetFreeXrd() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_faucet_free_xrd(self.pointer, $0
    )
}
        )
    }

    public func faucetLockFee() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_faucet_lock_fee(self.pointer, $0
    )
}
        )
    }

    public func identityCreate() throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_identity_create(self.pointer, $0
    )
}
        )
    }

    public func identityCreateAdvanced(ownerRole: OwnerRole) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_identity_create_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),$0
    )
}
        )
    }

    public func identitySecurify(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_identity_securify(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func metadataGet(address: Address, key: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_metadata_get(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataLock(address: Address, key: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_metadata_lock(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataRemove(address: Address, key: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_metadata_remove(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataSet(address: Address, key: String, value: MetadataValue) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_metadata_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),
        FfiConverterTypeMetadataValue.lower(value),$0
    )
}
        )
    }

    public func mintFungible(resourceAddress: Address, amount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_mint_fungible(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func multiResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func multiResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func multiResourcePoolGetVaultAmount(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func multiResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterSequenceTypeAddress.lower(resourceAddresses),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func multiResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func multiResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func multiResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_multi_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolContribute(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func oneResourcePoolGetVaultAmount(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func oneResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddress: Address, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func oneResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolProtectedWithdraw(address: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func oneResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_one_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func packageClaimRoyalty(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_package_claim_royalty(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func packagePublish(code: Data, definition: Data, metadata: [String: MetadataInitEntry]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_package_publish(self.pointer, 
        FfiConverterData.lower(code),
        FfiConverterData.lower(definition),
        FfiConverterDictionaryStringTypeMetadataInitEntry.lower(metadata),$0
    )
}
        )
    }

    public func packagePublishAdvanced(ownerRole: OwnerRole, code: Data, definition: Data, metadata: [String: MetadataInitEntry], packageAddress: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_package_publish_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterData.lower(code),
        FfiConverterData.lower(definition),
        FfiConverterDictionaryStringTypeMetadataInitEntry.lower(metadata),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(packageAddress),$0
    )
}
        )
    }

    public func popFromAuthZone(intoProof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_pop_from_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func pushToAuthZone(proof: ManifestBuilderProof) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_push_to_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),$0
    )
}
        )
    }

    public func returnToWorktop(bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_return_to_worktop(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func roleAssignmentGet(address: Address, module: ModuleId, roleKey: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_role_assignment_get(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeModuleId.lower(module),
        FfiConverterString.lower(roleKey),$0
    )
}
        )
    }

    public func roleAssignmentLockOwner(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_role_assignment_lock_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func roleAssignmentSet(address: Address, module: ModuleId, roleKey: String, rule: AccessRule) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_role_assignment_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeModuleId.lower(module),
        FfiConverterString.lower(roleKey),
        FfiConverterTypeAccessRule.lower(rule),$0
    )
}
        )
    }

    public func roleAssignmentSetOwner(address: Address, rule: AccessRule) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_role_assignment_set_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAccessRule.lower(rule),$0
    )
}
        )
    }

    public func royaltyClaim(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_royalty_claim(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func royaltyLock(address: Address, method: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_royalty_lock(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(method),$0
    )
}
        )
    }

    public func royaltySet(address: Address, method: String, amount: RoyaltyAmount) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_royalty_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(method),
        FfiConverterTypeRoyaltyAmount.lower(amount),$0
    )
}
        )
    }

    public func takeAllFromWorktop(resourceAddress: Address, intoBucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_take_all_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func takeFromWorktop(resourceAddress: Address, amount: Decimal, intoBucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_take_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId], intoBucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_take_non_fungibles_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func twoResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func twoResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func twoResourcePoolGetVaultAmount(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func twoResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterSequenceTypeAddress.lower(resourceAddresses),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func twoResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func twoResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func twoResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_two_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func validatorAcceptsDelegatedStake(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_accepts_delegated_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorClaimXrd(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_claim_xrd(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func validatorFinishUnlockOwnerStakeUnits(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_finish_unlock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorGetProtocolUpdateReadiness(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_get_protocol_update_readiness(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorGetRedemptionValue(address: Address, amountOfStakeUnits: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfStakeUnits),$0
    )
}
        )
    }

    public func validatorLockOwnerStakeUnits(address: Address, stakeUnitBucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_lock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stakeUnitBucket),$0
    )
}
        )
    }

    public func validatorRegister(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_register(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorSignalProtocolUpdateReadiness(address: Address, vote: String) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_signal_protocol_update_readiness(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(vote),$0
    )
}
        )
    }

    public func validatorStake(address: Address, stake: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stake),$0
    )
}
        )
    }

    public func validatorStakeAsOwner(address: Address, stake: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_stake_as_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stake),$0
    )
}
        )
    }

    public func validatorStartUnlockOwnerStakeUnits(address: Address, requestedStakeUnitAmount: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_start_unlock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(requestedStakeUnitAmount),$0
    )
}
        )
    }

    public func validatorTotalStakeUnitSupply(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_total_stake_unit_supply(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorTotalStakeXrdAmount(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_total_stake_xrd_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorUnregister(address: Address) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_unregister(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorUnstake(address: Address, stakeUnitBucket: ManifestBuilderBucket) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_unstake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stakeUnitBucket),$0
    )
}
        )
    }

    public func validatorUpdateAcceptDelegatedStake(address: Address, acceptDelegatedStake: Bool) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_update_accept_delegated_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterBool.lower(acceptDelegatedStake),$0
    )
}
        )
    }

    public func validatorUpdateFee(address: Address, newFeeFactor: Decimal) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_update_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(newFeeFactor),$0
    )
}
        )
    }

    public func validatorUpdateKey(address: Address, key: PublicKey) throws -> ManifestV1Builder {
        return try  FfiConverterTypeManifestV1Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv1builder_validator_update_key(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypePublicKey.lower(key),$0
    )
}
        )
    }
}

public struct FfiConverterTypeManifestV1Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ManifestV1Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestV1Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ManifestV1Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestV1Builder {
        return ManifestV1Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ManifestV1Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeManifestV1Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestV1Builder {
    return try FfiConverterTypeManifestV1Builder.lift(pointer)
}

public func FfiConverterTypeManifestV1Builder_lower(_ value: ManifestV1Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeManifestV1Builder.lower(value)
}


public protocol ManifestV2BuilderProtocol {
    func accessControllerCancelPrimaryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV2Builder
    func accessControllerCancelPrimaryRoleRecoveryProposal(address: Address)  throws -> ManifestV2Builder
    func accessControllerCancelRecoveryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV2Builder
    func accessControllerCancelRecoveryRoleRecoveryProposal(address: Address)  throws -> ManifestV2Builder
    func accessControllerCreate(controlledAsset: ManifestBuilderBucket, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func accessControllerCreateProof(address: Address)  throws -> ManifestV2Builder
    func accessControllerCreateWithSecurityStructure(controlledAsset: ManifestBuilderBucket, primaryRole: SecurityStructureRole, recoveryRole: SecurityStructureRole, confirmationRole: SecurityStructureRole, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func accessControllerInitiateBadgeWithdrawAsPrimary(address: Address)  throws -> ManifestV2Builder
    func accessControllerInitiateBadgeWithdrawAsRecovery(address: Address)  throws -> ManifestV2Builder
    func accessControllerInitiateRecoveryAsPrimary(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerInitiateRecoveryAsRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerLockPrimaryRole(address: Address)  throws -> ManifestV2Builder
    func accessControllerMintRecoveryBadges(address: Address, nonFungibleLocalIds: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accessControllerNewFromPublicKeys(controlledAsset: ManifestBuilderBucket, primaryRole: PublicKey, recoveryRole: PublicKey, confirmationRole: PublicKey, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func accessControllerQuickConfirmPrimaryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV2Builder
    func accessControllerQuickConfirmPrimaryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerQuickConfirmRecoveryRoleBadgeWithdrawAttempt(address: Address)  throws -> ManifestV2Builder
    func accessControllerQuickConfirmRecoveryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerStopTimedRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerTimedConfirmRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?)  throws -> ManifestV2Builder
    func accessControllerUnlockPrimaryRole(address: Address)  throws -> ManifestV2Builder
    func accountAddAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible)  throws -> ManifestV2Builder
    func accountBurn(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountBurnNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accountCreate()  throws -> ManifestV2Builder
    func accountCreateAdvanced(ownerRole: OwnerRole, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func accountCreateProofOfAmount(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountCreateProofOfNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accountDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func accountDepositBatch(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV2Builder
    func accountDepositEntireWorktop(accountAddress: Address)  throws -> ManifestV2Builder
    func accountLockContingentFee(address: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountLockFee(address: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountLockFeeAndWithdraw(address: Address, amountToLock: Decimal, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountLockFeeAndWithdrawNonFungibles(address: Address, amountToLock: Decimal, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accountLockerAirdrop(address: Address, claimants: [String: ResourceSpecifier], bucket: ManifestBuilderBucket, tryDirectSend: Bool)  throws -> ManifestV2Builder
    func accountLockerClaim(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountLockerClaimNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accountLockerGetAmount(address: Address, claimant: Address, resourceAddress: Address)  throws -> ManifestV2Builder
    func accountLockerGetNonFungibleLocalIds(address: Address, claimant: Address, resourceAddress: Address, limit: UInt32)  throws -> ManifestV2Builder
    func accountLockerInstantiate(ownerRole: OwnerRole, storerRole: AccessRule, storerUpdaterRole: AccessRule, recovererRole: AccessRule, recovererUpdaterRole: AccessRule, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func accountLockerInstantiateSimple(allowRecover: Bool)  throws -> ManifestV2Builder
    func accountLockerRecover(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountLockerRecoverNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func accountLockerStore(address: Address, claimant: Address, bucket: ManifestBuilderBucket, tryDirectSend: Bool)  throws -> ManifestV2Builder
    func accountRemoveAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible)  throws -> ManifestV2Builder
    func accountRemoveResourcePreference(address: Address, resourceAddress: Address)  throws -> ManifestV2Builder
    func accountSecurify(address: Address)  throws -> ManifestV2Builder
    func accountSetDefaultDepositRule(address: Address, defaultDepositRule: AccountDefaultDepositRule)  throws -> ManifestV2Builder
    func accountSetResourcePreference(address: Address, resourceAddress: Address, resourcePreference: ResourcePreference)  throws -> ManifestV2Builder
    func accountTryDepositBatchOrAbort(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountTryDepositBatchOrRefund(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountTryDepositEntireWorktopOrAbort(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountTryDepositEntireWorktopOrRefund(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountTryDepositOrAbort(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountTryDepositOrRefund(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?)  throws -> ManifestV2Builder
    func accountWithdraw(address: Address, resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func accountWithdrawNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func addInstruction(instruction: InstructionV2)  throws -> ManifestV2Builder
    func allocateGlobalAddress(packageAddress: Address, blueprintName: String, intoAddressReservation: ManifestBuilderAddressReservation, intoNamedAddress: ManifestBuilderNamedAddress)  throws -> ManifestV2Builder
    func assertWorktopContains(resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func assertWorktopContainsAny(resourceAddress: Address)  throws -> ManifestV2Builder
    func assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])  throws -> ManifestV2Builder
    func build()   -> TransactionManifestV2
    func burnResource(bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func callAccessRulesMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func callDirectVaultMethod(address: Address, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func callFunction(address: ManifestBuilderAddress, blueprintName: String, functionName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func callMetadataMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func callMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func callRoyaltyMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func cloneProof(proof: ManifestBuilderProof, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createFungibleResourceManager(ownerRole: OwnerRole, trackTotalSupply: Bool, divisibility: UInt8, initialSupply: Decimal?, resourceRoles: FungibleResourceRoles, metadata: MetadataModuleConfig, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func createProofFromAuthZoneOfAll(resourceAddress: Address, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId], intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createProofFromBucketOfAll(bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createProofFromBucketOfAmount(amount: Decimal, bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func createProofFromBucketOfNonFungibles(ids: [NonFungibleLocalId], bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func dropAllProofs()  throws -> ManifestV2Builder
    func dropAuthZoneProofs()  throws -> ManifestV2Builder
    func dropAuthZoneSignatureProofs()  throws -> ManifestV2Builder
    func dropProof(proof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func faucetFreeXrd()  throws -> ManifestV2Builder
    func faucetLockFee()  throws -> ManifestV2Builder
    func identityCreate()  throws -> ManifestV2Builder
    func identityCreateAdvanced(ownerRole: OwnerRole)  throws -> ManifestV2Builder
    func identitySecurify(address: Address)  throws -> ManifestV2Builder
    func metadataGet(address: Address, key: String)  throws -> ManifestV2Builder
    func metadataLock(address: Address, key: String)  throws -> ManifestV2Builder
    func metadataRemove(address: Address, key: String)  throws -> ManifestV2Builder
    func metadataSet(address: Address, key: String, value: MetadataValue)  throws -> ManifestV2Builder
    func mintFungible(resourceAddress: Address, amount: Decimal)  throws -> ManifestV2Builder
    func multiResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV2Builder
    func multiResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV2Builder
    func multiResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV2Builder
    func multiResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func multiResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func multiResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV2Builder
    func multiResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func oneResourcePoolContribute(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func oneResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV2Builder
    func oneResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV2Builder
    func oneResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddress: Address, addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func oneResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func oneResourcePoolProtectedWithdraw(address: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV2Builder
    func oneResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func packageClaimRoyalty(address: Address)  throws -> ManifestV2Builder
    func packagePublish(code: Data, definition: Data, metadata: [String: MetadataInitEntry])  throws -> ManifestV2Builder
    func packagePublishAdvanced(ownerRole: OwnerRole, code: Data, definition: Data, metadata: [String: MetadataInitEntry], packageAddress: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func popFromAuthZone(intoProof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func pushToAuthZone(proof: ManifestBuilderProof)  throws -> ManifestV2Builder
    func returnToWorktop(bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func roleAssignmentGet(address: Address, module: ModuleId, roleKey: String)  throws -> ManifestV2Builder
    func roleAssignmentLockOwner(address: Address)  throws -> ManifestV2Builder
    func roleAssignmentSet(address: Address, module: ModuleId, roleKey: String, rule: AccessRule)  throws -> ManifestV2Builder
    func roleAssignmentSetOwner(address: Address, rule: AccessRule)  throws -> ManifestV2Builder
    func royaltyClaim(address: Address)  throws -> ManifestV2Builder
    func royaltyLock(address: Address, method: String)  throws -> ManifestV2Builder
    func royaltySet(address: Address, method: String, amount: RoyaltyAmount)  throws -> ManifestV2Builder
    func takeAllFromWorktop(resourceAddress: Address, intoBucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func takeFromWorktop(resourceAddress: Address, amount: Decimal, intoBucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId], intoBucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func twoResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket])  throws -> ManifestV2Builder
    func twoResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal)  throws -> ManifestV2Builder
    func twoResourcePoolGetVaultAmount(address: Address)  throws -> ManifestV2Builder
    func twoResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?)  throws -> ManifestV2Builder
    func twoResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func twoResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy)  throws -> ManifestV2Builder
    func twoResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func useChild(subintentHash: TransactionHash, name: ManifestBuilderIntent)  throws -> ManifestV2Builder
    func validatorAcceptsDelegatedStake(address: Address)  throws -> ManifestV2Builder
    func validatorClaimXrd(address: Address, bucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func validatorFinishUnlockOwnerStakeUnits(address: Address)  throws -> ManifestV2Builder
    func validatorGetProtocolUpdateReadiness(address: Address)  throws -> ManifestV2Builder
    func validatorGetRedemptionValue(address: Address, amountOfStakeUnits: Decimal)  throws -> ManifestV2Builder
    func validatorLockOwnerStakeUnits(address: Address, stakeUnitBucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func validatorRegister(address: Address)  throws -> ManifestV2Builder
    func validatorSignalProtocolUpdateReadiness(address: Address, vote: String)  throws -> ManifestV2Builder
    func validatorStake(address: Address, stake: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func validatorStakeAsOwner(address: Address, stake: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func validatorStartUnlockOwnerStakeUnits(address: Address, requestedStakeUnitAmount: Decimal)  throws -> ManifestV2Builder
    func validatorTotalStakeUnitSupply(address: Address)  throws -> ManifestV2Builder
    func validatorTotalStakeXrdAmount(address: Address)  throws -> ManifestV2Builder
    func validatorUnregister(address: Address)  throws -> ManifestV2Builder
    func validatorUnstake(address: Address, stakeUnitBucket: ManifestBuilderBucket)  throws -> ManifestV2Builder
    func validatorUpdateAcceptDelegatedStake(address: Address, acceptDelegatedStake: Bool)  throws -> ManifestV2Builder
    func validatorUpdateFee(address: Address, newFeeFactor: Decimal)  throws -> ManifestV2Builder
    func validatorUpdateKey(address: Address, key: PublicKey)  throws -> ManifestV2Builder
    func verifyParent(accessRule: AccessRule)  throws -> ManifestV2Builder
    func yieldToChild(name: ManifestBuilderIntent, args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    func yieldToParent(args: [ManifestBuilderValue])  throws -> ManifestV2Builder
    
}

public class ManifestV2Builder: ManifestV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(networkId: UInt8)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestv2builder_new(
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_manifestv2builder(pointer, $0) }
    }

    

    
    

    public func accessControllerCancelPrimaryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_cancel_primary_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelPrimaryRoleRecoveryProposal(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_cancel_primary_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelRecoveryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_cancel_recovery_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCancelRecoveryRoleRecoveryProposal(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_cancel_recovery_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCreate(controlledAsset: ManifestBuilderBucket, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_create(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerCreateProof(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_create_proof(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerCreateWithSecurityStructure(controlledAsset: ManifestBuilderBucket, primaryRole: SecurityStructureRole, recoveryRole: SecurityStructureRole, confirmationRole: SecurityStructureRole, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_create_with_security_structure(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypeSecurityStructureRole.lower(primaryRole),
        FfiConverterTypeSecurityStructureRole.lower(recoveryRole),
        FfiConverterTypeSecurityStructureRole.lower(confirmationRole),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerInitiateBadgeWithdrawAsPrimary(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_initiate_badge_withdraw_as_primary(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerInitiateBadgeWithdrawAsRecovery(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_initiate_badge_withdraw_as_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerInitiateRecoveryAsPrimary(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_initiate_recovery_as_primary(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerInitiateRecoveryAsRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_initiate_recovery_as_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerLockPrimaryRole(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_lock_primary_role(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerMintRecoveryBadges(address: Address, nonFungibleLocalIds: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_mint_recovery_badges(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(nonFungibleLocalIds),$0
    )
}
        )
    }

    public func accessControllerNewFromPublicKeys(controlledAsset: ManifestBuilderBucket, primaryRole: PublicKey, recoveryRole: PublicKey, confirmationRole: PublicKey, timedRecoveryDelayInMinutes: UInt32?, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_new_from_public_keys(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(controlledAsset),
        FfiConverterTypePublicKey.lower(primaryRole),
        FfiConverterTypePublicKey.lower(recoveryRole),
        FfiConverterTypePublicKey.lower(confirmationRole),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmPrimaryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmPrimaryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_quick_confirm_primary_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmRecoveryRoleBadgeWithdrawAttempt(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accessControllerQuickConfirmRecoveryRoleRecoveryProposal(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_quick_confirm_recovery_role_recovery_proposal(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerStopTimedRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_stop_timed_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerTimedConfirmRecovery(address: Address, ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_timed_confirm_recovery(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeRuleSet.lower(ruleSet),
        FfiConverterOptionUInt32.lower(timedRecoveryDelayInMinutes),$0
    )
}
        )
    }

    public func accessControllerUnlockPrimaryRole(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_access_controller_unlock_primary_role(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accountAddAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_add_authorized_depositor(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeResourceOrNonFungible.lower(badge),$0
    )
}
        )
    }

    public func accountBurn(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_burn(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountBurnNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_burn_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountCreate() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_create(self.pointer, $0
    )
}
        )
    }

    public func accountCreateAdvanced(ownerRole: OwnerRole, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_create_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accountCreateProofOfAmount(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_create_proof_of_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountCreateProofOfNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_create_proof_of_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func accountDepositBatch(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_deposit_batch(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func accountDepositEntireWorktop(accountAddress: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_deposit_entire_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),$0
    )
}
        )
    }

    public func accountLockContingentFee(address: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_lock_contingent_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFee(address: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_lock_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFeeAndWithdraw(address: Address, amountToLock: Decimal, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_lock_fee_and_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountToLock),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockFeeAndWithdrawNonFungibles(address: Address, amountToLock: Decimal, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_lock_fee_and_withdraw_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountToLock),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerAirdrop(address: Address, claimants: [String: ResourceSpecifier], bucket: ManifestBuilderBucket, tryDirectSend: Bool) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_airdrop(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterDictionaryStringTypeResourceSpecifier.lower(claimants),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterBool.lower(tryDirectSend),$0
    )
}
        )
    }

    public func accountLockerClaim(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_claim(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockerClaimNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_claim_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerGetAmount(address: Address, claimant: Address, resourceAddress: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_get_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func accountLockerGetNonFungibleLocalIds(address: Address, claimant: Address, resourceAddress: Address, limit: UInt32) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_get_non_fungible_local_ids(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterUInt32.lower(limit),$0
    )
}
        )
    }

    public func accountLockerInstantiate(ownerRole: OwnerRole, storerRole: AccessRule, storerUpdaterRole: AccessRule, recovererRole: AccessRule, recovererUpdaterRole: AccessRule, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(storerRole),
        FfiConverterTypeAccessRule.lower(storerUpdaterRole),
        FfiConverterTypeAccessRule.lower(recovererRole),
        FfiConverterTypeAccessRule.lower(recovererUpdaterRole),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func accountLockerInstantiateSimple(allowRecover: Bool) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_instantiate_simple(self.pointer, 
        FfiConverterBool.lower(allowRecover),$0
    )
}
        )
    }

    public func accountLockerRecover(address: Address, claimant: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_recover(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountLockerRecoverNonFungibles(address: Address, claimant: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_recover_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func accountLockerStore(address: Address, claimant: Address, bucket: ManifestBuilderBucket, tryDirectSend: Bool) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_locker_store(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(claimant),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterBool.lower(tryDirectSend),$0
    )
}
        )
    }

    public func accountRemoveAuthorizedDepositor(address: Address, badge: ResourceOrNonFungible) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_remove_authorized_depositor(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeResourceOrNonFungible.lower(badge),$0
    )
}
        )
    }

    public func accountRemoveResourcePreference(address: Address, resourceAddress: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_remove_resource_preference(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func accountSecurify(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_securify(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func accountSetDefaultDepositRule(address: Address, defaultDepositRule: AccountDefaultDepositRule) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_set_default_deposit_rule(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAccountDefaultDepositRule.lower(defaultDepositRule),$0
    )
}
        )
    }

    public func accountSetResourcePreference(address: Address, resourceAddress: Address, resourcePreference: ResourcePreference) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_set_resource_preference(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeResourcePreference.lower(resourcePreference),$0
    )
}
        )
    }

    public func accountTryDepositBatchOrAbort(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_batch_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositBatchOrRefund(address: Address, buckets: [ManifestBuilderBucket], authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_batch_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositEntireWorktopOrAbort(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_entire_worktop_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositEntireWorktopOrRefund(accountAddress: Address, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_entire_worktop_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(accountAddress),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositOrAbort(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountTryDepositOrRefund(address: Address, bucket: ManifestBuilderBucket, authorizedDepositorBadge: ResourceOrNonFungible?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_try_deposit_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterOptionTypeResourceOrNonFungible.lower(authorizedDepositorBadge),$0
    )
}
        )
    }

    public func accountWithdraw(address: Address, resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func accountWithdrawNonFungibles(address: Address, resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_account_withdraw_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func addInstruction(instruction: InstructionV2) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_add_instruction(self.pointer, 
        FfiConverterTypeInstructionV2.lower(instruction),$0
    )
}
        )
    }

    public func allocateGlobalAddress(packageAddress: Address, blueprintName: String, intoAddressReservation: ManifestBuilderAddressReservation, intoNamedAddress: ManifestBuilderNamedAddress) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_allocate_global_address(self.pointer, 
        FfiConverterTypeAddress.lower(packageAddress),
        FfiConverterString.lower(blueprintName),
        FfiConverterTypeManifestBuilderAddressReservation.lower(intoAddressReservation),
        FfiConverterTypeManifestBuilderNamedAddress.lower(intoNamedAddress),$0
    )
}
        )
    }

    public func assertWorktopContains(resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_assert_worktop_contains(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func assertWorktopContainsAny(resourceAddress: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_assert_worktop_contains_any(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),$0
    )
}
        )
    }

    public func assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_assert_worktop_contains_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),$0
    )
}
        )
    }

    public func build()  -> TransactionManifestV2 {
        return try!  FfiConverterTypeTransactionManifestV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_build(self.pointer, $0
    )
}
        )
    }

    public func burnResource(bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_burn_resource(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func callAccessRulesMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_access_rules_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callDirectVaultMethod(address: Address, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_direct_vault_method(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callFunction(address: ManifestBuilderAddress, blueprintName: String, functionName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_function(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(blueprintName),
        FfiConverterString.lower(functionName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callMetadataMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_metadata_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func callRoyaltyMethod(address: ManifestBuilderAddress, methodName: String, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_call_royalty_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(address),
        FfiConverterString.lower(methodName),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func cloneProof(proof: ManifestBuilderProof, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_clone_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createFungibleResourceManager(ownerRole: OwnerRole, trackTotalSupply: Bool, divisibility: UInt8, initialSupply: Decimal?, resourceRoles: FungibleResourceRoles, metadata: MetadataModuleConfig, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_fungible_resource_manager(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterBool.lower(trackTotalSupply),
        FfiConverterUInt8.lower(divisibility),
        FfiConverterOptionTypeDecimal.lower(initialSupply),
        FfiConverterTypeFungibleResourceRoles.lower(resourceRoles),
        FfiConverterTypeMetadataModuleConfig.lower(metadata),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfAll(resourceAddress: Address, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_auth_zone_of_all(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_auth_zone_of_amount(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId], intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_auth_zone_of_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfAll(bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_bucket_of_all(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfAmount(amount: Decimal, bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_bucket_of_amount(self.pointer, 
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func createProofFromBucketOfNonFungibles(ids: [NonFungibleLocalId], bucket: ManifestBuilderBucket, intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_create_proof_from_bucket_of_non_fungibles(self.pointer, 
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func dropAllProofs() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_drop_all_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropAuthZoneProofs() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_drop_auth_zone_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropAuthZoneSignatureProofs() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_drop_auth_zone_signature_proofs(self.pointer, $0
    )
}
        )
    }

    public func dropProof(proof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_drop_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),$0
    )
}
        )
    }

    public func faucetFreeXrd() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_faucet_free_xrd(self.pointer, $0
    )
}
        )
    }

    public func faucetLockFee() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_faucet_lock_fee(self.pointer, $0
    )
}
        )
    }

    public func identityCreate() throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_identity_create(self.pointer, $0
    )
}
        )
    }

    public func identityCreateAdvanced(ownerRole: OwnerRole) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_identity_create_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),$0
    )
}
        )
    }

    public func identitySecurify(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_identity_securify(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func metadataGet(address: Address, key: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_metadata_get(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataLock(address: Address, key: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_metadata_lock(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataRemove(address: Address, key: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_metadata_remove(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),$0
    )
}
        )
    }

    public func metadataSet(address: Address, key: String, value: MetadataValue) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_metadata_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(key),
        FfiConverterTypeMetadataValue.lower(value),$0
    )
}
        )
    }

    public func mintFungible(resourceAddress: Address, amount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_mint_fungible(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),$0
    )
}
        )
    }

    public func multiResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func multiResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func multiResourcePoolGetVaultAmount(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func multiResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterSequenceTypeAddress.lower(resourceAddresses),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func multiResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func multiResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func multiResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_multi_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolContribute(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func oneResourcePoolGetVaultAmount(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func oneResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddress: Address, addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func oneResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func oneResourcePoolProtectedWithdraw(address: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func oneResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_one_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func packageClaimRoyalty(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_package_claim_royalty(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func packagePublish(code: Data, definition: Data, metadata: [String: MetadataInitEntry]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_package_publish(self.pointer, 
        FfiConverterData.lower(code),
        FfiConverterData.lower(definition),
        FfiConverterDictionaryStringTypeMetadataInitEntry.lower(metadata),$0
    )
}
        )
    }

    public func packagePublishAdvanced(ownerRole: OwnerRole, code: Data, definition: Data, metadata: [String: MetadataInitEntry], packageAddress: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_package_publish_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterData.lower(code),
        FfiConverterData.lower(definition),
        FfiConverterDictionaryStringTypeMetadataInitEntry.lower(metadata),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(packageAddress),$0
    )
}
        )
    }

    public func popFromAuthZone(intoProof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_pop_from_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(intoProof),$0
    )
}
        )
    }

    public func pushToAuthZone(proof: ManifestBuilderProof) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_push_to_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(proof),$0
    )
}
        )
    }

    public func returnToWorktop(bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_return_to_worktop(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func roleAssignmentGet(address: Address, module: ModuleId, roleKey: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_role_assignment_get(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeModuleId.lower(module),
        FfiConverterString.lower(roleKey),$0
    )
}
        )
    }

    public func roleAssignmentLockOwner(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_role_assignment_lock_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func roleAssignmentSet(address: Address, module: ModuleId, roleKey: String, rule: AccessRule) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_role_assignment_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeModuleId.lower(module),
        FfiConverterString.lower(roleKey),
        FfiConverterTypeAccessRule.lower(rule),$0
    )
}
        )
    }

    public func roleAssignmentSetOwner(address: Address, rule: AccessRule) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_role_assignment_set_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAccessRule.lower(rule),$0
    )
}
        )
    }

    public func royaltyClaim(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_royalty_claim(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func royaltyLock(address: Address, method: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_royalty_lock(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(method),$0
    )
}
        )
    }

    public func royaltySet(address: Address, method: String, amount: RoyaltyAmount) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_royalty_set(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(method),
        FfiConverterTypeRoyaltyAmount.lower(amount),$0
    )
}
        )
    }

    public func takeAllFromWorktop(resourceAddress: Address, intoBucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_take_all_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func takeFromWorktop(resourceAddress: Address, amount: Decimal, intoBucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_take_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId], intoBucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_take_non_fungibles_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        FfiConverterTypeManifestBuilderBucket.lower(intoBucket),$0
    )
}
        )
    }

    public func twoResourcePoolContribute(address: Address, buckets: [ManifestBuilderBucket]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_contribute(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterSequenceTypeManifestBuilderBucket.lower(buckets),$0
    )
}
        )
    }

    public func twoResourcePoolGetRedemptionValue(address: Address, amountOfPoolUnits: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfPoolUnits),$0
    )
}
        )
    }

    public func twoResourcePoolGetVaultAmount(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_get_vault_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func twoResourcePoolInstantiate(ownerRole: OwnerRole, poolManagerRule: AccessRule, resourceAddresses: [Address], addressReservation: ManifestBuilderAddressReservation?) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_instantiate(self.pointer, 
        FfiConverterTypeOwnerRole.lower(ownerRole),
        FfiConverterTypeAccessRule.lower(poolManagerRule),
        FfiConverterSequenceTypeAddress.lower(resourceAddresses),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(addressReservation),$0
    )
}
        )
    }

    public func twoResourcePoolProtectedDeposit(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_protected_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func twoResourcePoolProtectedWithdraw(address: Address, resourceAddress: Address, amount: Decimal, withdrawStrategy: WithdrawStrategy) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_protected_withdraw(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeDecimal.lower(amount),
        FfiConverterTypeWithdrawStrategy.lower(withdrawStrategy),$0
    )
}
        )
    }

    public func twoResourcePoolRedeem(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_two_resource_pool_redeem(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func useChild(subintentHash: TransactionHash, name: ManifestBuilderIntent) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_use_child(self.pointer, 
        FfiConverterTypeTransactionHash.lower(subintentHash),
        FfiConverterTypeManifestBuilderIntent.lower(name),$0
    )
}
        )
    }

    public func validatorAcceptsDelegatedStake(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_accepts_delegated_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorClaimXrd(address: Address, bucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_claim_xrd(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(bucket),$0
    )
}
        )
    }

    public func validatorFinishUnlockOwnerStakeUnits(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_finish_unlock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorGetProtocolUpdateReadiness(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_get_protocol_update_readiness(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorGetRedemptionValue(address: Address, amountOfStakeUnits: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_get_redemption_value(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(amountOfStakeUnits),$0
    )
}
        )
    }

    public func validatorLockOwnerStakeUnits(address: Address, stakeUnitBucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_lock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stakeUnitBucket),$0
    )
}
        )
    }

    public func validatorRegister(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_register(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorSignalProtocolUpdateReadiness(address: Address, vote: String) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_signal_protocol_update_readiness(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterString.lower(vote),$0
    )
}
        )
    }

    public func validatorStake(address: Address, stake: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stake),$0
    )
}
        )
    }

    public func validatorStakeAsOwner(address: Address, stake: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_stake_as_owner(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stake),$0
    )
}
        )
    }

    public func validatorStartUnlockOwnerStakeUnits(address: Address, requestedStakeUnitAmount: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_start_unlock_owner_stake_units(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(requestedStakeUnitAmount),$0
    )
}
        )
    }

    public func validatorTotalStakeUnitSupply(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_total_stake_unit_supply(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorTotalStakeXrdAmount(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_total_stake_xrd_amount(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorUnregister(address: Address) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_unregister(self.pointer, 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }

    public func validatorUnstake(address: Address, stakeUnitBucket: ManifestBuilderBucket) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_unstake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeManifestBuilderBucket.lower(stakeUnitBucket),$0
    )
}
        )
    }

    public func validatorUpdateAcceptDelegatedStake(address: Address, acceptDelegatedStake: Bool) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_update_accept_delegated_stake(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterBool.lower(acceptDelegatedStake),$0
    )
}
        )
    }

    public func validatorUpdateFee(address: Address, newFeeFactor: Decimal) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_update_fee(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeDecimal.lower(newFeeFactor),$0
    )
}
        )
    }

    public func validatorUpdateKey(address: Address, key: PublicKey) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_validator_update_key(self.pointer, 
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypePublicKey.lower(key),$0
    )
}
        )
    }

    public func verifyParent(accessRule: AccessRule) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_verify_parent(self.pointer, 
        FfiConverterTypeAccessRule.lower(accessRule),$0
    )
}
        )
    }

    public func yieldToChild(name: ManifestBuilderIntent, args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_yield_to_child(self.pointer, 
        FfiConverterTypeManifestBuilderIntent.lower(name),
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }

    public func yieldToParent(args: [ManifestBuilderValue]) throws -> ManifestV2Builder {
        return try  FfiConverterTypeManifestV2Builder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestv2builder_yield_to_parent(self.pointer, 
        FfiConverterSequenceTypeManifestBuilderValue.lower(args),$0
    )
}
        )
    }
}

public struct FfiConverterTypeManifestV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ManifestV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ManifestV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestV2Builder {
        return ManifestV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ManifestV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeManifestV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestV2Builder {
    return try FfiConverterTypeManifestV2Builder.lift(pointer)
}

public func FfiConverterTypeManifestV2Builder_lower(_ value: ManifestV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeManifestV2Builder.lower(value)
}


public protocol NonFungibleGlobalIdProtocol {
    func asStr()   -> String
    func localId()   -> NonFungibleLocalId
    func resourceAddress()   -> Address
    
}

public class NonFungibleGlobalId: NonFungibleGlobalIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(nonFungibleGlobalId: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new(
        FfiConverterString.lower(nonFungibleGlobalId),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid(pointer, $0) }
    }

    

    public static func fromParts(resourceAddress: Address, nonFungibleLocalId: NonFungibleLocalId) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts(
        FfiConverterTypeAddress.lower(resourceAddress),
        FfiConverterTypeNonFungibleLocalId.lower(nonFungibleLocalId),$0)
})
    }

    

    public static func globalCallerBadge(componentAddress: Address, networkId: UInt8) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_global_caller_badge(
        FfiConverterTypeAddress.lower(componentAddress),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func packageOfDirectCallerBadge(packageAddress: Address, networkId: UInt8) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_package_of_direct_caller_badge(
        FfiConverterTypeAddress.lower(packageAddress),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    public static func signatureBadge(publicKey: PublicKey, networkId: UInt8) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_signature_badge(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str(self.pointer, $0
    )
}
        )
    }

    public func localId()  -> NonFungibleLocalId {
        return try!  FfiConverterTypeNonFungibleLocalId.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id(self.pointer, $0
    )
}
        )
    }

    public func resourceAddress()  -> Address {
        return try!  FfiConverterTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NonFungibleGlobalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNonFungibleGlobalId_lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(pointer)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}


public protocol NotarizedTransactionV1Protocol {
    func hash()  throws -> TransactionHash
    func intentHash()  throws -> TransactionHash
    func notarizedTransactionHash()  throws -> TransactionHash
    func notarySignature()   -> SignatureV1
    func signedIntent()   -> SignedTransactionIntentV1
    func signedIntentHash()  throws -> TransactionHash
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class NotarizedTransactionV1: NotarizedTransactionV1Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(signedIntent: SignedTransactionIntentV1, notarySignature: SignatureV1)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransactionv1_new(
        FfiConverterTypeSignedTransactionIntentV1.lower(signedIntent),
        FfiConverterTypeSignatureV1.lower(notarySignature),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransactionv1(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledNotarizedTransaction: Data) throws -> NotarizedTransactionV1 {
        return NotarizedTransactionV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransactionv1_from_payload_bytes(
        FfiConverterData.lower(compiledNotarizedTransaction),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_hash(self.pointer, $0
    )
}
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func notarizedTransactionHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_notarized_transaction_hash(self.pointer, $0
    )
}
        )
    }

    public func notarySignature()  -> SignatureV1 {
        return try!  FfiConverterTypeSignatureV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_notary_signature(self.pointer, $0
    )
}
        )
    }

    public func signedIntent()  -> SignedTransactionIntentV1 {
        return try!  FfiConverterTypeSignedTransactionIntentV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_signed_intent(self.pointer, $0
    )
}
        )
    }

    public func signedIntentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_signed_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv1_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeNotarizedTransactionV1: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotarizedTransactionV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransactionV1 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotarizedTransactionV1, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransactionV1 {
        return NotarizedTransactionV1(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotarizedTransactionV1) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotarizedTransactionV1_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransactionV1 {
    return try FfiConverterTypeNotarizedTransactionV1.lift(pointer)
}

public func FfiConverterTypeNotarizedTransactionV1_lower(_ value: NotarizedTransactionV1) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotarizedTransactionV1.lower(value)
}


public protocol NotarizedTransactionV2Protocol {
    func hash()  throws -> TransactionHash
    func intentHash()  throws -> TransactionHash
    func notarizedTransactionHash()  throws -> TransactionHash
    func notarySignature()   -> SignatureV1
    func signedTransactionIntent()   -> SignedTransactionIntentV2
    func signedTransactionIntentHash()  throws -> TransactionHash
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class NotarizedTransactionV2: NotarizedTransactionV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(signedTransactionIntent: SignedTransactionIntentV2, notarySignature: SignatureV1)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransactionv2_new(
        FfiConverterTypeSignedTransactionIntentV2.lower(signedTransactionIntent),
        FfiConverterTypeSignatureV1.lower(notarySignature),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransactionv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledNotarizedTransaction: Data) throws -> NotarizedTransactionV2 {
        return NotarizedTransactionV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransactionv2_from_payload_bytes(
        FfiConverterData.lower(compiledNotarizedTransaction),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_hash(self.pointer, $0
    )
}
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func notarizedTransactionHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_notarized_transaction_hash(self.pointer, $0
    )
}
        )
    }

    public func notarySignature()  -> SignatureV1 {
        return try!  FfiConverterTypeSignatureV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_notary_signature(self.pointer, $0
    )
}
        )
    }

    public func signedTransactionIntent()  -> SignedTransactionIntentV2 {
        return try!  FfiConverterTypeSignedTransactionIntentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_signed_transaction_intent(self.pointer, $0
    )
}
        )
    }

    public func signedTransactionIntentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_signed_transaction_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransactionv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeNotarizedTransactionV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotarizedTransactionV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransactionV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotarizedTransactionV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransactionV2 {
        return NotarizedTransactionV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotarizedTransactionV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotarizedTransactionV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransactionV2 {
    return try FfiConverterTypeNotarizedTransactionV2.lift(pointer)
}

public func FfiConverterTypeNotarizedTransactionV2_lower(_ value: NotarizedTransactionV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotarizedTransactionV2.lower(value)
}


public protocol OlympiaAddressProtocol {
    func asStr()   -> String
    func publicKey()  throws -> PublicKey
    
}

public class OlympiaAddress: OlympiaAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(address: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new(
        FfiConverterString.lower(address),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress(pointer, $0) }
    }

    

    
    

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str(self.pointer, $0
    )
}
        )
    }

    public func publicKey() throws -> PublicKey {
        return try  FfiConverterTypePublicKey.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOlympiaAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlympiaAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlympiaAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
        return OlympiaAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOlympiaAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
    return try FfiConverterTypeOlympiaAddress.lift(pointer)
}

public func FfiConverterTypeOlympiaAddress_lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlympiaAddress.lower(value)
}


public protocol PartialTransactionV2Protocol {
    func nonRootSubintents()   -> [SubintentV2]
    func rootSubintent()   -> SubintentV2
    func rootSubintentHash()  throws -> TransactionHash
    func toPayloadBytes()  throws -> Data
    
}

public class PartialTransactionV2: PartialTransactionV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(rootSubintent: SubintentV2, nonRootSubintents: [SubintentV2])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_partialtransactionv2_new(
        FfiConverterTypeSubintentV2.lower(rootSubintent),
        FfiConverterSequenceTypeSubintentV2.lower(nonRootSubintents),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_partialtransactionv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledIntent: Data) throws -> PartialTransactionV2 {
        return PartialTransactionV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_partialtransactionv2_from_payload_bytes(
        FfiConverterData.lower(compiledIntent),$0)
})
    }

    

    
    

    public func nonRootSubintents()  -> [SubintentV2] {
        return try!  FfiConverterSequenceTypeSubintentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2_non_root_subintents(self.pointer, $0
    )
}
        )
    }

    public func rootSubintent()  -> SubintentV2 {
        return try!  FfiConverterTypeSubintentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2_root_subintent(self.pointer, $0
    )
}
        )
    }

    public func rootSubintentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2_root_subintent_hash(self.pointer, $0
    )
}
        )
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypePartialTransactionV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PartialTransactionV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PartialTransactionV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PartialTransactionV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PartialTransactionV2 {
        return PartialTransactionV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PartialTransactionV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePartialTransactionV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> PartialTransactionV2 {
    return try FfiConverterTypePartialTransactionV2.lift(pointer)
}

public func FfiConverterTypePartialTransactionV2_lower(_ value: PartialTransactionV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypePartialTransactionV2.lower(value)
}


public protocol PartialTransactionV2BuilderProtocol {
    func addChild(child: PartialTransactionV2)   -> PartialTransactionV2Builder
    func build()  throws -> PartialTransactionV2
    func intentHeader(intentHeader: IntentHeaderV2)   -> PartialTransactionV2Builder
    func manifest(manifest: TransactionManifestV2)   -> PartialTransactionV2Builder
    func message(message: MessageV2)   -> PartialTransactionV2Builder
    
}

public class PartialTransactionV2Builder: PartialTransactionV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_partialtransactionv2builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_partialtransactionv2builder(pointer, $0) }
    }

    

    
    

    public func addChild(child: PartialTransactionV2)  -> PartialTransactionV2Builder {
        return try!  FfiConverterTypePartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2builder_add_child(self.pointer, 
        FfiConverterTypePartialTransactionV2.lower(child),$0
    )
}
        )
    }

    public func build() throws -> PartialTransactionV2 {
        return try  FfiConverterTypePartialTransactionV2.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2builder_build(self.pointer, $0
    )
}
        )
    }

    public func intentHeader(intentHeader: IntentHeaderV2)  -> PartialTransactionV2Builder {
        return try!  FfiConverterTypePartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2builder_intent_header(self.pointer, 
        FfiConverterTypeIntentHeaderV2.lower(intentHeader),$0
    )
}
        )
    }

    public func manifest(manifest: TransactionManifestV2)  -> PartialTransactionV2Builder {
        return try!  FfiConverterTypePartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2builder_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
}
        )
    }

    public func message(message: MessageV2)  -> PartialTransactionV2Builder {
        return try!  FfiConverterTypePartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_partialtransactionv2builder_message(self.pointer, 
        FfiConverterTypeMessageV2.lower(message),$0
    )
}
        )
    }
}

public struct FfiConverterTypePartialTransactionV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PartialTransactionV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PartialTransactionV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PartialTransactionV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PartialTransactionV2Builder {
        return PartialTransactionV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PartialTransactionV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePartialTransactionV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PartialTransactionV2Builder {
    return try FfiConverterTypePartialTransactionV2Builder.lift(pointer)
}

public func FfiConverterTypePartialTransactionV2Builder_lower(_ value: PartialTransactionV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePartialTransactionV2Builder.lower(value)
}


public protocol PreciseDecimalProtocol {
    func abs()  throws -> PreciseDecimal
    func add(other: PreciseDecimal)  throws -> PreciseDecimal
    func asStr()   -> String
    func cbrt()  throws -> PreciseDecimal
    func ceiling()  throws -> PreciseDecimal
    func div(other: PreciseDecimal)  throws -> PreciseDecimal
    func equal(other: PreciseDecimal)   -> Bool
    func floor()  throws -> PreciseDecimal
    func greaterThan(other: PreciseDecimal)   -> Bool
    func greaterThanOrEqual(other: PreciseDecimal)   -> Bool
    func isNegative()   -> Bool
    func isPositive()   -> Bool
    func isZero()   -> Bool
    func lessThan(other: PreciseDecimal)   -> Bool
    func lessThanOrEqual(other: PreciseDecimal)   -> Bool
    func mantissa()   -> String
    func mul(other: PreciseDecimal)  throws -> PreciseDecimal
    func notEqual(other: PreciseDecimal)   -> Bool
    func nthRoot(n: UInt32)   -> PreciseDecimal?
    func powi(exp: Int64)  throws -> PreciseDecimal
    func round(decimalPlaces: Int32, roundingMode: RoundingMode)  throws -> PreciseDecimal
    func sqrt()   -> PreciseDecimal?
    func sub(other: PreciseDecimal)  throws -> PreciseDecimal
    func toLeBytes()   -> Data
    
}

public class PreciseDecimal: PreciseDecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(value: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new(
        FfiConverterString.lower(value),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal(pointer, $0) }
    }

    

    public static func fromLeBytes(value: Data)  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_from_le_bytes(
        FfiConverterData.lower(value),$0)
})
    }

    

    public static func max()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max($0)
})
    }

    

    public static func min()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min($0)
})
    }

    

    public static func one()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one($0)
})
    }

    

    public static func zero()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero($0)
})
    }

    

    
    

    public func abs() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs(self.pointer, $0
    )
}
        )
    }

    public func add(other: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str(self.pointer, $0
    )
}
        )
    }

    public func cbrt() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt(self.pointer, $0
    )
}
        )
    }

    public func ceiling() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling(self.pointer, $0
    )
}
        )
    }

    public func div(other: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func equal(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func floor() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor(self.pointer, $0
    )
}
        )
    }

    public func greaterThan(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func greaterThanOrEqual(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func isNegative()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative(self.pointer, $0
    )
}
        )
    }

    public func isPositive()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive(self.pointer, $0
    )
}
        )
    }

    public func isZero()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero(self.pointer, $0
    )
}
        )
    }

    public func lessThan(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func lessThanOrEqual(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func mantissa()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa(self.pointer, $0
    )
}
        )
    }

    public func mul(other: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func notEqual(other: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func nthRoot(n: UInt32)  -> PreciseDecimal? {
        return try!  FfiConverterOptionTypePreciseDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root(self.pointer, 
        FfiConverterUInt32.lower(n),$0
    )
}
        )
    }

    public func powi(exp: Int64) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi(self.pointer, 
        FfiConverterInt64.lower(exp),$0
    )
}
        )
    }

    public func round(decimalPlaces: Int32, roundingMode: RoundingMode) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round(self.pointer, 
        FfiConverterInt32.lower(decimalPlaces),
        FfiConverterTypeRoundingMode.lower(roundingMode),$0
    )
}
        )
    }

    public func sqrt()  -> PreciseDecimal? {
        return try!  FfiConverterOptionTypePreciseDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt(self.pointer, $0
    )
}
        )
    }

    public func sub(other: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(other),$0
    )
}
        )
    }

    public func toLeBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_to_le_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypePreciseDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreciseDecimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreciseDecimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreciseDecimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePreciseDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
    return try FfiConverterTypePreciseDecimal.lift(pointer)
}

public func FfiConverterTypePreciseDecimal_lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreciseDecimal.lower(value)
}


public protocol PreviewPartialTransactionV2Protocol {
    func nonRootSubintentSigners()   -> [[PublicKey]]
    func partialTransaction()   -> PartialTransactionV2
    func rootSubintentHash()  throws -> TransactionHash
    func rootSubintentSigners()   -> [PublicKey]
    
}

public class PreviewPartialTransactionV2: PreviewPartialTransactionV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(partialTransaction: PartialTransactionV2, rootSubintentSigners: [PublicKey], nonRootSubintentSigners: [[PublicKey]])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_previewpartialtransactionv2_new(
        FfiConverterTypePartialTransactionV2.lower(partialTransaction),
        FfiConverterSequenceTypePublicKey.lower(rootSubintentSigners),
        FfiConverterSequenceSequenceTypePublicKey.lower(nonRootSubintentSigners),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_previewpartialtransactionv2(pointer, $0) }
    }

    

    
    

    public func nonRootSubintentSigners()  -> [[PublicKey]] {
        return try!  FfiConverterSequenceSequenceTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2_non_root_subintent_signers(self.pointer, $0
    )
}
        )
    }

    public func partialTransaction()  -> PartialTransactionV2 {
        return try!  FfiConverterTypePartialTransactionV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2_partial_transaction(self.pointer, $0
    )
}
        )
    }

    public func rootSubintentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2_root_subintent_hash(self.pointer, $0
    )
}
        )
    }

    public func rootSubintentSigners()  -> [PublicKey] {
        return try!  FfiConverterSequenceTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2_root_subintent_signers(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypePreviewPartialTransactionV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreviewPartialTransactionV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreviewPartialTransactionV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreviewPartialTransactionV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewPartialTransactionV2 {
        return PreviewPartialTransactionV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreviewPartialTransactionV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePreviewPartialTransactionV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewPartialTransactionV2 {
    return try FfiConverterTypePreviewPartialTransactionV2.lift(pointer)
}

public func FfiConverterTypePreviewPartialTransactionV2_lower(_ value: PreviewPartialTransactionV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreviewPartialTransactionV2.lower(value)
}


public protocol PreviewPartialTransactionV2BuilderProtocol {
    func addChild(child: PreviewPartialTransactionV2)   -> PreviewPartialTransactionV2Builder
    func addRootSubintentSigner(signer: PublicKey)   -> PreviewPartialTransactionV2Builder
    func build()  throws -> PreviewPartialTransactionV2
    func intentHeader(intentHeader: IntentHeaderV2)   -> PreviewPartialTransactionV2Builder
    func manifest(manifest: TransactionManifestV2)   -> PreviewPartialTransactionV2Builder
    func message(message: MessageV2)   -> PreviewPartialTransactionV2Builder
    
}

public class PreviewPartialTransactionV2Builder: PreviewPartialTransactionV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_previewpartialtransactionv2builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_previewpartialtransactionv2builder(pointer, $0) }
    }

    

    
    

    public func addChild(child: PreviewPartialTransactionV2)  -> PreviewPartialTransactionV2Builder {
        return try!  FfiConverterTypePreviewPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_add_child(self.pointer, 
        FfiConverterTypePreviewPartialTransactionV2.lower(child),$0
    )
}
        )
    }

    public func addRootSubintentSigner(signer: PublicKey)  -> PreviewPartialTransactionV2Builder {
        return try!  FfiConverterTypePreviewPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_add_root_subintent_signer(self.pointer, 
        FfiConverterTypePublicKey.lower(signer),$0
    )
}
        )
    }

    public func build() throws -> PreviewPartialTransactionV2 {
        return try  FfiConverterTypePreviewPartialTransactionV2.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_build(self.pointer, $0
    )
}
        )
    }

    public func intentHeader(intentHeader: IntentHeaderV2)  -> PreviewPartialTransactionV2Builder {
        return try!  FfiConverterTypePreviewPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_intent_header(self.pointer, 
        FfiConverterTypeIntentHeaderV2.lower(intentHeader),$0
    )
}
        )
    }

    public func manifest(manifest: TransactionManifestV2)  -> PreviewPartialTransactionV2Builder {
        return try!  FfiConverterTypePreviewPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
}
        )
    }

    public func message(message: MessageV2)  -> PreviewPartialTransactionV2Builder {
        return try!  FfiConverterTypePreviewPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewpartialtransactionv2builder_message(self.pointer, 
        FfiConverterTypeMessageV2.lower(message),$0
    )
}
        )
    }
}

public struct FfiConverterTypePreviewPartialTransactionV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreviewPartialTransactionV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreviewPartialTransactionV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreviewPartialTransactionV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewPartialTransactionV2Builder {
        return PreviewPartialTransactionV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreviewPartialTransactionV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePreviewPartialTransactionV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewPartialTransactionV2Builder {
    return try FfiConverterTypePreviewPartialTransactionV2Builder.lift(pointer)
}

public func FfiConverterTypePreviewPartialTransactionV2Builder_lower(_ value: PreviewPartialTransactionV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreviewPartialTransactionV2Builder.lower(value)
}


public protocol PreviewTransactionV2BuilderProtocol {
    func addChild(partialPreviewTransaction: PreviewPartialTransactionV2)   -> PreviewTransactionV2Builder
    func addRootIntentSigner(signer: PublicKey)   -> PreviewTransactionV2Builder
    func build()  throws -> Data
    func intentHeader(intentHeader: IntentHeaderV2)   -> PreviewTransactionV2Builder
    func manifest(manifest: TransactionManifestV2)   -> PreviewTransactionV2Builder
    func message(message: MessageV2)   -> PreviewTransactionV2Builder
    func transactionHeader(transactionHeader: TransactionHeaderV2)   -> PreviewTransactionV2Builder
    
}

public class PreviewTransactionV2Builder: PreviewTransactionV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_previewtransactionv2builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_previewtransactionv2builder(pointer, $0) }
    }

    

    
    

    public func addChild(partialPreviewTransaction: PreviewPartialTransactionV2)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_add_child(self.pointer, 
        FfiConverterTypePreviewPartialTransactionV2.lower(partialPreviewTransaction),$0
    )
}
        )
    }

    public func addRootIntentSigner(signer: PublicKey)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_add_root_intent_signer(self.pointer, 
        FfiConverterTypePublicKey.lower(signer),$0
    )
}
        )
    }

    public func build() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_build(self.pointer, $0
    )
}
        )
    }

    public func intentHeader(intentHeader: IntentHeaderV2)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_intent_header(self.pointer, 
        FfiConverterTypeIntentHeaderV2.lower(intentHeader),$0
    )
}
        )
    }

    public func manifest(manifest: TransactionManifestV2)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
}
        )
    }

    public func message(message: MessageV2)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_message(self.pointer, 
        FfiConverterTypeMessageV2.lower(message),$0
    )
}
        )
    }

    public func transactionHeader(transactionHeader: TransactionHeaderV2)  -> PreviewTransactionV2Builder {
        return try!  FfiConverterTypePreviewTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_previewtransactionv2builder_transaction_header(self.pointer, 
        FfiConverterTypeTransactionHeaderV2.lower(transactionHeader),$0
    )
}
        )
    }
}

public struct FfiConverterTypePreviewTransactionV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreviewTransactionV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreviewTransactionV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreviewTransactionV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewTransactionV2Builder {
        return PreviewTransactionV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreviewTransactionV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePreviewTransactionV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreviewTransactionV2Builder {
    return try FfiConverterTypePreviewTransactionV2Builder.lift(pointer)
}

public func FfiConverterTypePreviewTransactionV2Builder_lower(_ value: PreviewTransactionV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreviewTransactionV2Builder.lower(value)
}


public protocol PrivateKeyProtocol {
    func curve()   -> Curve
    func publicKey()   -> PublicKey
    func publicKeyBytes()   -> Data
    func raw()   -> Data
    func rawHex()   -> String
    func sign(hash: Hash)   -> Data
    func signToSignature(hash: Hash)   -> SignatureV1
    func signToSignatureWithPublicKey(hash: Hash)   -> SignatureWithPublicKeyV1
    
}

public class PrivateKey: PrivateKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(bytes: Data, curve: Curve) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new(
        FfiConverterData.lower(bytes),
        FfiConverterTypeCurve.lower(curve),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey(pointer, $0) }
    }

    

    public static func newEd25519(bytes: Data) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519(
        FfiConverterData.lower(bytes),$0)
})
    }

    

    public static func newSecp256k1(bytes: Data) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1(
        FfiConverterData.lower(bytes),$0)
})
    }

    

    
    

    public func curve()  -> Curve {
        return try!  FfiConverterTypeCurve.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_curve(self.pointer, $0
    )
}
        )
    }

    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key(self.pointer, $0
    )
}
        )
    }

    public func publicKeyBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key_bytes(self.pointer, $0
    )
}
        )
    }

    public func raw()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw(self.pointer, $0
    )
}
        )
    }

    public func rawHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw_hex(self.pointer, $0
    )
}
        )
    }

    public func sign(hash: Hash)  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign(self.pointer, 
        FfiConverterTypeHash.lower(hash),$0
    )
}
        )
    }

    public func signToSignature(hash: Hash)  -> SignatureV1 {
        return try!  FfiConverterTypeSignatureV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature(self.pointer, 
        FfiConverterTypeHash.lower(hash),$0
    )
}
        )
    }

    public func signToSignatureWithPublicKey(hash: Hash)  -> SignatureWithPublicKeyV1 {
        return try!  FfiConverterTypeSignatureWithPublicKeyV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key(self.pointer, 
        FfiConverterTypeHash.lower(hash),$0
    )
}
        )
    }
}

public struct FfiConverterTypePrivateKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PrivateKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PrivateKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PrivateKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePrivateKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PrivateKey {
    return try FfiConverterTypePrivateKey.lift(pointer)
}

public func FfiConverterTypePrivateKey_lower(_ value: PrivateKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePrivateKey.lower(value)
}


public protocol SignedPartialTransactionV2Protocol {
    func nonRootSubintentSignatures()   -> [[SignatureWithPublicKeyV1]]
    func partialTransaction()   -> PartialTransactionV2
    func rootSubintentHash()  throws -> TransactionHash
    func rootSubintentSignatures()   -> [SignatureWithPublicKeyV1]
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class SignedPartialTransactionV2: SignedPartialTransactionV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(partialTransaction: PartialTransactionV2, rootSubintentSignatures: [SignatureWithPublicKeyV1], nonRootSubintentSignatures: [[SignatureWithPublicKeyV1]])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedpartialtransactionv2_new(
        FfiConverterTypePartialTransactionV2.lower(partialTransaction),
        FfiConverterSequenceTypeSignatureWithPublicKeyV1.lower(rootSubintentSignatures),
        FfiConverterSequenceSequenceTypeSignatureWithPublicKeyV1.lower(nonRootSubintentSignatures),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedpartialtransactionv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledIntent: Data) throws -> SignedPartialTransactionV2 {
        return SignedPartialTransactionV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedpartialtransactionv2_from_payload_bytes(
        FfiConverterData.lower(compiledIntent),$0)
})
    }

    

    
    

    public func nonRootSubintentSignatures()  -> [[SignatureWithPublicKeyV1]] {
        return try!  FfiConverterSequenceSequenceTypeSignatureWithPublicKeyV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_non_root_subintent_signatures(self.pointer, $0
    )
}
        )
    }

    public func partialTransaction()  -> PartialTransactionV2 {
        return try!  FfiConverterTypePartialTransactionV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_partial_transaction(self.pointer, $0
    )
}
        )
    }

    public func rootSubintentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_root_subintent_hash(self.pointer, $0
    )
}
        )
    }

    public func rootSubintentSignatures()  -> [SignatureWithPublicKeyV1] {
        return try!  FfiConverterSequenceTypeSignatureWithPublicKeyV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_root_subintent_signatures(self.pointer, $0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSignedPartialTransactionV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedPartialTransactionV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedPartialTransactionV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedPartialTransactionV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2 {
        return SignedPartialTransactionV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedPartialTransactionV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedPartialTransactionV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2 {
    return try FfiConverterTypeSignedPartialTransactionV2.lift(pointer)
}

public func FfiConverterTypeSignedPartialTransactionV2_lower(_ value: SignedPartialTransactionV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedPartialTransactionV2.lower(value)
}


public protocol SignedPartialTransactionV2BuilderProtocol {
    func addChild(child: SignedPartialTransactionV2)   -> SignedPartialTransactionV2Builder
    func intentHeader(intentHeader: IntentHeaderV2)   -> SignedPartialTransactionV2Builder
    func manifest(manifest: TransactionManifestV2)   -> SignedPartialTransactionV2Builder
    func message(message: MessageV2)   -> SignedPartialTransactionV2Builder
    func prepareForSigning()  throws -> SignedPartialTransactionV2BuilderSignatureStep
    
}

public class SignedPartialTransactionV2Builder: SignedPartialTransactionV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedpartialtransactionv2builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedpartialtransactionv2builder(pointer, $0) }
    }

    

    
    

    public func addChild(child: SignedPartialTransactionV2)  -> SignedPartialTransactionV2Builder {
        return try!  FfiConverterTypeSignedPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2builder_add_child(self.pointer, 
        FfiConverterTypeSignedPartialTransactionV2.lower(child),$0
    )
}
        )
    }

    public func intentHeader(intentHeader: IntentHeaderV2)  -> SignedPartialTransactionV2Builder {
        return try!  FfiConverterTypeSignedPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2builder_intent_header(self.pointer, 
        FfiConverterTypeIntentHeaderV2.lower(intentHeader),$0
    )
}
        )
    }

    public func manifest(manifest: TransactionManifestV2)  -> SignedPartialTransactionV2Builder {
        return try!  FfiConverterTypeSignedPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2builder_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
}
        )
    }

    public func message(message: MessageV2)  -> SignedPartialTransactionV2Builder {
        return try!  FfiConverterTypeSignedPartialTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2builder_message(self.pointer, 
        FfiConverterTypeMessageV2.lower(message),$0
    )
}
        )
    }

    public func prepareForSigning() throws -> SignedPartialTransactionV2BuilderSignatureStep {
        return try  FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2builder_prepare_for_signing(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSignedPartialTransactionV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedPartialTransactionV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedPartialTransactionV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedPartialTransactionV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2Builder {
        return SignedPartialTransactionV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedPartialTransactionV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedPartialTransactionV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2Builder {
    return try FfiConverterTypeSignedPartialTransactionV2Builder.lift(pointer)
}

public func FfiConverterTypeSignedPartialTransactionV2Builder_lower(_ value: SignedPartialTransactionV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedPartialTransactionV2Builder.lower(value)
}


public protocol SignedPartialTransactionV2BuilderSignatureStepProtocol {
    func build()   -> SignedPartialTransactionV2
    func signWithPrivateKey(privateKey: PrivateKey)   -> SignedPartialTransactionV2BuilderSignatureStep
    func signWithSigner(signer: Signer)   -> SignedPartialTransactionV2BuilderSignatureStep
    
}

public class SignedPartialTransactionV2BuilderSignatureStep: SignedPartialTransactionV2BuilderSignatureStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedpartialtransactionv2buildersignaturestep(pointer, $0) }
    }

    

    
    

    public func build()  -> SignedPartialTransactionV2 {
        return try!  FfiConverterTypeSignedPartialTransactionV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2buildersignaturestep_build(self.pointer, $0
    )
}
        )
    }

    public func signWithPrivateKey(privateKey: PrivateKey)  -> SignedPartialTransactionV2BuilderSignatureStep {
        return try!  FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2buildersignaturestep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func signWithSigner(signer: Signer)  -> SignedPartialTransactionV2BuilderSignatureStep {
        return try!  FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedpartialtransactionv2buildersignaturestep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(signer),$0
    )
}
        )
    }
}

public struct FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedPartialTransactionV2BuilderSignatureStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedPartialTransactionV2BuilderSignatureStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedPartialTransactionV2BuilderSignatureStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2BuilderSignatureStep {
        return SignedPartialTransactionV2BuilderSignatureStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedPartialTransactionV2BuilderSignatureStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedPartialTransactionV2BuilderSignatureStep {
    return try FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep.lift(pointer)
}

public func FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep_lower(_ value: SignedPartialTransactionV2BuilderSignatureStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedPartialTransactionV2BuilderSignatureStep.lower(value)
}


public protocol SignedTransactionIntentV1Protocol {
    func hash()  throws -> TransactionHash
    func intent()   -> IntentV1
    func intentHash()  throws -> TransactionHash
    func intentSignatures()   -> [SignatureWithPublicKeyV1]
    func signedIntentHash()  throws -> TransactionHash
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class SignedTransactionIntentV1: SignedTransactionIntentV1Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(intent: IntentV1, intentSignatures: [SignatureWithPublicKeyV1])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedtransactionintentv1_new(
        FfiConverterTypeIntentV1.lower(intent),
        FfiConverterSequenceTypeSignatureWithPublicKeyV1.lower(intentSignatures),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedtransactionintentv1(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledSignedIntent: Data) throws -> SignedTransactionIntentV1 {
        return SignedTransactionIntentV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedtransactionintentv1_from_payload_bytes(
        FfiConverterData.lower(compiledSignedIntent),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_hash(self.pointer, $0
    )
}
        )
    }

    public func intent()  -> IntentV1 {
        return try!  FfiConverterTypeIntentV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_intent(self.pointer, $0
    )
}
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func intentSignatures()  -> [SignatureWithPublicKeyV1] {
        return try!  FfiConverterSequenceTypeSignatureWithPublicKeyV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_intent_signatures(self.pointer, $0
    )
}
        )
    }

    public func signedIntentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_signed_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv1_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSignedTransactionIntentV1: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedTransactionIntentV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionIntentV1 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedTransactionIntentV1, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedTransactionIntentV1 {
        return SignedTransactionIntentV1(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedTransactionIntentV1) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedTransactionIntentV1_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedTransactionIntentV1 {
    return try FfiConverterTypeSignedTransactionIntentV1.lift(pointer)
}

public func FfiConverterTypeSignedTransactionIntentV1_lower(_ value: SignedTransactionIntentV1) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedTransactionIntentV1.lower(value)
}


public protocol SignedTransactionIntentV2Protocol {
    func hash()  throws -> TransactionHash
    func intentHash()  throws -> TransactionHash
    func signedIntentHash()  throws -> TransactionHash
    func toPayloadBytes()  throws -> Data
    func transactionIntent()   -> TransactionIntentV2
    func transactionIntentSignatures()   -> [SignatureWithPublicKeyV1]
    
}

public class SignedTransactionIntentV2: SignedTransactionIntentV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(transactionIntent: TransactionIntentV2, transactionIntentSignatures: [SignatureWithPublicKeyV1], nonRootSubintentSignatures: [[SignatureWithPublicKeyV1]])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedtransactionintentv2_new(
        FfiConverterTypeTransactionIntentV2.lower(transactionIntent),
        FfiConverterSequenceTypeSignatureWithPublicKeyV1.lower(transactionIntentSignatures),
        FfiConverterSequenceSequenceTypeSignatureWithPublicKeyV1.lower(nonRootSubintentSignatures),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedtransactionintentv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledSignedIntent: Data) throws -> SignedTransactionIntentV2 {
        return SignedTransactionIntentV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedtransactionintentv2_from_payload_bytes(
        FfiConverterData.lower(compiledSignedIntent),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_hash(self.pointer, $0
    )
}
        )
    }

    public func intentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func signedIntentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_signed_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }

    public func transactionIntent()  -> TransactionIntentV2 {
        return try!  FfiConverterTypeTransactionIntentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_transaction_intent(self.pointer, $0
    )
}
        )
    }

    public func transactionIntentSignatures()  -> [SignatureWithPublicKeyV1] {
        return try!  FfiConverterSequenceTypeSignatureWithPublicKeyV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedtransactionintentv2_transaction_intent_signatures(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSignedTransactionIntentV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedTransactionIntentV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionIntentV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedTransactionIntentV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedTransactionIntentV2 {
        return SignedTransactionIntentV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedTransactionIntentV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedTransactionIntentV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedTransactionIntentV2 {
    return try FfiConverterTypeSignedTransactionIntentV2.lift(pointer)
}

public func FfiConverterTypeSignedTransactionIntentV2_lower(_ value: SignedTransactionIntentV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedTransactionIntentV2.lower(value)
}


public protocol SubintentManifestV2Protocol {
    func asEnclosed(networkId: UInt8)   -> TransactionManifestV2?
    func blobs()   -> [Data]
    func extractAddresses()   -> [EntityType: [Address]]
    func instructions()   -> InstructionsV2
    func staticAnalysis(networkId: UInt8)  throws -> StaticAnalysisWithResourceMovements
    func staticallyValidate()  throws
    func toPayloadBytes()  throws -> Data
    
}

public class SubintentManifestV2: SubintentManifestV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(instructions: InstructionsV2, blobs: [Data], children: [Hash])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_subintentmanifestv2_new(
        FfiConverterTypeInstructionsV2.lower(instructions),
        FfiConverterSequenceData.lower(blobs),
        FfiConverterSequenceTypeHash.lower(children),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_subintentmanifestv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiled: Data, networkId: UInt8) throws -> SubintentManifestV2 {
        return SubintentManifestV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_subintentmanifestv2_from_payload_bytes(
        FfiConverterData.lower(compiled),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func asEnclosed(networkId: UInt8)  -> TransactionManifestV2? {
        return try!  FfiConverterOptionTypeTransactionManifestV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_as_enclosed(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func blobs()  -> [Data] {
        return try!  FfiConverterSequenceData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_blobs(self.pointer, $0
    )
}
        )
    }

    public func extractAddresses()  -> [EntityType: [Address]] {
        return try!  FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_extract_addresses(self.pointer, $0
    )
}
        )
    }

    public func instructions()  -> InstructionsV2 {
        return try!  FfiConverterTypeInstructionsV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_instructions(self.pointer, $0
    )
}
        )
    }

    public func staticAnalysis(networkId: UInt8) throws -> StaticAnalysisWithResourceMovements {
        return try  FfiConverterTypeStaticAnalysisWithResourceMovements.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_static_analysis(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func staticallyValidate() throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_statically_validate(self.pointer, $0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentmanifestv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSubintentManifestV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubintentManifestV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentManifestV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubintentManifestV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubintentManifestV2 {
        return SubintentManifestV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubintentManifestV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSubintentManifestV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubintentManifestV2 {
    return try FfiConverterTypeSubintentManifestV2.lift(pointer)
}

public func FfiConverterTypeSubintentManifestV2_lower(_ value: SubintentManifestV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubintentManifestV2.lower(value)
}


public protocol SubintentV2Protocol {
    func subintentHash()  throws -> TransactionHash
    
}

public class SubintentV2: SubintentV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(intentCore: IntentCoreV2)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_subintentv2_new(
        FfiConverterTypeIntentCoreV2.lower(intentCore),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_subintentv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledIntent: Data) throws -> SubintentV2 {
        return SubintentV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_subintentv2_from_payload_bytes(
        FfiConverterData.lower(compiledIntent),$0)
})
    }

    

    
    

    public func subintentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_subintentv2_subintent_hash(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSubintentV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubintentV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubintentV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubintentV2 {
        return SubintentV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubintentV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSubintentV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubintentV2 {
    return try FfiConverterTypeSubintentV2.lift(pointer)
}

public func FfiConverterTypeSubintentV2_lower(_ value: SubintentV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubintentV2.lower(value)
}


public protocol TransactionHashProtocol {
    func asHash()   -> Hash
    func asStr()   -> String
    func bytes()   -> Data
    func networkId()   -> UInt8
    
}

public class TransactionHash: TransactionHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash(pointer, $0) }
    }

    

    public static func fromStr(string: String, networkId: UInt8) throws -> TransactionHash {
        return TransactionHash(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str(
        FfiConverterString.lower(string),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func asHash()  -> Hash {
        return try!  FfiConverterTypeHash.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash(self.pointer, $0
    )
}
        )
    }

    public func asStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str(self.pointer, $0
    )
}
        )
    }

    public func bytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes(self.pointer, $0
    )
}
        )
    }

    public func networkId()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
        return TransactionHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
    return try FfiConverterTypeTransactionHash.lift(pointer)
}

public func FfiConverterTypeTransactionHash_lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionHash.lower(value)
}


public protocol TransactionIntentV2Protocol {
    func hash()  throws -> TransactionHash
    func nonRootSubintents()   -> [SubintentV2]
    func rootIntentCore()   -> IntentCoreV2
    func toPayloadBytes()  throws -> Data
    func transactionHeader()   -> TransactionHeaderV2
    func transactionIntentHash()  throws -> TransactionHash
    
}

public class TransactionIntentV2: TransactionIntentV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(transactionHeader: TransactionHeaderV2, rootIntentCore: IntentCoreV2, nonRootSubintents: [SubintentV2])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionintentv2_new(
        FfiConverterTypeTransactionHeaderV2.lower(transactionHeader),
        FfiConverterTypeIntentCoreV2.lower(rootIntentCore),
        FfiConverterSequenceTypeSubintentV2.lower(nonRootSubintents),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionintentv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiledIntent: Data) throws -> TransactionIntentV2 {
        return TransactionIntentV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionintentv2_from_payload_bytes(
        FfiConverterData.lower(compiledIntent),$0)
})
    }

    

    
    

    public func hash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_hash(self.pointer, $0
    )
}
        )
    }

    public func nonRootSubintents()  -> [SubintentV2] {
        return try!  FfiConverterSequenceTypeSubintentV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_non_root_subintents(self.pointer, $0
    )
}
        )
    }

    public func rootIntentCore()  -> IntentCoreV2 {
        return try!  FfiConverterTypeIntentCoreV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_root_intent_core(self.pointer, $0
    )
}
        )
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }

    public func transactionHeader()  -> TransactionHeaderV2 {
        return try!  FfiConverterTypeTransactionHeaderV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_transaction_header(self.pointer, $0
    )
}
        )
    }

    public func transactionIntentHash() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionintentv2_transaction_intent_hash(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionIntentV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionIntentV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntentV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionIntentV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionIntentV2 {
        return TransactionIntentV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionIntentV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionIntentV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionIntentV2 {
    return try FfiConverterTypeTransactionIntentV2.lift(pointer)
}

public func FfiConverterTypeTransactionIntentV2_lower(_ value: TransactionIntentV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionIntentV2.lower(value)
}


public protocol TransactionManifestV1Protocol {
    func blobs()   -> [Data]
    func dynamicallyAnalyze(networkId: UInt8, toolkitReceipt: String)  throws -> DynamicAnalysis
    func extractAddresses()   -> [EntityType: [Address]]
    func instructions()   -> InstructionsV1
    func staticallyAnalyze(networkId: UInt8)   -> StaticAnalysis
    func staticallyAnalyzeAndValidate(networkId: UInt8)  throws -> StaticAnalysisWithResourceMovements
    func staticallyValidate(networkId: UInt8)  throws
    func toPayloadBytes()  throws -> Data
    
}

public class TransactionManifestV1: TransactionManifestV1Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(instructions: InstructionsV1, blobs: [Data])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifestv1_new(
        FfiConverterTypeInstructionsV1.lower(instructions),
        FfiConverterSequenceData.lower(blobs),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifestv1(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiled: Data, networkId: UInt8) throws -> TransactionManifestV1 {
        return TransactionManifestV1(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifestv1_from_payload_bytes(
        FfiConverterData.lower(compiled),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func blobs()  -> [Data] {
        return try!  FfiConverterSequenceData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_blobs(self.pointer, $0
    )
}
        )
    }

    public func dynamicallyAnalyze(networkId: UInt8, toolkitReceipt: String) throws -> DynamicAnalysis {
        return try  FfiConverterTypeDynamicAnalysis.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_dynamically_analyze(self.pointer, 
        FfiConverterUInt8.lower(networkId),
        FfiConverterString.lower(toolkitReceipt),$0
    )
}
        )
    }

    public func extractAddresses()  -> [EntityType: [Address]] {
        return try!  FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_extract_addresses(self.pointer, $0
    )
}
        )
    }

    public func instructions()  -> InstructionsV1 {
        return try!  FfiConverterTypeInstructionsV1.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_instructions(self.pointer, $0
    )
}
        )
    }

    public func staticallyAnalyze(networkId: UInt8)  -> StaticAnalysis {
        return try!  FfiConverterTypeStaticAnalysis.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_statically_analyze(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func staticallyAnalyzeAndValidate(networkId: UInt8) throws -> StaticAnalysisWithResourceMovements {
        return try  FfiConverterTypeStaticAnalysisWithResourceMovements.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_statically_analyze_and_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func staticallyValidate(networkId: UInt8) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_statically_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv1_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionManifestV1: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionManifestV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestV1 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionManifestV1, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifestV1 {
        return TransactionManifestV1(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionManifestV1) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionManifestV1_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifestV1 {
    return try FfiConverterTypeTransactionManifestV1.lift(pointer)
}

public func FfiConverterTypeTransactionManifestV1_lower(_ value: TransactionManifestV1) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionManifestV1.lower(value)
}


public protocol TransactionManifestV2Protocol {
    func blobs()   -> [Data]
    func dynamicallyAnalyze(networkId: UInt8, toolkitReceipt: String)  throws -> DynamicAnalysis
    func extractAddresses()   -> [EntityType: [Address]]
    func instructions()   -> InstructionsV2
    func staticallyAnalyze(networkId: UInt8)   -> StaticAnalysis
    func staticallyAnalyzeAndValidate(networkId: UInt8)  throws -> StaticAnalysisWithResourceMovements
    func staticallyValidate()  throws
    func toPayloadBytes()  throws -> Data
    
}

public class TransactionManifestV2: TransactionManifestV2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(instructions: InstructionsV2, blobs: [Data], children: [Hash])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifestv2_new(
        FfiConverterTypeInstructionsV2.lower(instructions),
        FfiConverterSequenceData.lower(blobs),
        FfiConverterSequenceTypeHash.lower(children),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifestv2(pointer, $0) }
    }

    

    public static func fromPayloadBytes(compiled: Data, networkId: UInt8) throws -> TransactionManifestV2 {
        return TransactionManifestV2(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifestv2_from_payload_bytes(
        FfiConverterData.lower(compiled),
        FfiConverterUInt8.lower(networkId),$0)
})
    }

    

    
    

    public func blobs()  -> [Data] {
        return try!  FfiConverterSequenceData.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_blobs(self.pointer, $0
    )
}
        )
    }

    public func dynamicallyAnalyze(networkId: UInt8, toolkitReceipt: String) throws -> DynamicAnalysis {
        return try  FfiConverterTypeDynamicAnalysis.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_dynamically_analyze(self.pointer, 
        FfiConverterUInt8.lower(networkId),
        FfiConverterString.lower(toolkitReceipt),$0
    )
}
        )
    }

    public func extractAddresses()  -> [EntityType: [Address]] {
        return try!  FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_extract_addresses(self.pointer, $0
    )
}
        )
    }

    public func instructions()  -> InstructionsV2 {
        return try!  FfiConverterTypeInstructionsV2.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_instructions(self.pointer, $0
    )
}
        )
    }

    public func staticallyAnalyze(networkId: UInt8)  -> StaticAnalysis {
        return try!  FfiConverterTypeStaticAnalysis.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_statically_analyze(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func staticallyAnalyzeAndValidate(networkId: UInt8) throws -> StaticAnalysisWithResourceMovements {
        return try  FfiConverterTypeStaticAnalysisWithResourceMovements.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_statically_analyze_and_validate(self.pointer, 
        FfiConverterUInt8.lower(networkId),$0
    )
}
        )
    }

    public func staticallyValidate() throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_statically_validate(self.pointer, $0
    )
}
    }

    public func toPayloadBytes() throws -> Data {
        return try  FfiConverterData.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifestv2_to_payload_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionManifestV2: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionManifestV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestV2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionManifestV2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifestV2 {
        return TransactionManifestV2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionManifestV2) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionManifestV2_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifestV2 {
    return try FfiConverterTypeTransactionManifestV2.lift(pointer)
}

public func FfiConverterTypeTransactionManifestV2_lower(_ value: TransactionManifestV2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionManifestV2.lower(value)
}


public protocol TransactionV1BuilderProtocol {
    func header(header: TransactionHeaderV1)   -> TransactionV1BuilderHeaderStep
    
}

public class TransactionV1Builder: TransactionV1BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionv1builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv1builder(pointer, $0) }
    }

    

    
    

    public func header(header: TransactionHeaderV1)  -> TransactionV1BuilderHeaderStep {
        return try!  FfiConverterTypeTransactionV1BuilderHeaderStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builder_header(self.pointer, 
        FfiConverterTypeTransactionHeaderV1.lower(header),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV1Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV1Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV1Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV1Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1Builder {
        return TransactionV1Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV1Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV1Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1Builder {
    return try FfiConverterTypeTransactionV1Builder.lift(pointer)
}

public func FfiConverterTypeTransactionV1Builder_lower(_ value: TransactionV1Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV1Builder.lower(value)
}


public protocol TransactionV1BuilderHeaderStepProtocol {
    func manifest(manifest: TransactionManifestV1)   -> TransactionV1BuilderMessageStep
    
}

public class TransactionV1BuilderHeaderStep: TransactionV1BuilderHeaderStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv1builderheaderstep(pointer, $0) }
    }

    

    
    

    public func manifest(manifest: TransactionManifestV1)  -> TransactionV1BuilderMessageStep {
        return try!  FfiConverterTypeTransactionV1BuilderMessageStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builderheaderstep_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV1.lower(manifest),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV1BuilderHeaderStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV1BuilderHeaderStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV1BuilderHeaderStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV1BuilderHeaderStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderHeaderStep {
        return TransactionV1BuilderHeaderStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV1BuilderHeaderStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV1BuilderHeaderStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderHeaderStep {
    return try FfiConverterTypeTransactionV1BuilderHeaderStep.lift(pointer)
}

public func FfiConverterTypeTransactionV1BuilderHeaderStep_lower(_ value: TransactionV1BuilderHeaderStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV1BuilderHeaderStep.lower(value)
}


public protocol TransactionV1BuilderIntentSignaturesStepProtocol {
    func notarizeWithPrivateKey(privateKey: PrivateKey)  throws -> NotarizedTransactionV1
    func notarizeWithSigner(signer: Signer)  throws -> NotarizedTransactionV1
    func signWithPrivateKey(privateKey: PrivateKey)   -> TransactionV1BuilderIntentSignaturesStep
    func signWithSigner(signer: Signer)   -> TransactionV1BuilderIntentSignaturesStep
    
}

public class TransactionV1BuilderIntentSignaturesStep: TransactionV1BuilderIntentSignaturesStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(messageStep: TransactionV1BuilderMessageStep)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionv1builderintentsignaturesstep_new(
        FfiConverterTypeTransactionV1BuilderMessageStep.lower(messageStep),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv1builderintentsignaturesstep(pointer, $0) }
    }

    

    
    

    public func notarizeWithPrivateKey(privateKey: PrivateKey) throws -> NotarizedTransactionV1 {
        return try  FfiConverterTypeNotarizedTransactionV1.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builderintentsignaturesstep_notarize_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func notarizeWithSigner(signer: Signer) throws -> NotarizedTransactionV1 {
        return try  FfiConverterTypeNotarizedTransactionV1.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builderintentsignaturesstep_notarize_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(signer),$0
    )
}
        )
    }

    public func signWithPrivateKey(privateKey: PrivateKey)  -> TransactionV1BuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builderintentsignaturesstep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func signWithSigner(signer: Signer)  -> TransactionV1BuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1builderintentsignaturesstep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(signer),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV1BuilderIntentSignaturesStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV1BuilderIntentSignaturesStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV1BuilderIntentSignaturesStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV1BuilderIntentSignaturesStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderIntentSignaturesStep {
        return TransactionV1BuilderIntentSignaturesStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV1BuilderIntentSignaturesStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV1BuilderIntentSignaturesStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderIntentSignaturesStep {
    return try FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(pointer)
}

public func FfiConverterTypeTransactionV1BuilderIntentSignaturesStep_lower(_ value: TransactionV1BuilderIntentSignaturesStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lower(value)
}


public protocol TransactionV1BuilderMessageStepProtocol {
    func message(message: MessageV1)   -> TransactionV1BuilderIntentSignaturesStep
    func signWithPrivateKey(privateKey: PrivateKey)   -> TransactionV1BuilderIntentSignaturesStep
    func signWithSigner(signer: Signer)   -> TransactionV1BuilderIntentSignaturesStep
    
}

public class TransactionV1BuilderMessageStep: TransactionV1BuilderMessageStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv1buildermessagestep(pointer, $0) }
    }

    

    
    

    public func message(message: MessageV1)  -> TransactionV1BuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1buildermessagestep_message(self.pointer, 
        FfiConverterTypeMessageV1.lower(message),$0
    )
}
        )
    }

    public func signWithPrivateKey(privateKey: PrivateKey)  -> TransactionV1BuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1buildermessagestep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func signWithSigner(signer: Signer)  -> TransactionV1BuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionV1BuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv1buildermessagestep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(signer),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV1BuilderMessageStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV1BuilderMessageStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV1BuilderMessageStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV1BuilderMessageStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderMessageStep {
        return TransactionV1BuilderMessageStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV1BuilderMessageStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV1BuilderMessageStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV1BuilderMessageStep {
    return try FfiConverterTypeTransactionV1BuilderMessageStep.lift(pointer)
}

public func FfiConverterTypeTransactionV1BuilderMessageStep_lower(_ value: TransactionV1BuilderMessageStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV1BuilderMessageStep.lower(value)
}


public protocol TransactionV2BuilderProtocol {
    func addChild(child: SignedPartialTransactionV2)   -> TransactionV2Builder
    func intentHeader(intentHeader: IntentHeaderV2)   -> TransactionV2Builder
    func manifest(manifest: TransactionManifestV2)   -> TransactionV2Builder
    func message(message: MessageV2)   -> TransactionV2Builder
    func prepareForSigning()  throws -> TransactionV2BuilderSignatureStep
    func transactionHeader(transactionHeader: TransactionHeaderV2)   -> TransactionV2Builder
    
}

public class TransactionV2Builder: TransactionV2BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionv2builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv2builder(pointer, $0) }
    }

    

    
    

    public func addChild(child: SignedPartialTransactionV2)  -> TransactionV2Builder {
        return try!  FfiConverterTypeTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_add_child(self.pointer, 
        FfiConverterTypeSignedPartialTransactionV2.lower(child),$0
    )
}
        )
    }

    public func intentHeader(intentHeader: IntentHeaderV2)  -> TransactionV2Builder {
        return try!  FfiConverterTypeTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_intent_header(self.pointer, 
        FfiConverterTypeIntentHeaderV2.lower(intentHeader),$0
    )
}
        )
    }

    public func manifest(manifest: TransactionManifestV2)  -> TransactionV2Builder {
        return try!  FfiConverterTypeTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_manifest(self.pointer, 
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
}
        )
    }

    public func message(message: MessageV2)  -> TransactionV2Builder {
        return try!  FfiConverterTypeTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_message(self.pointer, 
        FfiConverterTypeMessageV2.lower(message),$0
    )
}
        )
    }

    public func prepareForSigning() throws -> TransactionV2BuilderSignatureStep {
        return try  FfiConverterTypeTransactionV2BuilderSignatureStep.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_prepare_for_signing(self.pointer, $0
    )
}
        )
    }

    public func transactionHeader(transactionHeader: TransactionHeaderV2)  -> TransactionV2Builder {
        return try!  FfiConverterTypeTransactionV2Builder.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2builder_transaction_header(self.pointer, 
        FfiConverterTypeTransactionHeaderV2.lower(transactionHeader),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV2Builder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV2Builder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV2Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV2Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV2Builder {
        return TransactionV2Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV2Builder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV2Builder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV2Builder {
    return try FfiConverterTypeTransactionV2Builder.lift(pointer)
}

public func FfiConverterTypeTransactionV2Builder_lower(_ value: TransactionV2Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV2Builder.lower(value)
}


public protocol TransactionV2BuilderSignatureStepProtocol {
    func notarizeWithPrivateKey(privateKey: PrivateKey)  throws -> NotarizedTransactionV2
    func notarizeWithSigner(privateKey: Signer)  throws -> NotarizedTransactionV2
    func signWithPrivateKey(privateKey: PrivateKey)   -> TransactionV2BuilderSignatureStep
    func signWithSigner(signer: Signer)   -> TransactionV2BuilderSignatureStep
    
}

public class TransactionV2BuilderSignatureStep: TransactionV2BuilderSignatureStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionv2buildersignaturestep(pointer, $0) }
    }

    

    
    

    public func notarizeWithPrivateKey(privateKey: PrivateKey) throws -> NotarizedTransactionV2 {
        return try  FfiConverterTypeNotarizedTransactionV2.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2buildersignaturestep_notarize_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func notarizeWithSigner(privateKey: Signer) throws -> NotarizedTransactionV2 {
        return try  FfiConverterTypeNotarizedTransactionV2.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2buildersignaturestep_notarize_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(privateKey),$0
    )
}
        )
    }

    public func signWithPrivateKey(privateKey: PrivateKey)  -> TransactionV2BuilderSignatureStep {
        return try!  FfiConverterTypeTransactionV2BuilderSignatureStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2buildersignaturestep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(privateKey),$0
    )
}
        )
    }

    public func signWithSigner(signer: Signer)  -> TransactionV2BuilderSignatureStep {
        return try!  FfiConverterTypeTransactionV2BuilderSignatureStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionv2buildersignaturestep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(signer),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionV2BuilderSignatureStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionV2BuilderSignatureStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionV2BuilderSignatureStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionV2BuilderSignatureStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV2BuilderSignatureStep {
        return TransactionV2BuilderSignatureStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionV2BuilderSignatureStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionV2BuilderSignatureStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionV2BuilderSignatureStep {
    return try FfiConverterTypeTransactionV2BuilderSignatureStep.lift(pointer)
}

public func FfiConverterTypeTransactionV2BuilderSignatureStep_lower(_ value: TransactionV2BuilderSignatureStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionV2BuilderSignatureStep.lower(value)
}


public struct AccountAddAuthorizedDepositorEvent {
    public var authorizedDepositorBadge: ResourceOrNonFungible

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorizedDepositorBadge: ResourceOrNonFungible) {
        self.authorizedDepositorBadge = authorizedDepositorBadge
    }
}



public struct FfiConverterTypeAccountAddAuthorizedDepositorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddAuthorizedDepositorEvent {
        return try AccountAddAuthorizedDepositorEvent(
            authorizedDepositorBadge: FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: AccountAddAuthorizedDepositorEvent, into buf: inout [UInt8]) {
        FfiConverterTypeResourceOrNonFungible.write(value.authorizedDepositorBadge, into: &buf)
    }
}


public func FfiConverterTypeAccountAddAuthorizedDepositorEvent_lift(_ buf: RustBuffer) throws -> AccountAddAuthorizedDepositorEvent {
    return try FfiConverterTypeAccountAddAuthorizedDepositorEvent.lift(buf)
}

public func FfiConverterTypeAccountAddAuthorizedDepositorEvent_lower(_ value: AccountAddAuthorizedDepositorEvent) -> RustBuffer {
    return FfiConverterTypeAccountAddAuthorizedDepositorEvent.lower(value)
}


public struct AccountRemoveAuthorizedDepositorEvent {
    public var authorizedDepositorBadge: ResourceOrNonFungible

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorizedDepositorBadge: ResourceOrNonFungible) {
        self.authorizedDepositorBadge = authorizedDepositorBadge
    }
}



public struct FfiConverterTypeAccountRemoveAuthorizedDepositorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRemoveAuthorizedDepositorEvent {
        return try AccountRemoveAuthorizedDepositorEvent(
            authorizedDepositorBadge: FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: AccountRemoveAuthorizedDepositorEvent, into buf: inout [UInt8]) {
        FfiConverterTypeResourceOrNonFungible.write(value.authorizedDepositorBadge, into: &buf)
    }
}


public func FfiConverterTypeAccountRemoveAuthorizedDepositorEvent_lift(_ buf: RustBuffer) throws -> AccountRemoveAuthorizedDepositorEvent {
    return try FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.lift(buf)
}

public func FfiConverterTypeAccountRemoveAuthorizedDepositorEvent_lower(_ value: AccountRemoveAuthorizedDepositorEvent) -> RustBuffer {
    return FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.lower(value)
}


public struct AccountRemoveResourcePreferenceEvent {
    public var resourceAddress: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address) {
        self.resourceAddress = resourceAddress
    }
}



public struct FfiConverterTypeAccountRemoveResourcePreferenceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRemoveResourcePreferenceEvent {
        return try AccountRemoveResourcePreferenceEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: AccountRemoveResourcePreferenceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
    }
}


public func FfiConverterTypeAccountRemoveResourcePreferenceEvent_lift(_ buf: RustBuffer) throws -> AccountRemoveResourcePreferenceEvent {
    return try FfiConverterTypeAccountRemoveResourcePreferenceEvent.lift(buf)
}

public func FfiConverterTypeAccountRemoveResourcePreferenceEvent_lower(_ value: AccountRemoveResourcePreferenceEvent) -> RustBuffer {
    return FfiConverterTypeAccountRemoveResourcePreferenceEvent.lower(value)
}


public struct AccountSetDefaultDepositRuleEvent {
    public var defaultDepositRule: AccountDefaultDepositRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(defaultDepositRule: AccountDefaultDepositRule) {
        self.defaultDepositRule = defaultDepositRule
    }
}


extension AccountSetDefaultDepositRuleEvent: Equatable, Hashable {
    public static func ==(lhs: AccountSetDefaultDepositRuleEvent, rhs: AccountSetDefaultDepositRuleEvent) -> Bool {
        if lhs.defaultDepositRule != rhs.defaultDepositRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositRule)
    }
}


public struct FfiConverterTypeAccountSetDefaultDepositRuleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountSetDefaultDepositRuleEvent {
        return try AccountSetDefaultDepositRuleEvent(
            defaultDepositRule: FfiConverterTypeAccountDefaultDepositRule.read(from: &buf)
        )
    }

    public static func write(_ value: AccountSetDefaultDepositRuleEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAccountDefaultDepositRule.write(value.defaultDepositRule, into: &buf)
    }
}


public func FfiConverterTypeAccountSetDefaultDepositRuleEvent_lift(_ buf: RustBuffer) throws -> AccountSetDefaultDepositRuleEvent {
    return try FfiConverterTypeAccountSetDefaultDepositRuleEvent.lift(buf)
}

public func FfiConverterTypeAccountSetDefaultDepositRuleEvent_lower(_ value: AccountSetDefaultDepositRuleEvent) -> RustBuffer {
    return FfiConverterTypeAccountSetDefaultDepositRuleEvent.lower(value)
}


public struct AccountSetResourcePreferenceEvent {
    public var resourceAddress: Address
    public var preference: ResourcePreference

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address, preference: ResourcePreference) {
        self.resourceAddress = resourceAddress
        self.preference = preference
    }
}



public struct FfiConverterTypeAccountSetResourcePreferenceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountSetResourcePreferenceEvent {
        return try AccountSetResourcePreferenceEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            preference: FfiConverterTypeResourcePreference.read(from: &buf)
        )
    }

    public static func write(_ value: AccountSetResourcePreferenceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeResourcePreference.write(value.preference, into: &buf)
    }
}


public func FfiConverterTypeAccountSetResourcePreferenceEvent_lift(_ buf: RustBuffer) throws -> AccountSetResourcePreferenceEvent {
    return try FfiConverterTypeAccountSetResourcePreferenceEvent.lift(buf)
}

public func FfiConverterTypeAccountSetResourcePreferenceEvent_lower(_ value: AccountSetResourcePreferenceEvent) -> RustBuffer {
    return FfiConverterTypeAccountSetResourcePreferenceEvent.lower(value)
}


public struct BadgeWithdrawEvent {
    public var proposer: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer) {
        self.proposer = proposer
    }
}


extension BadgeWithdrawEvent: Equatable, Hashable {
    public static func ==(lhs: BadgeWithdrawEvent, rhs: BadgeWithdrawEvent) -> Bool {
        if lhs.proposer != rhs.proposer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proposer)
    }
}


public struct FfiConverterTypeBadgeWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BadgeWithdrawEvent {
        return try BadgeWithdrawEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: BadgeWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
    }
}


public func FfiConverterTypeBadgeWithdrawEvent_lift(_ buf: RustBuffer) throws -> BadgeWithdrawEvent {
    return try FfiConverterTypeBadgeWithdrawEvent.lift(buf)
}

public func FfiConverterTypeBadgeWithdrawEvent_lower(_ value: BadgeWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeBadgeWithdrawEvent.lower(value)
}


public struct BuildInformation {
    public var version: String
    public var scryptoDependency: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: String, scryptoDependency: DependencyInformation) {
        self.version = version
        self.scryptoDependency = scryptoDependency
    }
}


extension BuildInformation: Equatable, Hashable {
    public static func ==(lhs: BuildInformation, rhs: BuildInformation) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.scryptoDependency != rhs.scryptoDependency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(scryptoDependency)
    }
}


public struct FfiConverterTypeBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildInformation {
        return try BuildInformation(
            version: FfiConverterString.read(from: &buf), 
            scryptoDependency: FfiConverterTypeDependencyInformation.read(from: &buf)
        )
    }

    public static func write(_ value: BuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoDependency, into: &buf)
    }
}


public func FfiConverterTypeBuildInformation_lift(_ buf: RustBuffer) throws -> BuildInformation {
    return try FfiConverterTypeBuildInformation.lift(buf)
}

public func FfiConverterTypeBuildInformation_lower(_ value: BuildInformation) -> RustBuffer {
    return FfiConverterTypeBuildInformation.lower(value)
}


public struct BurnFungibleResourceEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeBurnFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnFungibleResourceEvent {
        return try BurnFungibleResourceEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: BurnFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeBurnFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> BurnFungibleResourceEvent {
    return try FfiConverterTypeBurnFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeBurnFungibleResourceEvent_lower(_ value: BurnFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeBurnFungibleResourceEvent.lower(value)
}


public struct BurnNonFungibleResourceEvent {
    public var ids: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [NonFungibleLocalId]) {
        self.ids = ids
    }
}


extension BurnNonFungibleResourceEvent: Equatable, Hashable {
    public static func ==(lhs: BurnNonFungibleResourceEvent, rhs: BurnNonFungibleResourceEvent) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
    }
}


public struct FfiConverterTypeBurnNonFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnNonFungibleResourceEvent {
        return try BurnNonFungibleResourceEvent(
            ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: BurnNonFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
    }
}


public func FfiConverterTypeBurnNonFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> BurnNonFungibleResourceEvent {
    return try FfiConverterTypeBurnNonFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeBurnNonFungibleResourceEvent_lower(_ value: BurnNonFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeBurnNonFungibleResourceEvent.lower(value)
}


public struct CancelBadgeWithdrawAttemptEvent {
    public var proposer: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer) {
        self.proposer = proposer
    }
}


extension CancelBadgeWithdrawAttemptEvent: Equatable, Hashable {
    public static func ==(lhs: CancelBadgeWithdrawAttemptEvent, rhs: CancelBadgeWithdrawAttemptEvent) -> Bool {
        if lhs.proposer != rhs.proposer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proposer)
    }
}


public struct FfiConverterTypeCancelBadgeWithdrawAttemptEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelBadgeWithdrawAttemptEvent {
        return try CancelBadgeWithdrawAttemptEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: CancelBadgeWithdrawAttemptEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
    }
}


public func FfiConverterTypeCancelBadgeWithdrawAttemptEvent_lift(_ buf: RustBuffer) throws -> CancelBadgeWithdrawAttemptEvent {
    return try FfiConverterTypeCancelBadgeWithdrawAttemptEvent.lift(buf)
}

public func FfiConverterTypeCancelBadgeWithdrawAttemptEvent_lower(_ value: CancelBadgeWithdrawAttemptEvent) -> RustBuffer {
    return FfiConverterTypeCancelBadgeWithdrawAttemptEvent.lower(value)
}


public struct CancelRecoveryProposalEvent {
    public var proposer: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer) {
        self.proposer = proposer
    }
}


extension CancelRecoveryProposalEvent: Equatable, Hashable {
    public static func ==(lhs: CancelRecoveryProposalEvent, rhs: CancelRecoveryProposalEvent) -> Bool {
        if lhs.proposer != rhs.proposer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proposer)
    }
}


public struct FfiConverterTypeCancelRecoveryProposalEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelRecoveryProposalEvent {
        return try CancelRecoveryProposalEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: CancelRecoveryProposalEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
    }
}


public func FfiConverterTypeCancelRecoveryProposalEvent_lift(_ buf: RustBuffer) throws -> CancelRecoveryProposalEvent {
    return try FfiConverterTypeCancelRecoveryProposalEvent.lift(buf)
}

public func FfiConverterTypeCancelRecoveryProposalEvent_lower(_ value: CancelRecoveryProposalEvent) -> RustBuffer {
    return FfiConverterTypeCancelRecoveryProposalEvent.lower(value)
}


public struct ClaimEvent {
    public var claimant: Address
    public var resourceAddress: Address
    public var resources: ResourceSpecifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(claimant: Address, resourceAddress: Address, resources: ResourceSpecifier) {
        self.claimant = claimant
        self.resourceAddress = resourceAddress
        self.resources = resources
    }
}



public struct FfiConverterTypeClaimEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimEvent {
        return try ClaimEvent(
            claimant: FfiConverterTypeAddress.read(from: &buf), 
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            resources: FfiConverterTypeResourceSpecifier.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.claimant, into: &buf)
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeResourceSpecifier.write(value.resources, into: &buf)
    }
}


public func FfiConverterTypeClaimEvent_lift(_ buf: RustBuffer) throws -> ClaimEvent {
    return try FfiConverterTypeClaimEvent.lift(buf)
}

public func FfiConverterTypeClaimEvent_lower(_ value: ClaimEvent) -> RustBuffer {
    return FfiConverterTypeClaimEvent.lower(value)
}


public struct ClaimXrdEvent {
    public var claimedXrd: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(claimedXrd: Decimal) {
        self.claimedXrd = claimedXrd
    }
}



public struct FfiConverterTypeClaimXrdEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimXrdEvent {
        return try ClaimXrdEvent(
            claimedXrd: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimXrdEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.claimedXrd, into: &buf)
    }
}


public func FfiConverterTypeClaimXrdEvent_lift(_ buf: RustBuffer) throws -> ClaimXrdEvent {
    return try FfiConverterTypeClaimXrdEvent.lift(buf)
}

public func FfiConverterTypeClaimXrdEvent_lower(_ value: ClaimXrdEvent) -> RustBuffer {
    return FfiConverterTypeClaimXrdEvent.lower(value)
}


public struct ComponentAddresses {
    public var consensusManager: Address
    public var genesisHelper: Address
    public var faucet: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(consensusManager: Address, genesisHelper: Address, faucet: Address) {
        self.consensusManager = consensusManager
        self.genesisHelper = genesisHelper
        self.faucet = faucet
    }
}



public struct FfiConverterTypeComponentAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddresses {
        return try ComponentAddresses(
            consensusManager: FfiConverterTypeAddress.read(from: &buf), 
            genesisHelper: FfiConverterTypeAddress.read(from: &buf), 
            faucet: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ComponentAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.consensusManager, into: &buf)
        FfiConverterTypeAddress.write(value.genesisHelper, into: &buf)
        FfiConverterTypeAddress.write(value.faucet, into: &buf)
    }
}


public func FfiConverterTypeComponentAddresses_lift(_ buf: RustBuffer) throws -> ComponentAddresses {
    return try FfiConverterTypeComponentAddresses.lift(buf)
}

public func FfiConverterTypeComponentAddresses_lower(_ value: ComponentAddresses) -> RustBuffer {
    return FfiConverterTypeComponentAddresses.lower(value)
}


public struct DepositRecoveryXrdEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeDepositRecoveryXrdEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRecoveryXrdEvent {
        return try DepositRecoveryXrdEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: DepositRecoveryXrdEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeDepositRecoveryXrdEvent_lift(_ buf: RustBuffer) throws -> DepositRecoveryXrdEvent {
    return try FfiConverterTypeDepositRecoveryXrdEvent.lift(buf)
}

public func FfiConverterTypeDepositRecoveryXrdEvent_lower(_ value: DepositRecoveryXrdEvent) -> RustBuffer {
    return FfiConverterTypeDepositRecoveryXrdEvent.lower(value)
}


public struct DynamicAnalysis {
    public var accountWithdraws: [String: [ResourceIndicator]]
    public var accountDeposits: [String: [ResourceIndicator]]
    public var presentedProofs: [String: [ResourceSpecifier]]
    public var newEntities: NewEntities
    public var encounteredEntities: [Address]
    public var accountsRequiringAuth: [Address]
    public var identitiesRequiringAuth: [Address]
    public var reservedInstructions: [ReservedInstruction]
    public var feeLocks: FeeLocks
    public var feeSummary: FeeSummary
    public var detailedClassification: [DetailedManifestClass]
    public var newlyCreatedNonFungibles: [NonFungibleGlobalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountWithdraws: [String: [ResourceIndicator]], accountDeposits: [String: [ResourceIndicator]], presentedProofs: [String: [ResourceSpecifier]], newEntities: NewEntities, encounteredEntities: [Address], accountsRequiringAuth: [Address], identitiesRequiringAuth: [Address], reservedInstructions: [ReservedInstruction], feeLocks: FeeLocks, feeSummary: FeeSummary, detailedClassification: [DetailedManifestClass], newlyCreatedNonFungibles: [NonFungibleGlobalId]) {
        self.accountWithdraws = accountWithdraws
        self.accountDeposits = accountDeposits
        self.presentedProofs = presentedProofs
        self.newEntities = newEntities
        self.encounteredEntities = encounteredEntities
        self.accountsRequiringAuth = accountsRequiringAuth
        self.identitiesRequiringAuth = identitiesRequiringAuth
        self.reservedInstructions = reservedInstructions
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
        self.detailedClassification = detailedClassification
        self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
    }
}



public struct FfiConverterTypeDynamicAnalysis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DynamicAnalysis {
        return try DynamicAnalysis(
            accountWithdraws: FfiConverterDictionaryStringSequenceTypeResourceIndicator.read(from: &buf), 
            accountDeposits: FfiConverterDictionaryStringSequenceTypeResourceIndicator.read(from: &buf), 
            presentedProofs: FfiConverterDictionaryStringSequenceTypeResourceSpecifier.read(from: &buf), 
            newEntities: FfiConverterTypeNewEntities.read(from: &buf), 
            encounteredEntities: FfiConverterSequenceTypeAddress.read(from: &buf), 
            accountsRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            identitiesRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf), 
            feeLocks: FfiConverterTypeFeeLocks.read(from: &buf), 
            feeSummary: FfiConverterTypeFeeSummary.read(from: &buf), 
            detailedClassification: FfiConverterSequenceTypeDetailedManifestClass.read(from: &buf), 
            newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf)
        )
    }

    public static func write(_ value: DynamicAnalysis, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringSequenceTypeResourceIndicator.write(value.accountWithdraws, into: &buf)
        FfiConverterDictionaryStringSequenceTypeResourceIndicator.write(value.accountDeposits, into: &buf)
        FfiConverterDictionaryStringSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.encounteredEntities, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.identitiesRequiringAuth, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
        FfiConverterSequenceTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
        FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
    }
}


public func FfiConverterTypeDynamicAnalysis_lift(_ buf: RustBuffer) throws -> DynamicAnalysis {
    return try FfiConverterTypeDynamicAnalysis.lift(buf)
}

public func FfiConverterTypeDynamicAnalysis_lower(_ value: DynamicAnalysis) -> RustBuffer {
    return FfiConverterTypeDynamicAnalysis.lower(value)
}


public struct Ed25519PublicKey {
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Data) {
        self.value = value
    }
}


extension Ed25519PublicKey: Equatable, Hashable {
    public static func ==(lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return try Ed25519PublicKey(
            value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}


public struct EncryptedMessageV1 {
    public var encrypted: Data
    public var decryptorsByCurve: [CurveTypeV1: DecryptorsByCurveV1]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encrypted: Data, decryptorsByCurve: [CurveTypeV1: DecryptorsByCurveV1]) {
        self.encrypted = encrypted
        self.decryptorsByCurve = decryptorsByCurve
    }
}


extension EncryptedMessageV1: Equatable, Hashable {
    public static func ==(lhs: EncryptedMessageV1, rhs: EncryptedMessageV1) -> Bool {
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.decryptorsByCurve != rhs.decryptorsByCurve {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encrypted)
        hasher.combine(decryptorsByCurve)
    }
}


public struct FfiConverterTypeEncryptedMessageV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessageV1 {
        return try EncryptedMessageV1(
            encrypted: FfiConverterData.read(from: &buf), 
            decryptorsByCurve: FfiConverterDictionaryTypeCurveTypeV1TypeDecryptorsByCurveV1.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptedMessageV1, into buf: inout [UInt8]) {
        FfiConverterData.write(value.encrypted, into: &buf)
        FfiConverterDictionaryTypeCurveTypeV1TypeDecryptorsByCurveV1.write(value.decryptorsByCurve, into: &buf)
    }
}


public func FfiConverterTypeEncryptedMessageV1_lift(_ buf: RustBuffer) throws -> EncryptedMessageV1 {
    return try FfiConverterTypeEncryptedMessageV1.lift(buf)
}

public func FfiConverterTypeEncryptedMessageV1_lower(_ value: EncryptedMessageV1) -> RustBuffer {
    return FfiConverterTypeEncryptedMessageV1.lower(value)
}


public struct EncryptedMessageV2 {
    public var encrypted: Data
    public var decryptorsByCurve: [CurveTypeV2: DecryptorsByCurveV2]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encrypted: Data, decryptorsByCurve: [CurveTypeV2: DecryptorsByCurveV2]) {
        self.encrypted = encrypted
        self.decryptorsByCurve = decryptorsByCurve
    }
}


extension EncryptedMessageV2: Equatable, Hashable {
    public static func ==(lhs: EncryptedMessageV2, rhs: EncryptedMessageV2) -> Bool {
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.decryptorsByCurve != rhs.decryptorsByCurve {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encrypted)
        hasher.combine(decryptorsByCurve)
    }
}


public struct FfiConverterTypeEncryptedMessageV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessageV2 {
        return try EncryptedMessageV2(
            encrypted: FfiConverterData.read(from: &buf), 
            decryptorsByCurve: FfiConverterDictionaryTypeCurveTypeV2TypeDecryptorsByCurveV2.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptedMessageV2, into buf: inout [UInt8]) {
        FfiConverterData.write(value.encrypted, into: &buf)
        FfiConverterDictionaryTypeCurveTypeV2TypeDecryptorsByCurveV2.write(value.decryptorsByCurve, into: &buf)
    }
}


public func FfiConverterTypeEncryptedMessageV2_lift(_ buf: RustBuffer) throws -> EncryptedMessageV2 {
    return try FfiConverterTypeEncryptedMessageV2.lift(buf)
}

public func FfiConverterTypeEncryptedMessageV2_lower(_ value: EncryptedMessageV2) -> RustBuffer {
    return FfiConverterTypeEncryptedMessageV2.lower(value)
}


public struct EpochChangeEvent {
    public var epoch: UInt64
    public var validatorSet: [String: ValidatorInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epoch: UInt64, validatorSet: [String: ValidatorInfo]) {
        self.epoch = epoch
        self.validatorSet = validatorSet
    }
}



public struct FfiConverterTypeEpochChangeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EpochChangeEvent {
        return try EpochChangeEvent(
            epoch: FfiConverterUInt64.read(from: &buf), 
            validatorSet: FfiConverterDictionaryStringTypeValidatorInfo.read(from: &buf)
        )
    }

    public static func write(_ value: EpochChangeEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterDictionaryStringTypeValidatorInfo.write(value.validatorSet, into: &buf)
    }
}


public func FfiConverterTypeEpochChangeEvent_lift(_ buf: RustBuffer) throws -> EpochChangeEvent {
    return try FfiConverterTypeEpochChangeEvent.lift(buf)
}

public func FfiConverterTypeEpochChangeEvent_lower(_ value: EpochChangeEvent) -> RustBuffer {
    return FfiConverterTypeEpochChangeEvent.lower(value)
}


public struct EventTypeIdentifier {
    public var emitter: Emitter
    public var eventName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(emitter: Emitter, eventName: String) {
        self.emitter = emitter
        self.eventName = eventName
    }
}



public struct FfiConverterTypeEventTypeIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTypeIdentifier {
        return try EventTypeIdentifier(
            emitter: FfiConverterTypeEmitter.read(from: &buf), 
            eventName: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTypeIdentifier, into buf: inout [UInt8]) {
        FfiConverterTypeEmitter.write(value.emitter, into: &buf)
        FfiConverterString.write(value.eventName, into: &buf)
    }
}


public func FfiConverterTypeEventTypeIdentifier_lift(_ buf: RustBuffer) throws -> EventTypeIdentifier {
    return try FfiConverterTypeEventTypeIdentifier.lift(buf)
}

public func FfiConverterTypeEventTypeIdentifier_lower(_ value: EventTypeIdentifier) -> RustBuffer {
    return FfiConverterTypeEventTypeIdentifier.lower(value)
}


public struct FeeLocks {
    public var lock: Decimal
    public var contingentLock: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal, contingentLock: Decimal) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}



public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return try FeeLocks(
            lock: FfiConverterTypeDecimal.read(from: &buf), 
            contingentLock: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.lock, into: &buf)
        FfiConverterTypeDecimal.write(value.contingentLock, into: &buf)
    }
}


public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}


public struct FeeSummary {
    public var executionCost: Decimal
    public var finalizationCost: Decimal
    public var storageExpansionCost: Decimal
    public var royaltyCost: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(executionCost: Decimal, finalizationCost: Decimal, storageExpansionCost: Decimal, royaltyCost: Decimal) {
        self.executionCost = executionCost
        self.finalizationCost = finalizationCost
        self.storageExpansionCost = storageExpansionCost
        self.royaltyCost = royaltyCost
    }
}



public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return try FeeSummary(
            executionCost: FfiConverterTypeDecimal.read(from: &buf), 
            finalizationCost: FfiConverterTypeDecimal.read(from: &buf), 
            storageExpansionCost: FfiConverterTypeDecimal.read(from: &buf), 
            royaltyCost: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.executionCost, into: &buf)
        FfiConverterTypeDecimal.write(value.finalizationCost, into: &buf)
        FfiConverterTypeDecimal.write(value.storageExpansionCost, into: &buf)
        FfiConverterTypeDecimal.write(value.royaltyCost, into: &buf)
    }
}


public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}


public struct FungibleResourceRoles {
    public var mintRoles: ResourceManagerRole?
    public var burnRoles: ResourceManagerRole?
    public var freezeRoles: ResourceManagerRole?
    public var recallRoles: ResourceManagerRole?
    public var withdrawRoles: ResourceManagerRole?
    public var depositRoles: ResourceManagerRole?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mintRoles: ResourceManagerRole?, burnRoles: ResourceManagerRole?, freezeRoles: ResourceManagerRole?, recallRoles: ResourceManagerRole?, withdrawRoles: ResourceManagerRole?, depositRoles: ResourceManagerRole?) {
        self.mintRoles = mintRoles
        self.burnRoles = burnRoles
        self.freezeRoles = freezeRoles
        self.recallRoles = recallRoles
        self.withdrawRoles = withdrawRoles
        self.depositRoles = depositRoles
    }
}



public struct FfiConverterTypeFungibleResourceRoles: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceRoles {
        return try FungibleResourceRoles(
            mintRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            burnRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            freezeRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            recallRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            withdrawRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            depositRoles: FfiConverterOptionTypeResourceManagerRole.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleResourceRoles, into buf: inout [UInt8]) {
        FfiConverterOptionTypeResourceManagerRole.write(value.mintRoles, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.burnRoles, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.freezeRoles, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.recallRoles, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.withdrawRoles, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.depositRoles, into: &buf)
    }
}


public func FfiConverterTypeFungibleResourceRoles_lift(_ buf: RustBuffer) throws -> FungibleResourceRoles {
    return try FfiConverterTypeFungibleResourceRoles.lift(buf)
}

public func FfiConverterTypeFungibleResourceRoles_lower(_ value: FungibleResourceRoles) -> RustBuffer {
    return FfiConverterTypeFungibleResourceRoles.lower(value)
}


public struct FungibleVaultDepositEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeFungibleVaultDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultDepositEvent {
        return try FungibleVaultDepositEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultDepositEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultDepositEvent {
    return try FfiConverterTypeFungibleVaultDepositEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultDepositEvent_lower(_ value: FungibleVaultDepositEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultDepositEvent.lower(value)
}


public struct FungibleVaultLockFeeEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeFungibleVaultLockFeeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultLockFeeEvent {
        return try FungibleVaultLockFeeEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultLockFeeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultLockFeeEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultLockFeeEvent {
    return try FfiConverterTypeFungibleVaultLockFeeEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultLockFeeEvent_lower(_ value: FungibleVaultLockFeeEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultLockFeeEvent.lower(value)
}


public struct FungibleVaultPayFeeEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeFungibleVaultPayFeeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultPayFeeEvent {
        return try FungibleVaultPayFeeEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultPayFeeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultPayFeeEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultPayFeeEvent {
    return try FfiConverterTypeFungibleVaultPayFeeEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultPayFeeEvent_lower(_ value: FungibleVaultPayFeeEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultPayFeeEvent.lower(value)
}


public struct FungibleVaultRecallEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeFungibleVaultRecallEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultRecallEvent {
        return try FungibleVaultRecallEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultRecallEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultRecallEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultRecallEvent {
    return try FfiConverterTypeFungibleVaultRecallEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultRecallEvent_lower(_ value: FungibleVaultRecallEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultRecallEvent.lower(value)
}


public struct FungibleVaultWithdrawEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeFungibleVaultWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultWithdrawEvent {
        return try FungibleVaultWithdrawEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultWithdrawEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultWithdrawEvent {
    return try FfiConverterTypeFungibleVaultWithdrawEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultWithdrawEvent_lower(_ value: FungibleVaultWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultWithdrawEvent.lower(value)
}


public struct GeneralResourceConstraint {
    public var requiredIds: [NonFungibleLocalId]
    public var lowerBound: LowerBound
    public var upperBound: UpperBound
    public var allowedIds: AllowedIds

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requiredIds: [NonFungibleLocalId], lowerBound: LowerBound, upperBound: UpperBound, allowedIds: AllowedIds) {
        self.requiredIds = requiredIds
        self.lowerBound = lowerBound
        self.upperBound = upperBound
        self.allowedIds = allowedIds
    }
}



public struct FfiConverterTypeGeneralResourceConstraint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneralResourceConstraint {
        return try GeneralResourceConstraint(
            requiredIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
            lowerBound: FfiConverterTypeLowerBound.read(from: &buf), 
            upperBound: FfiConverterTypeUpperBound.read(from: &buf), 
            allowedIds: FfiConverterTypeAllowedIds.read(from: &buf)
        )
    }

    public static func write(_ value: GeneralResourceConstraint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.requiredIds, into: &buf)
        FfiConverterTypeLowerBound.write(value.lowerBound, into: &buf)
        FfiConverterTypeUpperBound.write(value.upperBound, into: &buf)
        FfiConverterTypeAllowedIds.write(value.allowedIds, into: &buf)
    }
}


public func FfiConverterTypeGeneralResourceConstraint_lift(_ buf: RustBuffer) throws -> GeneralResourceConstraint {
    return try FfiConverterTypeGeneralResourceConstraint.lift(buf)
}

public func FfiConverterTypeGeneralResourceConstraint_lower(_ value: GeneralResourceConstraint) -> RustBuffer {
    return FfiConverterTypeGeneralResourceConstraint.lower(value)
}


public struct InitiateBadgeWithdrawAttemptEvent {
    public var proposer: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer) {
        self.proposer = proposer
    }
}


extension InitiateBadgeWithdrawAttemptEvent: Equatable, Hashable {
    public static func ==(lhs: InitiateBadgeWithdrawAttemptEvent, rhs: InitiateBadgeWithdrawAttemptEvent) -> Bool {
        if lhs.proposer != rhs.proposer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proposer)
    }
}


public struct FfiConverterTypeInitiateBadgeWithdrawAttemptEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitiateBadgeWithdrawAttemptEvent {
        return try InitiateBadgeWithdrawAttemptEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: InitiateBadgeWithdrawAttemptEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
    }
}


public func FfiConverterTypeInitiateBadgeWithdrawAttemptEvent_lift(_ buf: RustBuffer) throws -> InitiateBadgeWithdrawAttemptEvent {
    return try FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.lift(buf)
}

public func FfiConverterTypeInitiateBadgeWithdrawAttemptEvent_lower(_ value: InitiateBadgeWithdrawAttemptEvent) -> RustBuffer {
    return FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.lower(value)
}


public struct InitiateRecoveryEvent {
    public var proposer: Proposer
    public var proposal: RecoveryProposal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer, proposal: RecoveryProposal) {
        self.proposer = proposer
        self.proposal = proposal
    }
}



public struct FfiConverterTypeInitiateRecoveryEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitiateRecoveryEvent {
        return try InitiateRecoveryEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf), 
            proposal: FfiConverterTypeRecoveryProposal.read(from: &buf)
        )
    }

    public static func write(_ value: InitiateRecoveryEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
        FfiConverterTypeRecoveryProposal.write(value.proposal, into: &buf)
    }
}


public func FfiConverterTypeInitiateRecoveryEvent_lift(_ buf: RustBuffer) throws -> InitiateRecoveryEvent {
    return try FfiConverterTypeInitiateRecoveryEvent.lift(buf)
}

public func FfiConverterTypeInitiateRecoveryEvent_lower(_ value: InitiateRecoveryEvent) -> RustBuffer {
    return FfiConverterTypeInitiateRecoveryEvent.lower(value)
}


public struct IntentHeaderV2 {
    public var networkId: UInt8
    public var startEpochInclusive: UInt64
    public var endEpochExclusive: UInt64
    public var minProposerTimestampInclusive: Int64?
    public var maxProposerTimestampExclusive: Int64?
    public var intentDiscriminator: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: UInt8, startEpochInclusive: UInt64, endEpochExclusive: UInt64, minProposerTimestampInclusive: Int64?, maxProposerTimestampExclusive: Int64?, intentDiscriminator: UInt64) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.minProposerTimestampInclusive = minProposerTimestampInclusive
        self.maxProposerTimestampExclusive = maxProposerTimestampExclusive
        self.intentDiscriminator = intentDiscriminator
    }
}


extension IntentHeaderV2: Equatable, Hashable {
    public static func ==(lhs: IntentHeaderV2, rhs: IntentHeaderV2) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.minProposerTimestampInclusive != rhs.minProposerTimestampInclusive {
            return false
        }
        if lhs.maxProposerTimestampExclusive != rhs.maxProposerTimestampExclusive {
            return false
        }
        if lhs.intentDiscriminator != rhs.intentDiscriminator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(minProposerTimestampInclusive)
        hasher.combine(maxProposerTimestampExclusive)
        hasher.combine(intentDiscriminator)
    }
}


public struct FfiConverterTypeIntentHeaderV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHeaderV2 {
        return try IntentHeaderV2(
            networkId: FfiConverterUInt8.read(from: &buf), 
            startEpochInclusive: FfiConverterUInt64.read(from: &buf), 
            endEpochExclusive: FfiConverterUInt64.read(from: &buf), 
            minProposerTimestampInclusive: FfiConverterOptionInt64.read(from: &buf), 
            maxProposerTimestampExclusive: FfiConverterOptionInt64.read(from: &buf), 
            intentDiscriminator: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: IntentHeaderV2, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.networkId, into: &buf)
        FfiConverterUInt64.write(value.startEpochInclusive, into: &buf)
        FfiConverterUInt64.write(value.endEpochExclusive, into: &buf)
        FfiConverterOptionInt64.write(value.minProposerTimestampInclusive, into: &buf)
        FfiConverterOptionInt64.write(value.maxProposerTimestampExclusive, into: &buf)
        FfiConverterUInt64.write(value.intentDiscriminator, into: &buf)
    }
}


public func FfiConverterTypeIntentHeaderV2_lift(_ buf: RustBuffer) throws -> IntentHeaderV2 {
    return try FfiConverterTypeIntentHeaderV2.lift(buf)
}

public func FfiConverterTypeIntentHeaderV2_lower(_ value: IntentHeaderV2) -> RustBuffer {
    return FfiConverterTypeIntentHeaderV2.lower(value)
}


public struct KnownAddresses {
    public var resourceAddresses: ResourceAddresses
    public var packageAddresses: PackageAddresses
    public var componentAddresses: ComponentAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddresses: ResourceAddresses, packageAddresses: PackageAddresses, componentAddresses: ComponentAddresses) {
        self.resourceAddresses = resourceAddresses
        self.packageAddresses = packageAddresses
        self.componentAddresses = componentAddresses
    }
}



public struct FfiConverterTypeKnownAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnownAddresses {
        return try KnownAddresses(
            resourceAddresses: FfiConverterTypeResourceAddresses.read(from: &buf), 
            packageAddresses: FfiConverterTypePackageAddresses.read(from: &buf), 
            componentAddresses: FfiConverterTypeComponentAddresses.read(from: &buf)
        )
    }

    public static func write(_ value: KnownAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddresses.write(value.resourceAddresses, into: &buf)
        FfiConverterTypePackageAddresses.write(value.packageAddresses, into: &buf)
        FfiConverterTypeComponentAddresses.write(value.componentAddresses, into: &buf)
    }
}


public func FfiConverterTypeKnownAddresses_lift(_ buf: RustBuffer) throws -> KnownAddresses {
    return try FfiConverterTypeKnownAddresses.lift(buf)
}

public func FfiConverterTypeKnownAddresses_lower(_ value: KnownAddresses) -> RustBuffer {
    return FfiConverterTypeKnownAddresses.lower(value)
}


public struct LockOwnerRoleEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension LockOwnerRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockOwnerRoleEvent, rhs: LockOwnerRoleEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeLockOwnerRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockOwnerRoleEvent {
        return try LockOwnerRoleEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LockOwnerRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeLockOwnerRoleEvent_lift(_ buf: RustBuffer) throws -> LockOwnerRoleEvent {
    return try FfiConverterTypeLockOwnerRoleEvent.lift(buf)
}

public func FfiConverterTypeLockOwnerRoleEvent_lower(_ value: LockOwnerRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockOwnerRoleEvent.lower(value)
}


public struct LockPrimaryRoleEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension LockPrimaryRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockPrimaryRoleEvent, rhs: LockPrimaryRoleEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeLockPrimaryRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockPrimaryRoleEvent {
        return try LockPrimaryRoleEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LockPrimaryRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeLockPrimaryRoleEvent_lift(_ buf: RustBuffer) throws -> LockPrimaryRoleEvent {
    return try FfiConverterTypeLockPrimaryRoleEvent.lift(buf)
}

public func FfiConverterTypeLockPrimaryRoleEvent_lower(_ value: LockPrimaryRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockPrimaryRoleEvent.lower(value)
}


public struct LockRoleEvent {
    public var roleKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roleKey: String) {
        self.roleKey = roleKey
    }
}


extension LockRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockRoleEvent, rhs: LockRoleEvent) -> Bool {
        if lhs.roleKey != rhs.roleKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roleKey)
    }
}


public struct FfiConverterTypeLockRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockRoleEvent {
        return try LockRoleEvent(
            roleKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LockRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roleKey, into: &buf)
    }
}


public func FfiConverterTypeLockRoleEvent_lift(_ buf: RustBuffer) throws -> LockRoleEvent {
    return try FfiConverterTypeLockRoleEvent.lift(buf)
}

public func FfiConverterTypeLockRoleEvent_lower(_ value: LockRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockRoleEvent.lower(value)
}


public struct ManifestAddressReservation {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}


extension ManifestAddressReservation: Equatable, Hashable {
    public static func ==(lhs: ManifestAddressReservation, rhs: ManifestAddressReservation) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeManifestAddressReservation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddressReservation {
        return try ManifestAddressReservation(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestAddressReservation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeManifestAddressReservation_lift(_ buf: RustBuffer) throws -> ManifestAddressReservation {
    return try FfiConverterTypeManifestAddressReservation.lift(buf)
}

public func FfiConverterTypeManifestAddressReservation_lower(_ value: ManifestAddressReservation) -> RustBuffer {
    return FfiConverterTypeManifestAddressReservation.lower(value)
}


public struct ManifestBlobRef {
    public var value: Hash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Hash) {
        self.value = value
    }
}



public struct FfiConverterTypeManifestBlobRef: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBlobRef {
        return try ManifestBlobRef(
            value: FfiConverterTypeHash.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBlobRef, into buf: inout [UInt8]) {
        FfiConverterTypeHash.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeManifestBlobRef_lift(_ buf: RustBuffer) throws -> ManifestBlobRef {
    return try FfiConverterTypeManifestBlobRef.lift(buf)
}

public func FfiConverterTypeManifestBlobRef_lower(_ value: ManifestBlobRef) -> RustBuffer {
    return FfiConverterTypeManifestBlobRef.lower(value)
}


public struct ManifestBucket {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}


extension ManifestBucket: Equatable, Hashable {
    public static func ==(lhs: ManifestBucket, rhs: ManifestBucket) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeManifestBucket: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBucket {
        return try ManifestBucket(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBucket, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeManifestBucket_lift(_ buf: RustBuffer) throws -> ManifestBucket {
    return try FfiConverterTypeManifestBucket.lift(buf)
}

public func FfiConverterTypeManifestBucket_lower(_ value: ManifestBucket) -> RustBuffer {
    return FfiConverterTypeManifestBucket.lower(value)
}


public struct ManifestBuilderAddressReservation {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}


extension ManifestBuilderAddressReservation: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderAddressReservation, rhs: ManifestBuilderAddressReservation) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeManifestBuilderAddressReservation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderAddressReservation {
        return try ManifestBuilderAddressReservation(
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderAddressReservation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderAddressReservation_lift(_ buf: RustBuffer) throws -> ManifestBuilderAddressReservation {
    return try FfiConverterTypeManifestBuilderAddressReservation.lift(buf)
}

public func FfiConverterTypeManifestBuilderAddressReservation_lower(_ value: ManifestBuilderAddressReservation) -> RustBuffer {
    return FfiConverterTypeManifestBuilderAddressReservation.lower(value)
}


public struct ManifestBuilderBucket {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}


extension ManifestBuilderBucket: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderBucket, rhs: ManifestBuilderBucket) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeManifestBuilderBucket: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderBucket {
        return try ManifestBuilderBucket(
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderBucket, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderBucket_lift(_ buf: RustBuffer) throws -> ManifestBuilderBucket {
    return try FfiConverterTypeManifestBuilderBucket.lift(buf)
}

public func FfiConverterTypeManifestBuilderBucket_lower(_ value: ManifestBuilderBucket) -> RustBuffer {
    return FfiConverterTypeManifestBuilderBucket.lower(value)
}


public struct ManifestBuilderIntent {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}


extension ManifestBuilderIntent: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderIntent, rhs: ManifestBuilderIntent) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeManifestBuilderIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderIntent {
        return try ManifestBuilderIntent(
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderIntent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderIntent_lift(_ buf: RustBuffer) throws -> ManifestBuilderIntent {
    return try FfiConverterTypeManifestBuilderIntent.lift(buf)
}

public func FfiConverterTypeManifestBuilderIntent_lower(_ value: ManifestBuilderIntent) -> RustBuffer {
    return FfiConverterTypeManifestBuilderIntent.lower(value)
}


public struct ManifestBuilderMapEntry {
    public var key: ManifestBuilderValue
    public var value: ManifestBuilderValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: ManifestBuilderValue, value: ManifestBuilderValue) {
        self.key = key
        self.value = value
    }
}



public struct FfiConverterTypeManifestBuilderMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderMapEntry {
        return try ManifestBuilderMapEntry(
            key: FfiConverterTypeManifestBuilderValue.read(from: &buf), 
            value: FfiConverterTypeManifestBuilderValue.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderMapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeManifestBuilderValue.write(value.key, into: &buf)
        FfiConverterTypeManifestBuilderValue.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderMapEntry_lift(_ buf: RustBuffer) throws -> ManifestBuilderMapEntry {
    return try FfiConverterTypeManifestBuilderMapEntry.lift(buf)
}

public func FfiConverterTypeManifestBuilderMapEntry_lower(_ value: ManifestBuilderMapEntry) -> RustBuffer {
    return FfiConverterTypeManifestBuilderMapEntry.lower(value)
}


public struct ManifestBuilderNamedAddress {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}


extension ManifestBuilderNamedAddress: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderNamedAddress, rhs: ManifestBuilderNamedAddress) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeManifestBuilderNamedAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderNamedAddress {
        return try ManifestBuilderNamedAddress(
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderNamedAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderNamedAddress_lift(_ buf: RustBuffer) throws -> ManifestBuilderNamedAddress {
    return try FfiConverterTypeManifestBuilderNamedAddress.lift(buf)
}

public func FfiConverterTypeManifestBuilderNamedAddress_lower(_ value: ManifestBuilderNamedAddress) -> RustBuffer {
    return FfiConverterTypeManifestBuilderNamedAddress.lower(value)
}


public struct ManifestBuilderProof {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}


extension ManifestBuilderProof: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderProof, rhs: ManifestBuilderProof) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeManifestBuilderProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderProof {
        return try ManifestBuilderProof(
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderProof, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderProof_lift(_ buf: RustBuffer) throws -> ManifestBuilderProof {
    return try FfiConverterTypeManifestBuilderProof.lift(buf)
}

public func FfiConverterTypeManifestBuilderProof_lower(_ value: ManifestBuilderProof) -> RustBuffer {
    return FfiConverterTypeManifestBuilderProof.lower(value)
}


public struct ManifestProof {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}


extension ManifestProof: Equatable, Hashable {
    public static func ==(lhs: ManifestProof, rhs: ManifestProof) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeManifestProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestProof {
        return try ManifestProof(
            value: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestProof, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeManifestProof_lift(_ buf: RustBuffer) throws -> ManifestProof {
    return try FfiConverterTypeManifestProof.lift(buf)
}

public func FfiConverterTypeManifestProof_lower(_ value: ManifestProof) -> RustBuffer {
    return FfiConverterTypeManifestProof.lower(value)
}


public struct MapEntry {
    public var key: ManifestValue
    public var value: ManifestValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: ManifestValue, value: ManifestValue) {
        self.key = key
        self.value = value
    }
}



public struct FfiConverterTypeMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MapEntry {
        return try MapEntry(
            key: FfiConverterTypeManifestValue.read(from: &buf), 
            value: FfiConverterTypeManifestValue.read(from: &buf)
        )
    }

    public static func write(_ value: MapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeManifestValue.write(value.key, into: &buf)
        FfiConverterTypeManifestValue.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeMapEntry_lift(_ buf: RustBuffer) throws -> MapEntry {
    return try FfiConverterTypeMapEntry.lift(buf)
}

public func FfiConverterTypeMapEntry_lower(_ value: MapEntry) -> RustBuffer {
    return FfiConverterTypeMapEntry.lower(value)
}


public struct MetadataInitEntry {
    public var value: MetadataValue?
    public var lock: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: MetadataValue?, lock: Bool) {
        self.value = value
        self.lock = lock
    }
}



public struct FfiConverterTypeMetadataInitEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataInitEntry {
        return try MetadataInitEntry(
            value: FfiConverterOptionTypeMetadataValue.read(from: &buf), 
            lock: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataInitEntry, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMetadataValue.write(value.value, into: &buf)
        FfiConverterBool.write(value.lock, into: &buf)
    }
}


public func FfiConverterTypeMetadataInitEntry_lift(_ buf: RustBuffer) throws -> MetadataInitEntry {
    return try FfiConverterTypeMetadataInitEntry.lift(buf)
}

public func FfiConverterTypeMetadataInitEntry_lower(_ value: MetadataInitEntry) -> RustBuffer {
    return FfiConverterTypeMetadataInitEntry.lower(value)
}


public struct MetadataModuleConfig {
    public var `init`: [String: MetadataInitEntry]
    public var roles: [String: AccessRule?]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`init`: [String: MetadataInitEntry], roles: [String: AccessRule?]) {
        self.`init` = `init`
        self.roles = roles
    }
}



public struct FfiConverterTypeMetadataModuleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataModuleConfig {
        return try MetadataModuleConfig(
            init: FfiConverterDictionaryStringTypeMetadataInitEntry.read(from: &buf), 
            roles: FfiConverterDictionaryStringOptionTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataModuleConfig, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeMetadataInitEntry.write(value.`init`, into: &buf)
        FfiConverterDictionaryStringOptionTypeAccessRule.write(value.roles, into: &buf)
    }
}


public func FfiConverterTypeMetadataModuleConfig_lift(_ buf: RustBuffer) throws -> MetadataModuleConfig {
    return try FfiConverterTypeMetadataModuleConfig.lift(buf)
}

public func FfiConverterTypeMetadataModuleConfig_lower(_ value: MetadataModuleConfig) -> RustBuffer {
    return FfiConverterTypeMetadataModuleConfig.lower(value)
}


public struct MintFungibleResourceEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeMintFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintFungibleResourceEvent {
        return try MintFungibleResourceEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MintFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeMintFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> MintFungibleResourceEvent {
    return try FfiConverterTypeMintFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeMintFungibleResourceEvent_lower(_ value: MintFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeMintFungibleResourceEvent.lower(value)
}


public struct MintNonFungibleResourceEvent {
    public var ids: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [NonFungibleLocalId]) {
        self.ids = ids
    }
}


extension MintNonFungibleResourceEvent: Equatable, Hashable {
    public static func ==(lhs: MintNonFungibleResourceEvent, rhs: MintNonFungibleResourceEvent) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
    }
}


public struct FfiConverterTypeMintNonFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintNonFungibleResourceEvent {
        return try MintNonFungibleResourceEvent(
            ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: MintNonFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
    }
}


public func FfiConverterTypeMintNonFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> MintNonFungibleResourceEvent {
    return try FfiConverterTypeMintNonFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeMintNonFungibleResourceEvent_lower(_ value: MintNonFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeMintNonFungibleResourceEvent.lower(value)
}


public struct MultiResourcePoolContributionEvent {
    public var contributedResources: [String: Decimal]
    public var poolUnitsMinted: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contributedResources: [String: Decimal], poolUnitsMinted: Decimal) {
        self.contributedResources = contributedResources
        self.poolUnitsMinted = poolUnitsMinted
    }
}



public struct FfiConverterTypeMultiResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolContributionEvent {
        return try MultiResourcePoolContributionEvent(
            contributedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf), 
            poolUnitsMinted: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeDecimal.write(value.contributedResources, into: &buf)
        FfiConverterTypeDecimal.write(value.poolUnitsMinted, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolContributionEvent {
    return try FfiConverterTypeMultiResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolContributionEvent_lower(_ value: MultiResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolContributionEvent.lower(value)
}


public struct MultiResourcePoolDepositEvent {
    public var resourceAddress: Address
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address, amount: Decimal) {
        self.resourceAddress = resourceAddress
        self.amount = amount
    }
}



public struct FfiConverterTypeMultiResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolDepositEvent {
        return try MultiResourcePoolDepositEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolDepositEvent {
    return try FfiConverterTypeMultiResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolDepositEvent_lower(_ value: MultiResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolDepositEvent.lower(value)
}


public struct MultiResourcePoolRedemptionEvent {
    public var poolUnitTokensRedeemed: Decimal
    public var redeemedResources: [String: Decimal]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolUnitTokensRedeemed: Decimal, redeemedResources: [String: Decimal]) {
        self.poolUnitTokensRedeemed = poolUnitTokensRedeemed
        self.redeemedResources = redeemedResources
    }
}



public struct FfiConverterTypeMultiResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolRedemptionEvent {
        return try MultiResourcePoolRedemptionEvent(
            poolUnitTokensRedeemed: FfiConverterTypeDecimal.read(from: &buf), 
            redeemedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.poolUnitTokensRedeemed, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.redeemedResources, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolRedemptionEvent {
    return try FfiConverterTypeMultiResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolRedemptionEvent_lower(_ value: MultiResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolRedemptionEvent.lower(value)
}


public struct MultiResourcePoolWithdrawEvent {
    public var resourceAddress: Address
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address, amount: Decimal) {
        self.resourceAddress = resourceAddress
        self.amount = amount
    }
}



public struct FfiConverterTypeMultiResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolWithdrawEvent {
        return try MultiResourcePoolWithdrawEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolWithdrawEvent {
    return try FfiConverterTypeMultiResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolWithdrawEvent_lower(_ value: MultiResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolWithdrawEvent.lower(value)
}


public struct NewEntities {
    public var componentAddresses: [Address]
    public var resourceAddresses: [Address]
    public var packageAddresses: [Address]
    public var metadata: [String: [String: MetadataValue?]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(componentAddresses: [Address], resourceAddresses: [Address], packageAddresses: [Address], metadata: [String: [String: MetadataValue?]]) {
        self.componentAddresses = componentAddresses
        self.resourceAddresses = resourceAddresses
        self.packageAddresses = packageAddresses
        self.metadata = metadata
    }
}



public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
        return try NewEntities(
            componentAddresses: FfiConverterSequenceTypeAddress.read(from: &buf), 
            resourceAddresses: FfiConverterSequenceTypeAddress.read(from: &buf), 
            packageAddresses: FfiConverterSequenceTypeAddress.read(from: &buf), 
            metadata: FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue.read(from: &buf)
        )
    }

    public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAddress.write(value.componentAddresses, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.resourceAddresses, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.packageAddresses, into: &buf)
        FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue.write(value.metadata, into: &buf)
    }
}


public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
    return try FfiConverterTypeNewEntities.lift(buf)
}

public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
    return FfiConverterTypeNewEntities.lower(value)
}


public struct NonFungibleVaultDepositEvent {
    public var ids: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [NonFungibleLocalId]) {
        self.ids = ids
    }
}


extension NonFungibleVaultDepositEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultDepositEvent, rhs: NonFungibleVaultDepositEvent) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
    }
}


public struct FfiConverterTypeNonFungibleVaultDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultDepositEvent {
        return try NonFungibleVaultDepositEvent(
            ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultDepositEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultDepositEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultDepositEvent {
    return try FfiConverterTypeNonFungibleVaultDepositEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultDepositEvent_lower(_ value: NonFungibleVaultDepositEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultDepositEvent.lower(value)
}


public struct NonFungibleVaultRecallEvent {
    public var ids: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [NonFungibleLocalId]) {
        self.ids = ids
    }
}


extension NonFungibleVaultRecallEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultRecallEvent, rhs: NonFungibleVaultRecallEvent) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
    }
}


public struct FfiConverterTypeNonFungibleVaultRecallEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultRecallEvent {
        return try NonFungibleVaultRecallEvent(
            ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultRecallEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultRecallEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultRecallEvent {
    return try FfiConverterTypeNonFungibleVaultRecallEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultRecallEvent_lower(_ value: NonFungibleVaultRecallEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultRecallEvent.lower(value)
}


public struct NonFungibleVaultWithdrawEvent {
    public var ids: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [NonFungibleLocalId]) {
        self.ids = ids
    }
}


extension NonFungibleVaultWithdrawEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultWithdrawEvent, rhs: NonFungibleVaultWithdrawEvent) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
    }
}


public struct FfiConverterTypeNonFungibleVaultWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultWithdrawEvent {
        return try NonFungibleVaultWithdrawEvent(
            ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultWithdrawEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultWithdrawEvent {
    return try FfiConverterTypeNonFungibleVaultWithdrawEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultWithdrawEvent_lower(_ value: NonFungibleVaultWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultWithdrawEvent.lower(value)
}


public struct OneResourcePoolContributionEvent {
    public var amountOfResourcesContributed: Decimal
    public var poolUnitsMinted: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountOfResourcesContributed: Decimal, poolUnitsMinted: Decimal) {
        self.amountOfResourcesContributed = amountOfResourcesContributed
        self.poolUnitsMinted = poolUnitsMinted
    }
}



public struct FfiConverterTypeOneResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolContributionEvent {
        return try OneResourcePoolContributionEvent(
            amountOfResourcesContributed: FfiConverterTypeDecimal.read(from: &buf), 
            poolUnitsMinted: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amountOfResourcesContributed, into: &buf)
        FfiConverterTypeDecimal.write(value.poolUnitsMinted, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolContributionEvent {
    return try FfiConverterTypeOneResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolContributionEvent_lower(_ value: OneResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolContributionEvent.lower(value)
}


public struct OneResourcePoolDepositEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeOneResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolDepositEvent {
        return try OneResourcePoolDepositEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolDepositEvent {
    return try FfiConverterTypeOneResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolDepositEvent_lower(_ value: OneResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolDepositEvent.lower(value)
}


public struct OneResourcePoolRedemptionEvent {
    public var poolUnitTokensRedeemed: Decimal
    public var redeemedAmount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolUnitTokensRedeemed: Decimal, redeemedAmount: Decimal) {
        self.poolUnitTokensRedeemed = poolUnitTokensRedeemed
        self.redeemedAmount = redeemedAmount
    }
}



public struct FfiConverterTypeOneResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolRedemptionEvent {
        return try OneResourcePoolRedemptionEvent(
            poolUnitTokensRedeemed: FfiConverterTypeDecimal.read(from: &buf), 
            redeemedAmount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.poolUnitTokensRedeemed, into: &buf)
        FfiConverterTypeDecimal.write(value.redeemedAmount, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolRedemptionEvent {
    return try FfiConverterTypeOneResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolRedemptionEvent_lower(_ value: OneResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolRedemptionEvent.lower(value)
}


public struct OneResourcePoolWithdrawEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeOneResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolWithdrawEvent {
        return try OneResourcePoolWithdrawEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolWithdrawEvent {
    return try FfiConverterTypeOneResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolWithdrawEvent_lower(_ value: OneResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolWithdrawEvent.lower(value)
}


public struct PackageAddresses {
    public var packagePackage: Address
    public var resourcePackage: Address
    public var accountPackage: Address
    public var identityPackage: Address
    public var consensusManagerPackage: Address
    public var accessControllerPackage: Address
    public var poolPackage: Address
    public var transactionProcessorPackage: Address
    public var metadataModulePackage: Address
    public var royaltyModulePackage: Address
    public var roleAssignmentModulePackage: Address
    public var genesisHelperPackage: Address
    public var faucetPackage: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(packagePackage: Address, resourcePackage: Address, accountPackage: Address, identityPackage: Address, consensusManagerPackage: Address, accessControllerPackage: Address, poolPackage: Address, transactionProcessorPackage: Address, metadataModulePackage: Address, royaltyModulePackage: Address, roleAssignmentModulePackage: Address, genesisHelperPackage: Address, faucetPackage: Address) {
        self.packagePackage = packagePackage
        self.resourcePackage = resourcePackage
        self.accountPackage = accountPackage
        self.identityPackage = identityPackage
        self.consensusManagerPackage = consensusManagerPackage
        self.accessControllerPackage = accessControllerPackage
        self.poolPackage = poolPackage
        self.transactionProcessorPackage = transactionProcessorPackage
        self.metadataModulePackage = metadataModulePackage
        self.royaltyModulePackage = royaltyModulePackage
        self.roleAssignmentModulePackage = roleAssignmentModulePackage
        self.genesisHelperPackage = genesisHelperPackage
        self.faucetPackage = faucetPackage
    }
}



public struct FfiConverterTypePackageAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddresses {
        return try PackageAddresses(
            packagePackage: FfiConverterTypeAddress.read(from: &buf), 
            resourcePackage: FfiConverterTypeAddress.read(from: &buf), 
            accountPackage: FfiConverterTypeAddress.read(from: &buf), 
            identityPackage: FfiConverterTypeAddress.read(from: &buf), 
            consensusManagerPackage: FfiConverterTypeAddress.read(from: &buf), 
            accessControllerPackage: FfiConverterTypeAddress.read(from: &buf), 
            poolPackage: FfiConverterTypeAddress.read(from: &buf), 
            transactionProcessorPackage: FfiConverterTypeAddress.read(from: &buf), 
            metadataModulePackage: FfiConverterTypeAddress.read(from: &buf), 
            royaltyModulePackage: FfiConverterTypeAddress.read(from: &buf), 
            roleAssignmentModulePackage: FfiConverterTypeAddress.read(from: &buf), 
            genesisHelperPackage: FfiConverterTypeAddress.read(from: &buf), 
            faucetPackage: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PackageAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.packagePackage, into: &buf)
        FfiConverterTypeAddress.write(value.resourcePackage, into: &buf)
        FfiConverterTypeAddress.write(value.accountPackage, into: &buf)
        FfiConverterTypeAddress.write(value.identityPackage, into: &buf)
        FfiConverterTypeAddress.write(value.consensusManagerPackage, into: &buf)
        FfiConverterTypeAddress.write(value.accessControllerPackage, into: &buf)
        FfiConverterTypeAddress.write(value.poolPackage, into: &buf)
        FfiConverterTypeAddress.write(value.transactionProcessorPackage, into: &buf)
        FfiConverterTypeAddress.write(value.metadataModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.royaltyModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.roleAssignmentModulePackage, into: &buf)
        FfiConverterTypeAddress.write(value.genesisHelperPackage, into: &buf)
        FfiConverterTypeAddress.write(value.faucetPackage, into: &buf)
    }
}


public func FfiConverterTypePackageAddresses_lift(_ buf: RustBuffer) throws -> PackageAddresses {
    return try FfiConverterTypePackageAddresses.lift(buf)
}

public func FfiConverterTypePackageAddresses_lower(_ value: PackageAddresses) -> RustBuffer {
    return FfiConverterTypePackageAddresses.lower(value)
}


public struct PlainTextMessageV1 {
    public var mimeType: String
    public var message: MessageContentV1

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContentV1) {
        self.mimeType = mimeType
        self.message = message
    }
}


extension PlainTextMessageV1: Equatable, Hashable {
    public static func ==(lhs: PlainTextMessageV1, rhs: PlainTextMessageV1) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}


public struct FfiConverterTypePlainTextMessageV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlainTextMessageV1 {
        return try PlainTextMessageV1(
            mimeType: FfiConverterString.read(from: &buf), 
            message: FfiConverterTypeMessageContentV1.read(from: &buf)
        )
    }

    public static func write(_ value: PlainTextMessageV1, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContentV1.write(value.message, into: &buf)
    }
}


public func FfiConverterTypePlainTextMessageV1_lift(_ buf: RustBuffer) throws -> PlainTextMessageV1 {
    return try FfiConverterTypePlainTextMessageV1.lift(buf)
}

public func FfiConverterTypePlainTextMessageV1_lower(_ value: PlainTextMessageV1) -> RustBuffer {
    return FfiConverterTypePlainTextMessageV1.lower(value)
}


public struct PlainTextMessageV2 {
    public var mimeType: String
    public var message: MessageContentsV2

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContentsV2) {
        self.mimeType = mimeType
        self.message = message
    }
}


extension PlainTextMessageV2: Equatable, Hashable {
    public static func ==(lhs: PlainTextMessageV2, rhs: PlainTextMessageV2) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}


public struct FfiConverterTypePlainTextMessageV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlainTextMessageV2 {
        return try PlainTextMessageV2(
            mimeType: FfiConverterString.read(from: &buf), 
            message: FfiConverterTypeMessageContentsV2.read(from: &buf)
        )
    }

    public static func write(_ value: PlainTextMessageV2, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContentsV2.write(value.message, into: &buf)
    }
}


public func FfiConverterTypePlainTextMessageV2_lift(_ buf: RustBuffer) throws -> PlainTextMessageV2 {
    return try FfiConverterTypePlainTextMessageV2.lift(buf)
}

public func FfiConverterTypePlainTextMessageV2_lower(_ value: PlainTextMessageV2) -> RustBuffer {
    return FfiConverterTypePlainTextMessageV2.lower(value)
}


public struct PredictedDecimal {
    public var value: Decimal
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Decimal, instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}



public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
        return try PredictedDecimal(
            value: FfiConverterTypeDecimal.read(from: &buf), 
            instructionIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}


public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
    return try FfiConverterTypePredictedDecimal.lift(buf)
}

public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
    return FfiConverterTypePredictedDecimal.lower(value)
}


public struct PredictedNonFungibleIds {
    public var value: [NonFungibleLocalId]
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}


extension PredictedNonFungibleIds: Equatable, Hashable {
    public static func ==(lhs: PredictedNonFungibleIds, rhs: PredictedNonFungibleIds) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}


public struct FfiConverterTypePredictedNonFungibleIds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleIds {
        return try PredictedNonFungibleIds(
            value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
            instructionIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PredictedNonFungibleIds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}


public func FfiConverterTypePredictedNonFungibleIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleIds {
    return try FfiConverterTypePredictedNonFungibleIds.lift(buf)
}

public func FfiConverterTypePredictedNonFungibleIds_lower(_ value: PredictedNonFungibleIds) -> RustBuffer {
    return FfiConverterTypePredictedNonFungibleIds.lower(value)
}


public struct ProtocolUpdateReadinessSignalEvent {
    public var protocolVersionName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(protocolVersionName: String) {
        self.protocolVersionName = protocolVersionName
    }
}


extension ProtocolUpdateReadinessSignalEvent: Equatable, Hashable {
    public static func ==(lhs: ProtocolUpdateReadinessSignalEvent, rhs: ProtocolUpdateReadinessSignalEvent) -> Bool {
        if lhs.protocolVersionName != rhs.protocolVersionName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(protocolVersionName)
    }
}


public struct FfiConverterTypeProtocolUpdateReadinessSignalEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtocolUpdateReadinessSignalEvent {
        return try ProtocolUpdateReadinessSignalEvent(
            protocolVersionName: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ProtocolUpdateReadinessSignalEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.protocolVersionName, into: &buf)
    }
}


public func FfiConverterTypeProtocolUpdateReadinessSignalEvent_lift(_ buf: RustBuffer) throws -> ProtocolUpdateReadinessSignalEvent {
    return try FfiConverterTypeProtocolUpdateReadinessSignalEvent.lift(buf)
}

public func FfiConverterTypeProtocolUpdateReadinessSignalEvent_lower(_ value: ProtocolUpdateReadinessSignalEvent) -> RustBuffer {
    return FfiConverterTypeProtocolUpdateReadinessSignalEvent.lower(value)
}


public struct PublicKeyFingerprint {
    public var bytes: HashableBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: HashableBytes) {
        self.bytes = bytes
    }
}


extension PublicKeyFingerprint: Equatable, Hashable {
    public static func ==(lhs: PublicKeyFingerprint, rhs: PublicKeyFingerprint) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


public struct FfiConverterTypePublicKeyFingerprint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyFingerprint {
        return try PublicKeyFingerprint(
            bytes: FfiConverterTypeHashableBytes.read(from: &buf)
        )
    }

    public static func write(_ value: PublicKeyFingerprint, into buf: inout [UInt8]) {
        FfiConverterTypeHashableBytes.write(value.bytes, into: &buf)
    }
}


public func FfiConverterTypePublicKeyFingerprint_lift(_ buf: RustBuffer) throws -> PublicKeyFingerprint {
    return try FfiConverterTypePublicKeyFingerprint.lift(buf)
}

public func FfiConverterTypePublicKeyFingerprint_lower(_ value: PublicKeyFingerprint) -> RustBuffer {
    return FfiConverterTypePublicKeyFingerprint.lower(value)
}


public struct PublicKeyFingerprintV1 {
    public var bytes: HashableBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: HashableBytes) {
        self.bytes = bytes
    }
}


extension PublicKeyFingerprintV1: Equatable, Hashable {
    public static func ==(lhs: PublicKeyFingerprintV1, rhs: PublicKeyFingerprintV1) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


public struct FfiConverterTypePublicKeyFingerprintV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyFingerprintV1 {
        return try PublicKeyFingerprintV1(
            bytes: FfiConverterTypeHashableBytes.read(from: &buf)
        )
    }

    public static func write(_ value: PublicKeyFingerprintV1, into buf: inout [UInt8]) {
        FfiConverterTypeHashableBytes.write(value.bytes, into: &buf)
    }
}


public func FfiConverterTypePublicKeyFingerprintV1_lift(_ buf: RustBuffer) throws -> PublicKeyFingerprintV1 {
    return try FfiConverterTypePublicKeyFingerprintV1.lift(buf)
}

public func FfiConverterTypePublicKeyFingerprintV1_lower(_ value: PublicKeyFingerprintV1) -> RustBuffer {
    return FfiConverterTypePublicKeyFingerprintV1.lower(value)
}


public struct RecoverEvent {
    public var claimant: Address
    public var resourceAddress: Address
    public var resources: ResourceSpecifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(claimant: Address, resourceAddress: Address, resources: ResourceSpecifier) {
        self.claimant = claimant
        self.resourceAddress = resourceAddress
        self.resources = resources
    }
}



public struct FfiConverterTypeRecoverEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoverEvent {
        return try RecoverEvent(
            claimant: FfiConverterTypeAddress.read(from: &buf), 
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            resources: FfiConverterTypeResourceSpecifier.read(from: &buf)
        )
    }

    public static func write(_ value: RecoverEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.claimant, into: &buf)
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeResourceSpecifier.write(value.resources, into: &buf)
    }
}


public func FfiConverterTypeRecoverEvent_lift(_ buf: RustBuffer) throws -> RecoverEvent {
    return try FfiConverterTypeRecoverEvent.lift(buf)
}

public func FfiConverterTypeRecoverEvent_lower(_ value: RecoverEvent) -> RustBuffer {
    return FfiConverterTypeRecoverEvent.lower(value)
}


public struct RecoveryProposal {
    public var ruleSet: RuleSet
    public var timedRecoveryDelayInMinutes: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ruleSet: RuleSet, timedRecoveryDelayInMinutes: UInt32?) {
        self.ruleSet = ruleSet
        self.timedRecoveryDelayInMinutes = timedRecoveryDelayInMinutes
    }
}



public struct FfiConverterTypeRecoveryProposal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryProposal {
        return try RecoveryProposal(
            ruleSet: FfiConverterTypeRuleSet.read(from: &buf), 
            timedRecoveryDelayInMinutes: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RecoveryProposal, into buf: inout [UInt8]) {
        FfiConverterTypeRuleSet.write(value.ruleSet, into: &buf)
        FfiConverterOptionUInt32.write(value.timedRecoveryDelayInMinutes, into: &buf)
    }
}


public func FfiConverterTypeRecoveryProposal_lift(_ buf: RustBuffer) throws -> RecoveryProposal {
    return try FfiConverterTypeRecoveryProposal.lift(buf)
}

public func FfiConverterTypeRecoveryProposal_lower(_ value: RecoveryProposal) -> RustBuffer {
    return FfiConverterTypeRecoveryProposal.lower(value)
}


public struct RegisterValidatorEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension RegisterValidatorEvent: Equatable, Hashable {
    public static func ==(lhs: RegisterValidatorEvent, rhs: RegisterValidatorEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeRegisterValidatorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterValidatorEvent {
        return try RegisterValidatorEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterValidatorEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeRegisterValidatorEvent_lift(_ buf: RustBuffer) throws -> RegisterValidatorEvent {
    return try FfiConverterTypeRegisterValidatorEvent.lift(buf)
}

public func FfiConverterTypeRegisterValidatorEvent_lower(_ value: RegisterValidatorEvent) -> RustBuffer {
    return FfiConverterTypeRegisterValidatorEvent.lower(value)
}


public struct RemoveMetadataEvent {
    public var key: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String) {
        self.key = key
    }
}


extension RemoveMetadataEvent: Equatable, Hashable {
    public static func ==(lhs: RemoveMetadataEvent, rhs: RemoveMetadataEvent) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
    }
}


public struct FfiConverterTypeRemoveMetadataEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RemoveMetadataEvent {
        return try RemoveMetadataEvent(
            key: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RemoveMetadataEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeRemoveMetadataEvent_lift(_ buf: RustBuffer) throws -> RemoveMetadataEvent {
    return try FfiConverterTypeRemoveMetadataEvent.lift(buf)
}

public func FfiConverterTypeRemoveMetadataEvent_lower(_ value: RemoveMetadataEvent) -> RustBuffer {
    return FfiConverterTypeRemoveMetadataEvent.lower(value)
}


public struct ResourceAddresses {
    public var xrd: Address
    public var secp256k1SignatureResource: Address
    public var ed25519SignatureResource: Address
    public var packageOfDirectCallerResource: Address
    public var globalCallerResource: Address
    public var systemExecutionResource: Address
    public var packageOwnerBadge: Address
    public var validatorOwnerBadge: Address
    public var accountOwnerBadge: Address
    public var identityOwnerBadge: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(xrd: Address, secp256k1SignatureResource: Address, ed25519SignatureResource: Address, packageOfDirectCallerResource: Address, globalCallerResource: Address, systemExecutionResource: Address, packageOwnerBadge: Address, validatorOwnerBadge: Address, accountOwnerBadge: Address, identityOwnerBadge: Address) {
        self.xrd = xrd
        self.secp256k1SignatureResource = secp256k1SignatureResource
        self.ed25519SignatureResource = ed25519SignatureResource
        self.packageOfDirectCallerResource = packageOfDirectCallerResource
        self.globalCallerResource = globalCallerResource
        self.systemExecutionResource = systemExecutionResource
        self.packageOwnerBadge = packageOwnerBadge
        self.validatorOwnerBadge = validatorOwnerBadge
        self.accountOwnerBadge = accountOwnerBadge
        self.identityOwnerBadge = identityOwnerBadge
    }
}



public struct FfiConverterTypeResourceAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddresses {
        return try ResourceAddresses(
            xrd: FfiConverterTypeAddress.read(from: &buf), 
            secp256k1SignatureResource: FfiConverterTypeAddress.read(from: &buf), 
            ed25519SignatureResource: FfiConverterTypeAddress.read(from: &buf), 
            packageOfDirectCallerResource: FfiConverterTypeAddress.read(from: &buf), 
            globalCallerResource: FfiConverterTypeAddress.read(from: &buf), 
            systemExecutionResource: FfiConverterTypeAddress.read(from: &buf), 
            packageOwnerBadge: FfiConverterTypeAddress.read(from: &buf), 
            validatorOwnerBadge: FfiConverterTypeAddress.read(from: &buf), 
            accountOwnerBadge: FfiConverterTypeAddress.read(from: &buf), 
            identityOwnerBadge: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.xrd, into: &buf)
        FfiConverterTypeAddress.write(value.secp256k1SignatureResource, into: &buf)
        FfiConverterTypeAddress.write(value.ed25519SignatureResource, into: &buf)
        FfiConverterTypeAddress.write(value.packageOfDirectCallerResource, into: &buf)
        FfiConverterTypeAddress.write(value.globalCallerResource, into: &buf)
        FfiConverterTypeAddress.write(value.systemExecutionResource, into: &buf)
        FfiConverterTypeAddress.write(value.packageOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.validatorOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.accountOwnerBadge, into: &buf)
        FfiConverterTypeAddress.write(value.identityOwnerBadge, into: &buf)
    }
}


public func FfiConverterTypeResourceAddresses_lift(_ buf: RustBuffer) throws -> ResourceAddresses {
    return try FfiConverterTypeResourceAddresses.lift(buf)
}

public func FfiConverterTypeResourceAddresses_lower(_ value: ResourceAddresses) -> RustBuffer {
    return FfiConverterTypeResourceAddresses.lower(value)
}


public struct ResourceManagerRole {
    public var role: AccessRule?
    public var roleUpdater: AccessRule?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(role: AccessRule?, roleUpdater: AccessRule?) {
        self.role = role
        self.roleUpdater = roleUpdater
    }
}



public struct FfiConverterTypeResourceManagerRole: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceManagerRole {
        return try ResourceManagerRole(
            role: FfiConverterOptionTypeAccessRule.read(from: &buf), 
            roleUpdater: FfiConverterOptionTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceManagerRole, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAccessRule.write(value.role, into: &buf)
        FfiConverterOptionTypeAccessRule.write(value.roleUpdater, into: &buf)
    }
}


public func FfiConverterTypeResourceManagerRole_lift(_ buf: RustBuffer) throws -> ResourceManagerRole {
    return try FfiConverterTypeResourceManagerRole.lift(buf)
}

public func FfiConverterTypeResourceManagerRole_lower(_ value: ResourceManagerRole) -> RustBuffer {
    return FfiConverterTypeResourceManagerRole.lower(value)
}


public struct RoundChangeEvent {
    public var round: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(round: UInt64) {
        self.round = round
    }
}


extension RoundChangeEvent: Equatable, Hashable {
    public static func ==(lhs: RoundChangeEvent, rhs: RoundChangeEvent) -> Bool {
        if lhs.round != rhs.round {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(round)
    }
}


public struct FfiConverterTypeRoundChangeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundChangeEvent {
        return try RoundChangeEvent(
            round: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoundChangeEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.round, into: &buf)
    }
}


public func FfiConverterTypeRoundChangeEvent_lift(_ buf: RustBuffer) throws -> RoundChangeEvent {
    return try FfiConverterTypeRoundChangeEvent.lift(buf)
}

public func FfiConverterTypeRoundChangeEvent_lower(_ value: RoundChangeEvent) -> RustBuffer {
    return FfiConverterTypeRoundChangeEvent.lower(value)
}


public struct RuleSet {
    public var primaryRole: AccessRule
    public var recoveryRole: AccessRule
    public var confirmationRole: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(primaryRole: AccessRule, recoveryRole: AccessRule, confirmationRole: AccessRule) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}



public struct FfiConverterTypeRuleSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuleSet {
        return try RuleSet(
            primaryRole: FfiConverterTypeAccessRule.read(from: &buf), 
            recoveryRole: FfiConverterTypeAccessRule.read(from: &buf), 
            confirmationRole: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: RuleSet, into buf: inout [UInt8]) {
        FfiConverterTypeAccessRule.write(value.primaryRole, into: &buf)
        FfiConverterTypeAccessRule.write(value.recoveryRole, into: &buf)
        FfiConverterTypeAccessRule.write(value.confirmationRole, into: &buf)
    }
}


public func FfiConverterTypeRuleSet_lift(_ buf: RustBuffer) throws -> RuleSet {
    return try FfiConverterTypeRuleSet.lift(buf)
}

public func FfiConverterTypeRuleSet_lower(_ value: RuleSet) -> RustBuffer {
    return FfiConverterTypeRuleSet.lower(value)
}


public struct RuleSetUpdateEvent {
    public var proposer: Proposer
    public var proposal: RecoveryProposal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proposer: Proposer, proposal: RecoveryProposal) {
        self.proposer = proposer
        self.proposal = proposal
    }
}



public struct FfiConverterTypeRuleSetUpdateEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuleSetUpdateEvent {
        return try RuleSetUpdateEvent(
            proposer: FfiConverterTypeProposer.read(from: &buf), 
            proposal: FfiConverterTypeRecoveryProposal.read(from: &buf)
        )
    }

    public static func write(_ value: RuleSetUpdateEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.proposer, into: &buf)
        FfiConverterTypeRecoveryProposal.write(value.proposal, into: &buf)
    }
}


public func FfiConverterTypeRuleSetUpdateEvent_lift(_ buf: RustBuffer) throws -> RuleSetUpdateEvent {
    return try FfiConverterTypeRuleSetUpdateEvent.lift(buf)
}

public func FfiConverterTypeRuleSetUpdateEvent_lower(_ value: RuleSetUpdateEvent) -> RustBuffer {
    return FfiConverterTypeRuleSetUpdateEvent.lower(value)
}


public struct Schema {
    public var localTypeId: LocalTypeId
    public var schema: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localTypeId: LocalTypeId, schema: Data) {
        self.localTypeId = localTypeId
        self.schema = schema
    }
}


extension Schema: Equatable, Hashable {
    public static func ==(lhs: Schema, rhs: Schema) -> Bool {
        if lhs.localTypeId != rhs.localTypeId {
            return false
        }
        if lhs.schema != rhs.schema {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localTypeId)
        hasher.combine(schema)
    }
}


public struct FfiConverterTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Schema {
        return try Schema(
            localTypeId: FfiConverterTypeLocalTypeId.read(from: &buf), 
            schema: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Schema, into buf: inout [UInt8]) {
        FfiConverterTypeLocalTypeId.write(value.localTypeId, into: &buf)
        FfiConverterData.write(value.schema, into: &buf)
    }
}


public func FfiConverterTypeSchema_lift(_ buf: RustBuffer) throws -> Schema {
    return try FfiConverterTypeSchema.lift(buf)
}

public func FfiConverterTypeSchema_lower(_ value: Schema) -> RustBuffer {
    return FfiConverterTypeSchema.lower(value)
}


public struct Secp256k1PublicKey {
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Data) {
        self.value = value
    }
}


extension Secp256k1PublicKey: Equatable, Hashable {
    public static func ==(lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return try Secp256k1PublicKey(
            value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}


public struct SecurityStructureRole {
    public var superAdminFactors: [PublicKey]
    public var thresholdFactors: [PublicKey]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(superAdminFactors: [PublicKey], thresholdFactors: [PublicKey], threshold: UInt8) {
        self.superAdminFactors = superAdminFactors
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
    }
}


extension SecurityStructureRole: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureRole, rhs: SecurityStructureRole) -> Bool {
        if lhs.superAdminFactors != rhs.superAdminFactors {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(superAdminFactors)
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
    }
}


public struct FfiConverterTypeSecurityStructureRole: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureRole {
        return try SecurityStructureRole(
            superAdminFactors: FfiConverterSequenceTypePublicKey.read(from: &buf), 
            thresholdFactors: FfiConverterSequenceTypePublicKey.read(from: &buf), 
            threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureRole, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.superAdminFactors, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


public func FfiConverterTypeSecurityStructureRole_lift(_ buf: RustBuffer) throws -> SecurityStructureRole {
    return try FfiConverterTypeSecurityStructureRole.lift(buf)
}

public func FfiConverterTypeSecurityStructureRole_lower(_ value: SecurityStructureRole) -> RustBuffer {
    return FfiConverterTypeSecurityStructureRole.lower(value)
}


public struct SetAndLockRoleEvent {
    public var roleKey: String
    public var rule: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roleKey: String, rule: AccessRule) {
        self.roleKey = roleKey
        self.rule = rule
    }
}



public struct FfiConverterTypeSetAndLockRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetAndLockRoleEvent {
        return try SetAndLockRoleEvent(
            roleKey: FfiConverterString.read(from: &buf), 
            rule: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetAndLockRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roleKey, into: &buf)
        FfiConverterTypeAccessRule.write(value.rule, into: &buf)
    }
}


public func FfiConverterTypeSetAndLockRoleEvent_lift(_ buf: RustBuffer) throws -> SetAndLockRoleEvent {
    return try FfiConverterTypeSetAndLockRoleEvent.lift(buf)
}

public func FfiConverterTypeSetAndLockRoleEvent_lower(_ value: SetAndLockRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetAndLockRoleEvent.lower(value)
}


public struct SetMetadataEvent {
    public var key: String
    public var value: MetadataValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: MetadataValue) {
        self.key = key
        self.value = value
    }
}



public struct FfiConverterTypeSetMetadataEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetMetadataEvent {
        return try SetMetadataEvent(
            key: FfiConverterString.read(from: &buf), 
            value: FfiConverterTypeMetadataValue.read(from: &buf)
        )
    }

    public static func write(_ value: SetMetadataEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterTypeMetadataValue.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeSetMetadataEvent_lift(_ buf: RustBuffer) throws -> SetMetadataEvent {
    return try FfiConverterTypeSetMetadataEvent.lift(buf)
}

public func FfiConverterTypeSetMetadataEvent_lower(_ value: SetMetadataEvent) -> RustBuffer {
    return FfiConverterTypeSetMetadataEvent.lower(value)
}


public struct SetOwnerRoleEvent {
    public var rule: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rule: AccessRule) {
        self.rule = rule
    }
}



public struct FfiConverterTypeSetOwnerRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetOwnerRoleEvent {
        return try SetOwnerRoleEvent(
            rule: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetOwnerRoleEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAccessRule.write(value.rule, into: &buf)
    }
}


public func FfiConverterTypeSetOwnerRoleEvent_lift(_ buf: RustBuffer) throws -> SetOwnerRoleEvent {
    return try FfiConverterTypeSetOwnerRoleEvent.lift(buf)
}

public func FfiConverterTypeSetOwnerRoleEvent_lower(_ value: SetOwnerRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetOwnerRoleEvent.lower(value)
}


public struct SetRoleEvent {
    public var roleKey: String
    public var rule: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roleKey: String, rule: AccessRule) {
        self.roleKey = roleKey
        self.rule = rule
    }
}



public struct FfiConverterTypeSetRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetRoleEvent {
        return try SetRoleEvent(
            roleKey: FfiConverterString.read(from: &buf), 
            rule: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roleKey, into: &buf)
        FfiConverterTypeAccessRule.write(value.rule, into: &buf)
    }
}


public func FfiConverterTypeSetRoleEvent_lift(_ buf: RustBuffer) throws -> SetRoleEvent {
    return try FfiConverterTypeSetRoleEvent.lift(buf)
}

public func FfiConverterTypeSetRoleEvent_lower(_ value: SetRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetRoleEvent.lower(value)
}


public struct StakeEvent {
    public var xrdStaked: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(xrdStaked: Decimal) {
        self.xrdStaked = xrdStaked
    }
}



public struct FfiConverterTypeStakeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeEvent {
        return try StakeEvent(
            xrdStaked: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: StakeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.xrdStaked, into: &buf)
    }
}


public func FfiConverterTypeStakeEvent_lift(_ buf: RustBuffer) throws -> StakeEvent {
    return try FfiConverterTypeStakeEvent.lift(buf)
}

public func FfiConverterTypeStakeEvent_lower(_ value: StakeEvent) -> RustBuffer {
    return FfiConverterTypeStakeEvent.lower(value)
}


public struct StaticAnalysis {
    public var presentedProofs: [String: [ResourceSpecifier]]
    public var accountsWithdrawnFrom: [Address]
    public var accountsDepositedInto: [Address]
    public var encounteredEntities: [Address]
    public var accountsRequiringAuth: [Address]
    public var identitiesRequiringAuth: [Address]
    public var reservedInstructions: [ReservedInstruction]
    public var classification: [ManifestClass]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(presentedProofs: [String: [ResourceSpecifier]], accountsWithdrawnFrom: [Address], accountsDepositedInto: [Address], encounteredEntities: [Address], accountsRequiringAuth: [Address], identitiesRequiringAuth: [Address], reservedInstructions: [ReservedInstruction], classification: [ManifestClass]) {
        self.presentedProofs = presentedProofs
        self.accountsWithdrawnFrom = accountsWithdrawnFrom
        self.accountsDepositedInto = accountsDepositedInto
        self.encounteredEntities = encounteredEntities
        self.accountsRequiringAuth = accountsRequiringAuth
        self.identitiesRequiringAuth = identitiesRequiringAuth
        self.reservedInstructions = reservedInstructions
        self.classification = classification
    }
}



public struct FfiConverterTypeStaticAnalysis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StaticAnalysis {
        return try StaticAnalysis(
            presentedProofs: FfiConverterDictionaryStringSequenceTypeResourceSpecifier.read(from: &buf), 
            accountsWithdrawnFrom: FfiConverterSequenceTypeAddress.read(from: &buf), 
            accountsDepositedInto: FfiConverterSequenceTypeAddress.read(from: &buf), 
            encounteredEntities: FfiConverterSequenceTypeAddress.read(from: &buf), 
            accountsRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            identitiesRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf), 
            classification: FfiConverterSequenceTypeManifestClass.read(from: &buf)
        )
    }

    public static func write(_ value: StaticAnalysis, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.encounteredEntities, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.identitiesRequiringAuth, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeManifestClass.write(value.classification, into: &buf)
    }
}


public func FfiConverterTypeStaticAnalysis_lift(_ buf: RustBuffer) throws -> StaticAnalysis {
    return try FfiConverterTypeStaticAnalysis.lift(buf)
}

public func FfiConverterTypeStaticAnalysis_lower(_ value: StaticAnalysis) -> RustBuffer {
    return FfiConverterTypeStaticAnalysis.lower(value)
}


public struct StaticAnalysisWithResourceMovements {
    public var accountWithdraws: [String: [AccountWithdraw]]
    public var accountDeposits: [String: [AccountDeposit]]
    public var presentedProofs: [String: [ResourceSpecifier]]
    public var accountsWithdrawnFrom: [Address]
    public var accountsDepositedInto: [Address]
    public var encounteredEntities: [Address]
    public var accountsRequiringAuth: [Address]
    public var identitiesRequiringAuth: [Address]
    public var reservedInstructions: [ReservedInstruction]
    public var classification: [ManifestClass]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountWithdraws: [String: [AccountWithdraw]], accountDeposits: [String: [AccountDeposit]], presentedProofs: [String: [ResourceSpecifier]], accountsWithdrawnFrom: [Address], accountsDepositedInto: [Address], encounteredEntities: [Address], accountsRequiringAuth: [Address], identitiesRequiringAuth: [Address], reservedInstructions: [ReservedInstruction], classification: [ManifestClass]) {
        self.accountWithdraws = accountWithdraws
        self.accountDeposits = accountDeposits
        self.presentedProofs = presentedProofs
        self.accountsWithdrawnFrom = accountsWithdrawnFrom
        self.accountsDepositedInto = accountsDepositedInto
        self.encounteredEntities = encounteredEntities
        self.accountsRequiringAuth = accountsRequiringAuth
        self.identitiesRequiringAuth = identitiesRequiringAuth
        self.reservedInstructions = reservedInstructions
        self.classification = classification
    }
}



public struct FfiConverterTypeStaticAnalysisWithResourceMovements: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StaticAnalysisWithResourceMovements {
        return try StaticAnalysisWithResourceMovements(
            accountWithdraws: FfiConverterDictionaryStringSequenceTypeAccountWithdraw.read(from: &buf), 
            accountDeposits: FfiConverterDictionaryStringSequenceTypeAccountDeposit.read(from: &buf), 
            presentedProofs: FfiConverterDictionaryStringSequenceTypeResourceSpecifier.read(from: &buf), 
            accountsWithdrawnFrom: FfiConverterSequenceTypeAddress.read(from: &buf), 
            accountsDepositedInto: FfiConverterSequenceTypeAddress.read(from: &buf), 
            encounteredEntities: FfiConverterSequenceTypeAddress.read(from: &buf), 
            accountsRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            identitiesRequiringAuth: FfiConverterSequenceTypeAddress.read(from: &buf), 
            reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf), 
            classification: FfiConverterSequenceTypeManifestClass.read(from: &buf)
        )
    }

    public static func write(_ value: StaticAnalysisWithResourceMovements, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringSequenceTypeAccountWithdraw.write(value.accountWithdraws, into: &buf)
        FfiConverterDictionaryStringSequenceTypeAccountDeposit.write(value.accountDeposits, into: &buf)
        FfiConverterDictionaryStringSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.encounteredEntities, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.accountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeAddress.write(value.identitiesRequiringAuth, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeManifestClass.write(value.classification, into: &buf)
    }
}


public func FfiConverterTypeStaticAnalysisWithResourceMovements_lift(_ buf: RustBuffer) throws -> StaticAnalysisWithResourceMovements {
    return try FfiConverterTypeStaticAnalysisWithResourceMovements.lift(buf)
}

public func FfiConverterTypeStaticAnalysisWithResourceMovements_lower(_ value: StaticAnalysisWithResourceMovements) -> RustBuffer {
    return FfiConverterTypeStaticAnalysisWithResourceMovements.lower(value)
}


public struct StopTimedRecoveryEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension StopTimedRecoveryEvent: Equatable, Hashable {
    public static func ==(lhs: StopTimedRecoveryEvent, rhs: StopTimedRecoveryEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeStopTimedRecoveryEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StopTimedRecoveryEvent {
        return try StopTimedRecoveryEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: StopTimedRecoveryEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeStopTimedRecoveryEvent_lift(_ buf: RustBuffer) throws -> StopTimedRecoveryEvent {
    return try FfiConverterTypeStopTimedRecoveryEvent.lift(buf)
}

public func FfiConverterTypeStopTimedRecoveryEvent_lower(_ value: StopTimedRecoveryEvent) -> RustBuffer {
    return FfiConverterTypeStopTimedRecoveryEvent.lower(value)
}


public struct StoreEvent {
    public var claimant: Address
    public var resourceAddress: Address
    public var resources: ResourceSpecifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(claimant: Address, resourceAddress: Address, resources: ResourceSpecifier) {
        self.claimant = claimant
        self.resourceAddress = resourceAddress
        self.resources = resources
    }
}



public struct FfiConverterTypeStoreEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StoreEvent {
        return try StoreEvent(
            claimant: FfiConverterTypeAddress.read(from: &buf), 
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            resources: FfiConverterTypeResourceSpecifier.read(from: &buf)
        )
    }

    public static func write(_ value: StoreEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.claimant, into: &buf)
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeResourceSpecifier.write(value.resources, into: &buf)
    }
}


public func FfiConverterTypeStoreEvent_lift(_ buf: RustBuffer) throws -> StoreEvent {
    return try FfiConverterTypeStoreEvent.lift(buf)
}

public func FfiConverterTypeStoreEvent_lower(_ value: StoreEvent) -> RustBuffer {
    return FfiConverterTypeStoreEvent.lower(value)
}


public struct TrackedPoolContribution {
    public var poolAddress: Address
    public var contributedResources: [String: Decimal]
    public var poolUnitsResourceAddress: Address
    public var poolUnitsAmount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: Address, contributedResources: [String: Decimal], poolUnitsResourceAddress: Address, poolUnitsAmount: Decimal) {
        self.poolAddress = poolAddress
        self.contributedResources = contributedResources
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
    }
}



public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
        return try TrackedPoolContribution(
            poolAddress: FfiConverterTypeAddress.read(from: &buf), 
            contributedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf), 
            poolUnitsResourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            poolUnitsAmount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.poolAddress, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.contributedResources, into: &buf)
        FfiConverterTypeAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.poolUnitsAmount, into: &buf)
    }
}


public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
    return try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
    return FfiConverterTypeTrackedPoolContribution.lower(value)
}


public struct TrackedPoolRedemption {
    public var poolAddress: Address
    public var poolUnitsResourceAddress: Address
    public var poolUnitsAmount: Decimal
    public var redeemedResources: [String: Decimal]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: Address, poolUnitsResourceAddress: Address, poolUnitsAmount: Decimal, redeemedResources: [String: Decimal]) {
        self.poolAddress = poolAddress
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
        self.redeemedResources = redeemedResources
    }
}



public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
        return try TrackedPoolRedemption(
            poolAddress: FfiConverterTypeAddress.read(from: &buf), 
            poolUnitsResourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            poolUnitsAmount: FfiConverterTypeDecimal.read(from: &buf), 
            redeemedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.poolAddress, into: &buf)
        FfiConverterTypeAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.poolUnitsAmount, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.redeemedResources, into: &buf)
    }
}


public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
    return try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
    return FfiConverterTypeTrackedPoolRedemption.lower(value)
}


public struct TrackedValidatorClaim {
    public var validatorAddress: Address
    public var claimNftAddress: Address
    public var claimNftIds: [NonFungibleLocalId]
    public var xrdAmount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: Address, claimNftAddress: Address, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal) {
        self.validatorAddress = validatorAddress
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
        self.xrdAmount = xrdAmount
    }
}



public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
        return try TrackedValidatorClaim(
            validatorAddress: FfiConverterTypeAddress.read(from: &buf), 
            claimNftAddress: FfiConverterTypeAddress.read(from: &buf), 
            claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
            xrdAmount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
        FfiConverterTypeDecimal.write(value.xrdAmount, into: &buf)
    }
}


public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
    return try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorClaim.lower(value)
}


public struct TrackedValidatorStake {
    public var validatorAddress: Address
    public var xrdAmount: Decimal
    public var liquidStakeUnitAddress: Address
    public var liquidStakeUnitAmount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: Address, xrdAmount: Decimal, liquidStakeUnitAddress: Address, liquidStakeUnitAmount: Decimal) {
        self.validatorAddress = validatorAddress
        self.xrdAmount = xrdAmount
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
    }
}



public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
        return try TrackedValidatorStake(
            validatorAddress: FfiConverterTypeAddress.read(from: &buf), 
            xrdAmount: FfiConverterTypeDecimal.read(from: &buf), 
            liquidStakeUnitAddress: FfiConverterTypeAddress.read(from: &buf), 
            liquidStakeUnitAmount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.xrdAmount, into: &buf)
        FfiConverterTypeAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.liquidStakeUnitAmount, into: &buf)
    }
}


public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
    return try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorStake.lower(value)
}


public struct TrackedValidatorUnstake {
    public var validatorAddress: Address
    public var liquidStakeUnitAddress: Address
    public var liquidStakeUnitAmount: Decimal
    public var claimNftAddress: Address
    public var claimNftIds: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: Address, liquidStakeUnitAddress: Address, liquidStakeUnitAmount: Decimal, claimNftAddress: Address, claimNftIds: [NonFungibleLocalId]) {
        self.validatorAddress = validatorAddress
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
    }
}



public struct FfiConverterTypeTrackedValidatorUnstake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorUnstake {
        return try TrackedValidatorUnstake(
            validatorAddress: FfiConverterTypeAddress.read(from: &buf), 
            liquidStakeUnitAddress: FfiConverterTypeAddress.read(from: &buf), 
            liquidStakeUnitAmount: FfiConverterTypeDecimal.read(from: &buf), 
            claimNftAddress: FfiConverterTypeAddress.read(from: &buf), 
            claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedValidatorUnstake, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.liquidStakeUnitAmount, into: &buf)
        FfiConverterTypeAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
    }
}


public func FfiConverterTypeTrackedValidatorUnstake_lift(_ buf: RustBuffer) throws -> TrackedValidatorUnstake {
    return try FfiConverterTypeTrackedValidatorUnstake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorUnstake_lower(_ value: TrackedValidatorUnstake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorUnstake.lower(value)
}


public struct TransactionHeaderV1 {
    public var networkId: UInt8
    public var startEpochInclusive: UInt64
    public var endEpochExclusive: UInt64
    public var nonce: UInt32
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: UInt8, startEpochInclusive: UInt64, endEpochExclusive: UInt64, nonce: UInt32, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}


extension TransactionHeaderV1: Equatable, Hashable {
    public static func ==(lhs: TransactionHeaderV1, rhs: TransactionHeaderV1) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}


public struct FfiConverterTypeTransactionHeaderV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeaderV1 {
        return try TransactionHeaderV1(
            networkId: FfiConverterUInt8.read(from: &buf), 
            startEpochInclusive: FfiConverterUInt64.read(from: &buf), 
            endEpochExclusive: FfiConverterUInt64.read(from: &buf), 
            nonce: FfiConverterUInt32.read(from: &buf), 
            notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf), 
            notaryIsSignatory: FfiConverterBool.read(from: &buf), 
            tipPercentage: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionHeaderV1, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.networkId, into: &buf)
        FfiConverterUInt64.write(value.startEpochInclusive, into: &buf)
        FfiConverterUInt64.write(value.endEpochExclusive, into: &buf)
        FfiConverterUInt32.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}


public func FfiConverterTypeTransactionHeaderV1_lift(_ buf: RustBuffer) throws -> TransactionHeaderV1 {
    return try FfiConverterTypeTransactionHeaderV1.lift(buf)
}

public func FfiConverterTypeTransactionHeaderV1_lower(_ value: TransactionHeaderV1) -> RustBuffer {
    return FfiConverterTypeTransactionHeaderV1.lower(value)
}


public struct TransactionHeaderV2 {
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipBasisPoints: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipBasisPoints: UInt32) {
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipBasisPoints = tipBasisPoints
    }
}


extension TransactionHeaderV2: Equatable, Hashable {
    public static func ==(lhs: TransactionHeaderV2, rhs: TransactionHeaderV2) -> Bool {
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipBasisPoints != rhs.tipBasisPoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipBasisPoints)
    }
}


public struct FfiConverterTypeTransactionHeaderV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeaderV2 {
        return try TransactionHeaderV2(
            notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf), 
            notaryIsSignatory: FfiConverterBool.read(from: &buf), 
            tipBasisPoints: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionHeaderV2, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt32.write(value.tipBasisPoints, into: &buf)
    }
}


public func FfiConverterTypeTransactionHeaderV2_lift(_ buf: RustBuffer) throws -> TransactionHeaderV2 {
    return try FfiConverterTypeTransactionHeaderV2.lift(buf)
}

public func FfiConverterTypeTransactionHeaderV2_lower(_ value: TransactionHeaderV2) -> RustBuffer {
    return FfiConverterTypeTransactionHeaderV2.lower(value)
}


public struct TwoResourcePoolContributionEvent {
    public var contributedResources: [String: Decimal]
    public var poolUnitsMinted: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contributedResources: [String: Decimal], poolUnitsMinted: Decimal) {
        self.contributedResources = contributedResources
        self.poolUnitsMinted = poolUnitsMinted
    }
}



public struct FfiConverterTypeTwoResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolContributionEvent {
        return try TwoResourcePoolContributionEvent(
            contributedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf), 
            poolUnitsMinted: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeDecimal.write(value.contributedResources, into: &buf)
        FfiConverterTypeDecimal.write(value.poolUnitsMinted, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolContributionEvent {
    return try FfiConverterTypeTwoResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolContributionEvent_lower(_ value: TwoResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolContributionEvent.lower(value)
}


public struct TwoResourcePoolDepositEvent {
    public var resourceAddress: Address
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address, amount: Decimal) {
        self.resourceAddress = resourceAddress
        self.amount = amount
    }
}



public struct FfiConverterTypeTwoResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolDepositEvent {
        return try TwoResourcePoolDepositEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolDepositEvent {
    return try FfiConverterTypeTwoResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolDepositEvent_lower(_ value: TwoResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolDepositEvent.lower(value)
}


public struct TwoResourcePoolRedemptionEvent {
    public var poolUnitTokensRedeemed: Decimal
    public var redeemedResources: [String: Decimal]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolUnitTokensRedeemed: Decimal, redeemedResources: [String: Decimal]) {
        self.poolUnitTokensRedeemed = poolUnitTokensRedeemed
        self.redeemedResources = redeemedResources
    }
}



public struct FfiConverterTypeTwoResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolRedemptionEvent {
        return try TwoResourcePoolRedemptionEvent(
            poolUnitTokensRedeemed: FfiConverterTypeDecimal.read(from: &buf), 
            redeemedResources: FfiConverterDictionaryStringTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.poolUnitTokensRedeemed, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.redeemedResources, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolRedemptionEvent {
    return try FfiConverterTypeTwoResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolRedemptionEvent_lower(_ value: TwoResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolRedemptionEvent.lower(value)
}


public struct TwoResourcePoolWithdrawEvent {
    public var resourceAddress: Address
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: Address, amount: Decimal) {
        self.resourceAddress = resourceAddress
        self.amount = amount
    }
}



public struct FfiConverterTypeTwoResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolWithdrawEvent {
        return try TwoResourcePoolWithdrawEvent(
            resourceAddress: FfiConverterTypeAddress.read(from: &buf), 
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolWithdrawEvent {
    return try FfiConverterTypeTwoResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolWithdrawEvent_lower(_ value: TwoResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolWithdrawEvent.lower(value)
}


public struct UnlockPrimaryRoleEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension UnlockPrimaryRoleEvent: Equatable, Hashable {
    public static func ==(lhs: UnlockPrimaryRoleEvent, rhs: UnlockPrimaryRoleEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeUnlockPrimaryRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnlockPrimaryRoleEvent {
        return try UnlockPrimaryRoleEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UnlockPrimaryRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeUnlockPrimaryRoleEvent_lift(_ buf: RustBuffer) throws -> UnlockPrimaryRoleEvent {
    return try FfiConverterTypeUnlockPrimaryRoleEvent.lift(buf)
}

public func FfiConverterTypeUnlockPrimaryRoleEvent_lower(_ value: UnlockPrimaryRoleEvent) -> RustBuffer {
    return FfiConverterTypeUnlockPrimaryRoleEvent.lower(value)
}


public struct UnregisterValidatorEvent {
    public var placeholderField: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placeholderField: Bool) {
        self.placeholderField = placeholderField
    }
}


extension UnregisterValidatorEvent: Equatable, Hashable {
    public static func ==(lhs: UnregisterValidatorEvent, rhs: UnregisterValidatorEvent) -> Bool {
        if lhs.placeholderField != rhs.placeholderField {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placeholderField)
    }
}


public struct FfiConverterTypeUnregisterValidatorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnregisterValidatorEvent {
        return try UnregisterValidatorEvent(
            placeholderField: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UnregisterValidatorEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.placeholderField, into: &buf)
    }
}


public func FfiConverterTypeUnregisterValidatorEvent_lift(_ buf: RustBuffer) throws -> UnregisterValidatorEvent {
    return try FfiConverterTypeUnregisterValidatorEvent.lift(buf)
}

public func FfiConverterTypeUnregisterValidatorEvent_lower(_ value: UnregisterValidatorEvent) -> RustBuffer {
    return FfiConverterTypeUnregisterValidatorEvent.lower(value)
}


public struct UnstakeData {
    public var name: String
    public var claimEpoch: UInt64
    public var claimAmount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, claimEpoch: UInt64, claimAmount: Decimal) {
        self.name = name
        self.claimEpoch = claimEpoch
        self.claimAmount = claimAmount
    }
}



public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
        return try UnstakeData(
            name: FfiConverterString.read(from: &buf), 
            claimEpoch: FfiConverterUInt64.read(from: &buf), 
            claimAmount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt64.write(value.claimEpoch, into: &buf)
        FfiConverterTypeDecimal.write(value.claimAmount, into: &buf)
    }
}


public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
    return try FfiConverterTypeUnstakeData.lift(buf)
}

public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
    return FfiConverterTypeUnstakeData.lower(value)
}


public struct UnstakeDataEntry {
    public var nonFungibleGlobalId: NonFungibleGlobalId
    public var data: UnstakeData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nonFungibleGlobalId: NonFungibleGlobalId, data: UnstakeData) {
        self.nonFungibleGlobalId = nonFungibleGlobalId
        self.data = data
    }
}



public struct FfiConverterTypeUnstakeDataEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeDataEntry {
        return try UnstakeDataEntry(
            nonFungibleGlobalId: FfiConverterTypeNonFungibleGlobalId.read(from: &buf), 
            data: FfiConverterTypeUnstakeData.read(from: &buf)
        )
    }

    public static func write(_ value: UnstakeDataEntry, into buf: inout [UInt8]) {
        FfiConverterTypeNonFungibleGlobalId.write(value.nonFungibleGlobalId, into: &buf)
        FfiConverterTypeUnstakeData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeUnstakeDataEntry_lift(_ buf: RustBuffer) throws -> UnstakeDataEntry {
    return try FfiConverterTypeUnstakeDataEntry.lift(buf)
}

public func FfiConverterTypeUnstakeDataEntry_lower(_ value: UnstakeDataEntry) -> RustBuffer {
    return FfiConverterTypeUnstakeDataEntry.lower(value)
}


public struct UnstakeEvent {
    public var stakeUnits: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(stakeUnits: Decimal) {
        self.stakeUnits = stakeUnits
    }
}



public struct FfiConverterTypeUnstakeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeEvent {
        return try UnstakeEvent(
            stakeUnits: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: UnstakeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.stakeUnits, into: &buf)
    }
}


public func FfiConverterTypeUnstakeEvent_lift(_ buf: RustBuffer) throws -> UnstakeEvent {
    return try FfiConverterTypeUnstakeEvent.lift(buf)
}

public func FfiConverterTypeUnstakeEvent_lower(_ value: UnstakeEvent) -> RustBuffer {
    return FfiConverterTypeUnstakeEvent.lower(value)
}


public struct UpdateAcceptingStakeDelegationStateEvent {
    public var acceptsDelegation: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(acceptsDelegation: Bool) {
        self.acceptsDelegation = acceptsDelegation
    }
}


extension UpdateAcceptingStakeDelegationStateEvent: Equatable, Hashable {
    public static func ==(lhs: UpdateAcceptingStakeDelegationStateEvent, rhs: UpdateAcceptingStakeDelegationStateEvent) -> Bool {
        if lhs.acceptsDelegation != rhs.acceptsDelegation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(acceptsDelegation)
    }
}


public struct FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateAcceptingStakeDelegationStateEvent {
        return try UpdateAcceptingStakeDelegationStateEvent(
            acceptsDelegation: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateAcceptingStakeDelegationStateEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.acceptsDelegation, into: &buf)
    }
}


public func FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent_lift(_ buf: RustBuffer) throws -> UpdateAcceptingStakeDelegationStateEvent {
    return try FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.lift(buf)
}

public func FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent_lower(_ value: UpdateAcceptingStakeDelegationStateEvent) -> RustBuffer {
    return FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.lower(value)
}


public struct ValidatorEmissionAppliedEvent {
    public var epoch: UInt64
    public var startingStakePoolXrd: Decimal
    public var stakePoolAddedXrd: Decimal
    public var totalStakeUnitSupply: Decimal
    public var validatorFeeXrd: Decimal
    public var proposalsMade: UInt64
    public var proposalsMissed: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epoch: UInt64, startingStakePoolXrd: Decimal, stakePoolAddedXrd: Decimal, totalStakeUnitSupply: Decimal, validatorFeeXrd: Decimal, proposalsMade: UInt64, proposalsMissed: UInt64) {
        self.epoch = epoch
        self.startingStakePoolXrd = startingStakePoolXrd
        self.stakePoolAddedXrd = stakePoolAddedXrd
        self.totalStakeUnitSupply = totalStakeUnitSupply
        self.validatorFeeXrd = validatorFeeXrd
        self.proposalsMade = proposalsMade
        self.proposalsMissed = proposalsMissed
    }
}



public struct FfiConverterTypeValidatorEmissionAppliedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorEmissionAppliedEvent {
        return try ValidatorEmissionAppliedEvent(
            epoch: FfiConverterUInt64.read(from: &buf), 
            startingStakePoolXrd: FfiConverterTypeDecimal.read(from: &buf), 
            stakePoolAddedXrd: FfiConverterTypeDecimal.read(from: &buf), 
            totalStakeUnitSupply: FfiConverterTypeDecimal.read(from: &buf), 
            validatorFeeXrd: FfiConverterTypeDecimal.read(from: &buf), 
            proposalsMade: FfiConverterUInt64.read(from: &buf), 
            proposalsMissed: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorEmissionAppliedEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterTypeDecimal.write(value.startingStakePoolXrd, into: &buf)
        FfiConverterTypeDecimal.write(value.stakePoolAddedXrd, into: &buf)
        FfiConverterTypeDecimal.write(value.totalStakeUnitSupply, into: &buf)
        FfiConverterTypeDecimal.write(value.validatorFeeXrd, into: &buf)
        FfiConverterUInt64.write(value.proposalsMade, into: &buf)
        FfiConverterUInt64.write(value.proposalsMissed, into: &buf)
    }
}


public func FfiConverterTypeValidatorEmissionAppliedEvent_lift(_ buf: RustBuffer) throws -> ValidatorEmissionAppliedEvent {
    return try FfiConverterTypeValidatorEmissionAppliedEvent.lift(buf)
}

public func FfiConverterTypeValidatorEmissionAppliedEvent_lower(_ value: ValidatorEmissionAppliedEvent) -> RustBuffer {
    return FfiConverterTypeValidatorEmissionAppliedEvent.lower(value)
}


public struct ValidatorInfo {
    public var key: Secp256k1PublicKey
    public var stake: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: Secp256k1PublicKey, stake: Decimal) {
        self.key = key
        self.stake = stake
    }
}



public struct FfiConverterTypeValidatorInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorInfo {
        return try ValidatorInfo(
            key: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), 
            stake: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorInfo, into buf: inout [UInt8]) {
        FfiConverterTypeSecp256k1PublicKey.write(value.key, into: &buf)
        FfiConverterTypeDecimal.write(value.stake, into: &buf)
    }
}


public func FfiConverterTypeValidatorInfo_lift(_ buf: RustBuffer) throws -> ValidatorInfo {
    return try FfiConverterTypeValidatorInfo.lift(buf)
}

public func FfiConverterTypeValidatorInfo_lower(_ value: ValidatorInfo) -> RustBuffer {
    return FfiConverterTypeValidatorInfo.lower(value)
}


public struct ValidatorRewardAppliedEvent {
    public var epoch: UInt64
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epoch: UInt64, amount: Decimal) {
        self.epoch = epoch
        self.amount = amount
    }
}



public struct FfiConverterTypeValidatorRewardAppliedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorRewardAppliedEvent {
        return try ValidatorRewardAppliedEvent(
            epoch: FfiConverterUInt64.read(from: &buf), 
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorRewardAppliedEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeValidatorRewardAppliedEvent_lift(_ buf: RustBuffer) throws -> ValidatorRewardAppliedEvent {
    return try FfiConverterTypeValidatorRewardAppliedEvent.lift(buf)
}

public func FfiConverterTypeValidatorRewardAppliedEvent_lower(_ value: ValidatorRewardAppliedEvent) -> RustBuffer {
    return FfiConverterTypeValidatorRewardAppliedEvent.lower(value)
}


public struct VaultCreationEvent {
    public var vaultId: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(vaultId: Address) {
        self.vaultId = vaultId
    }
}



public struct FfiConverterTypeVaultCreationEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultCreationEvent {
        return try VaultCreationEvent(
            vaultId: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: VaultCreationEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.vaultId, into: &buf)
    }
}


public func FfiConverterTypeVaultCreationEvent_lift(_ buf: RustBuffer) throws -> VaultCreationEvent {
    return try FfiConverterTypeVaultCreationEvent.lift(buf)
}

public func FfiConverterTypeVaultCreationEvent_lower(_ value: VaultCreationEvent) -> RustBuffer {
    return FfiConverterTypeVaultCreationEvent.lower(value)
}


public struct WithdrawRecoveryXrdEvent {
    public var amount: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal) {
        self.amount = amount
    }
}



public struct FfiConverterTypeWithdrawRecoveryXrdEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WithdrawRecoveryXrdEvent {
        return try WithdrawRecoveryXrdEvent(
            amount: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: WithdrawRecoveryXrdEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeWithdrawRecoveryXrdEvent_lift(_ buf: RustBuffer) throws -> WithdrawRecoveryXrdEvent {
    return try FfiConverterTypeWithdrawRecoveryXrdEvent.lift(buf)
}

public func FfiConverterTypeWithdrawRecoveryXrdEvent_lower(_ value: WithdrawRecoveryXrdEvent) -> RustBuffer {
    return FfiConverterTypeWithdrawRecoveryXrdEvent.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountDefaultDepositRule {
    
    case accept
    case reject
    case allowExisting
}

public struct FfiConverterTypeAccountDefaultDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = AccountDefaultDepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDefaultDepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accept
        
        case 2: return .reject
        
        case 3: return .allowExisting
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDefaultDepositRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .accept:
            writeInt(&buf, Int32(1))
        
        
        case .reject:
            writeInt(&buf, Int32(2))
        
        
        case .allowExisting:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAccountDefaultDepositRule_lift(_ buf: RustBuffer) throws -> AccountDefaultDepositRule {
    return try FfiConverterTypeAccountDefaultDepositRule.lift(buf)
}

public func FfiConverterTypeAccountDefaultDepositRule_lower(_ value: AccountDefaultDepositRule) -> RustBuffer {
    return FfiConverterTypeAccountDefaultDepositRule.lower(value)
}


extension AccountDefaultDepositRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountDeposit {
    
    case knownFungible(resourceAddress: Address, bounds: SimpleFungibleResourceBounds)
    case knownNonFungible(resourceAddress: Address, bounds: SimpleNonFungibleResourceBounds)
    case unknown
}

public struct FfiConverterTypeAccountDeposit: FfiConverterRustBuffer {
    typealias SwiftType = AccountDeposit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDeposit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .knownFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            bounds: try FfiConverterTypeSimpleFungibleResourceBounds.read(from: &buf)
        )
        
        case 2: return .knownNonFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            bounds: try FfiConverterTypeSimpleNonFungibleResourceBounds.read(from: &buf)
        )
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDeposit, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .knownFungible(resourceAddress,bounds):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleFungibleResourceBounds.write(bounds, into: &buf)
            
        
        case let .knownNonFungible(resourceAddress,bounds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleNonFungibleResourceBounds.write(bounds, into: &buf)
            
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAccountDeposit_lift(_ buf: RustBuffer) throws -> AccountDeposit {
    return try FfiConverterTypeAccountDeposit.lift(buf)
}

public func FfiConverterTypeAccountDeposit_lower(_ value: AccountDeposit) -> RustBuffer {
    return FfiConverterTypeAccountDeposit.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountDepositEvent {
    
    case fungible(resourceAddress: Address, amount: Decimal)
    case nonFungible(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountDepositEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountDepositEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDepositEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .nonFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDepositEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .nonFungible(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountDepositEvent_lift(_ buf: RustBuffer) throws -> AccountDepositEvent {
    return try FfiConverterTypeAccountDepositEvent.lift(buf)
}

public func FfiConverterTypeAccountDepositEvent_lower(_ value: AccountDepositEvent) -> RustBuffer {
    return FfiConverterTypeAccountDepositEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountRejectedDepositEvent {
    
    case fungible(resourceAddress: Address, amount: Decimal)
    case nonFungible(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountRejectedDepositEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountRejectedDepositEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRejectedDepositEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .nonFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountRejectedDepositEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .nonFungible(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountRejectedDepositEvent_lift(_ buf: RustBuffer) throws -> AccountRejectedDepositEvent {
    return try FfiConverterTypeAccountRejectedDepositEvent.lift(buf)
}

public func FfiConverterTypeAccountRejectedDepositEvent_lower(_ value: AccountRejectedDepositEvent) -> RustBuffer {
    return FfiConverterTypeAccountRejectedDepositEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountWithdraw {
    
    case amount(resourceAddress: Address, amount: Decimal)
    case ids(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = AccountWithdraw

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdraw {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .ids(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountWithdraw, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .ids(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountWithdraw_lift(_ buf: RustBuffer) throws -> AccountWithdraw {
    return try FfiConverterTypeAccountWithdraw.lift(buf)
}

public func FfiConverterTypeAccountWithdraw_lower(_ value: AccountWithdraw) -> RustBuffer {
    return FfiConverterTypeAccountWithdraw.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountWithdrawEvent {
    
    case fungible(resourceAddress: Address, amount: Decimal)
    case nonFungible(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountWithdrawEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountWithdrawEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdrawEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .nonFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountWithdrawEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .nonFungible(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountWithdrawEvent_lift(_ buf: RustBuffer) throws -> AccountWithdrawEvent {
    return try FfiConverterTypeAccountWithdrawEvent.lift(buf)
}

public func FfiConverterTypeAccountWithdrawEvent_lower(_ value: AccountWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeAccountWithdrawEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AllowedIds {
    
    case allowlist(ids: [NonFungibleLocalId])
    case any
}

public struct FfiConverterTypeAllowedIds: FfiConverterRustBuffer {
    typealias SwiftType = AllowedIds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AllowedIds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allowlist(
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 2: return .any
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AllowedIds, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .allowlist(ids):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case .any:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAllowedIds_lift(_ buf: RustBuffer) throws -> AllowedIds {
    return try FfiConverterTypeAllowedIds.lift(buf)
}

public func FfiConverterTypeAllowedIds_lower(_ value: AllowedIds) -> RustBuffer {
    return FfiConverterTypeAllowedIds.lower(value)
}


extension AllowedIds: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Curve {
    
    case secp256k1
    case ed25519
}

public struct FfiConverterTypeCurve: FfiConverterRustBuffer {
    typealias SwiftType = Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1
        
        case 2: return .ed25519
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Curve, into buf: inout [UInt8]) {
        switch value {
        
        
        case .secp256k1:
            writeInt(&buf, Int32(1))
        
        
        case .ed25519:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCurve_lift(_ buf: RustBuffer) throws -> Curve {
    return try FfiConverterTypeCurve.lift(buf)
}

public func FfiConverterTypeCurve_lower(_ value: Curve) -> RustBuffer {
    return FfiConverterTypeCurve.lower(value)
}


extension Curve: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CurveTypeV1 {
    
    case ed25519
    case secp256k1
}

public struct FfiConverterTypeCurveTypeV1: FfiConverterRustBuffer {
    typealias SwiftType = CurveTypeV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurveTypeV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519
        
        case 2: return .secp256k1
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CurveTypeV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ed25519:
            writeInt(&buf, Int32(1))
        
        
        case .secp256k1:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCurveTypeV1_lift(_ buf: RustBuffer) throws -> CurveTypeV1 {
    return try FfiConverterTypeCurveTypeV1.lift(buf)
}

public func FfiConverterTypeCurveTypeV1_lower(_ value: CurveTypeV1) -> RustBuffer {
    return FfiConverterTypeCurveTypeV1.lower(value)
}


extension CurveTypeV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CurveTypeV2 {
    
    case ed25519
    case secp256k1
}

public struct FfiConverterTypeCurveTypeV2: FfiConverterRustBuffer {
    typealias SwiftType = CurveTypeV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurveTypeV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519
        
        case 2: return .secp256k1
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CurveTypeV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ed25519:
            writeInt(&buf, Int32(1))
        
        
        case .secp256k1:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCurveTypeV2_lift(_ buf: RustBuffer) throws -> CurveTypeV2 {
    return try FfiConverterTypeCurveTypeV2.lift(buf)
}

public func FfiConverterTypeCurveTypeV2_lower(_ value: CurveTypeV2) -> RustBuffer {
    return FfiConverterTypeCurveTypeV2.lower(value)
}


extension CurveTypeV2: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecryptorsByCurveV1 {
    
    case ed25519(dhEphemeralPublicKey: Ed25519PublicKey, decryptors: [PublicKeyFingerprintV1: Data])
    case secp256k1(dhEphemeralPublicKey: Secp256k1PublicKey, decryptors: [PublicKeyFingerprintV1: Data])
}

public struct FfiConverterTypeDecryptorsByCurveV1: FfiConverterRustBuffer {
    typealias SwiftType = DecryptorsByCurveV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptorsByCurveV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519(
            dhEphemeralPublicKey: try FfiConverterTypeEd25519PublicKey.read(from: &buf), 
            decryptors: try FfiConverterDictionaryTypePublicKeyFingerprintV1Data.read(from: &buf)
        )
        
        case 2: return .secp256k1(
            dhEphemeralPublicKey: try FfiConverterTypeSecp256k1PublicKey.read(from: &buf), 
            decryptors: try FfiConverterDictionaryTypePublicKeyFingerprintV1Data.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptorsByCurveV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ed25519(dhEphemeralPublicKey,decryptors):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionaryTypePublicKeyFingerprintV1Data.write(decryptors, into: &buf)
            
        
        case let .secp256k1(dhEphemeralPublicKey,decryptors):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionaryTypePublicKeyFingerprintV1Data.write(decryptors, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDecryptorsByCurveV1_lift(_ buf: RustBuffer) throws -> DecryptorsByCurveV1 {
    return try FfiConverterTypeDecryptorsByCurveV1.lift(buf)
}

public func FfiConverterTypeDecryptorsByCurveV1_lower(_ value: DecryptorsByCurveV1) -> RustBuffer {
    return FfiConverterTypeDecryptorsByCurveV1.lower(value)
}


extension DecryptorsByCurveV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecryptorsByCurveV2 {
    
    case ed25519(dhEphemeralPublicKey: Ed25519PublicKey, decryptors: [PublicKeyFingerprint: Data])
    case secp256k1(dhEphemeralPublicKey: Secp256k1PublicKey, decryptors: [PublicKeyFingerprint: Data])
}

public struct FfiConverterTypeDecryptorsByCurveV2: FfiConverterRustBuffer {
    typealias SwiftType = DecryptorsByCurveV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptorsByCurveV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519(
            dhEphemeralPublicKey: try FfiConverterTypeEd25519PublicKey.read(from: &buf), 
            decryptors: try FfiConverterDictionaryTypePublicKeyFingerprintData.read(from: &buf)
        )
        
        case 2: return .secp256k1(
            dhEphemeralPublicKey: try FfiConverterTypeSecp256k1PublicKey.read(from: &buf), 
            decryptors: try FfiConverterDictionaryTypePublicKeyFingerprintData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptorsByCurveV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ed25519(dhEphemeralPublicKey,decryptors):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionaryTypePublicKeyFingerprintData.write(decryptors, into: &buf)
            
        
        case let .secp256k1(dhEphemeralPublicKey,decryptors):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(dhEphemeralPublicKey, into: &buf)
            FfiConverterDictionaryTypePublicKeyFingerprintData.write(decryptors, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDecryptorsByCurveV2_lift(_ buf: RustBuffer) throws -> DecryptorsByCurveV2 {
    return try FfiConverterTypeDecryptorsByCurveV2.lift(buf)
}

public func FfiConverterTypeDecryptorsByCurveV2_lower(_ value: DecryptorsByCurveV2) -> RustBuffer {
    return FfiConverterTypeDecryptorsByCurveV2.lower(value)
}


extension DecryptorsByCurveV2: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DependencyInformation {
    
    case version(value: String)
    case tag(value: String)
    case branch(value: String)
    case rev(value: String)
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .version(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .tag(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .branch(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .rev(
            value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .version(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .tag(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .branch(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .rev(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}


extension DependencyInformation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DepositResourceEvent {
    
    case amount(value: Decimal)
    case ids(value: [NonFungibleLocalId])
}

public struct FfiConverterTypeDepositResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = DepositResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .ids(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .ids(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDepositResourceEvent_lift(_ buf: RustBuffer) throws -> DepositResourceEvent {
    return try FfiConverterTypeDepositResourceEvent.lift(buf)
}

public func FfiConverterTypeDepositResourceEvent_lower(_ value: DepositResourceEvent) -> RustBuffer {
    return FfiConverterTypeDepositResourceEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DetailedManifestClass {
    
    case general
    case transfer(isOneToOne: Bool)
    case poolContribution(poolAddresses: [Address], poolContributions: [TrackedPoolContribution])
    case poolRedemption(poolAddresses: [Address], poolRedemptions: [TrackedPoolRedemption])
    case validatorStake(validatorAddresses: [Address], validatorStakes: [TrackedValidatorStake])
    case validatorUnstake(validatorAddresses: [Address], validatorUnstakes: [TrackedValidatorUnstake], claimsNonFungibleData: [UnstakeDataEntry])
    case validatorClaim(validatorAddresses: [Address], validatorClaims: [TrackedValidatorClaim])
    case accountDepositSettingsUpdate(resourcePreferencesUpdates: [String: [String: ResourcePreferenceUpdate]], depositModeUpdates: [String: AccountDefaultDepositRule], authorizedDepositorsAdded: [String: [ResourceOrNonFungible]], authorizedDepositorsRemoved: [String: [ResourceOrNonFungible]])
}

public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .transfer(
            isOneToOne: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .poolContribution(
            poolAddresses: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            poolContributions: try FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf)
        )
        
        case 4: return .poolRedemption(
            poolAddresses: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            poolRedemptions: try FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf)
        )
        
        case 5: return .validatorStake(
            validatorAddresses: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            validatorStakes: try FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf)
        )
        
        case 6: return .validatorUnstake(
            validatorAddresses: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            validatorUnstakes: try FfiConverterSequenceTypeTrackedValidatorUnstake.read(from: &buf), 
            claimsNonFungibleData: try FfiConverterSequenceTypeUnstakeDataEntry.read(from: &buf)
        )
        
        case 7: return .validatorClaim(
            validatorAddresses: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            validatorClaims: try FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf)
        )
        
        case 8: return .accountDepositSettingsUpdate(
            resourcePreferencesUpdates: try FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceUpdate.read(from: &buf), 
            depositModeUpdates: try FfiConverterDictionaryStringTypeAccountDefaultDepositRule.read(from: &buf), 
            authorizedDepositorsAdded: try FfiConverterDictionaryStringSequenceTypeResourceOrNonFungible.read(from: &buf), 
            authorizedDepositorsRemoved: try FfiConverterDictionaryStringSequenceTypeResourceOrNonFungible.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case let .transfer(isOneToOne):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(isOneToOne, into: &buf)
            
        
        case let .poolContribution(poolAddresses,poolContributions):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)
            
        
        case let .poolRedemption(poolAddresses,poolRedemptions):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)
            
        
        case let .validatorStake(validatorAddresses,validatorStakes):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)
            
        
        case let .validatorUnstake(validatorAddresses,validatorUnstakes,claimsNonFungibleData):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorUnstake.write(validatorUnstakes, into: &buf)
            FfiConverterSequenceTypeUnstakeDataEntry.write(claimsNonFungibleData, into: &buf)
            
        
        case let .validatorClaim(validatorAddresses,validatorClaims):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)
            
        
        case let .accountDepositSettingsUpdate(resourcePreferencesUpdates,depositModeUpdates,authorizedDepositorsAdded,authorizedDepositorsRemoved):
            writeInt(&buf, Int32(8))
            FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
            FfiConverterDictionaryStringTypeAccountDefaultDepositRule.write(depositModeUpdates, into: &buf)
            FfiConverterDictionaryStringSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
            FfiConverterDictionaryStringSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
    return try FfiConverterTypeDetailedManifestClass.lift(buf)
}

public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClass.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Emitter {
    
    case function(address: Address, blueprintName: String)
    case method(address: Address, objectModuleId: ModuleId)
}

public struct FfiConverterTypeEmitter: FfiConverterRustBuffer {
    typealias SwiftType = Emitter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emitter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .function(
            address: try FfiConverterTypeAddress.read(from: &buf), 
            blueprintName: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .method(
            address: try FfiConverterTypeAddress.read(from: &buf), 
            objectModuleId: try FfiConverterTypeModuleId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Emitter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .function(address,blueprintName):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(address, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            
        
        case let .method(address,objectModuleId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(address, into: &buf)
            FfiConverterTypeModuleId.write(objectModuleId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEmitter_lift(_ buf: RustBuffer) throws -> Emitter {
    return try FfiConverterTypeEmitter.lift(buf)
}

public func FfiConverterTypeEmitter_lower(_ value: Emitter) -> RustBuffer {
    return FfiConverterTypeEmitter.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EntityType {
    
    case globalPackage
    case globalFungibleResourceManager
    case globalNonFungibleResourceManager
    case globalConsensusManager
    case globalValidator
    case globalAccessController
    case globalAccount
    case globalIdentity
    case globalGenericComponent
    case globalPreallocatedSecp256k1Account
    case globalPreallocatedEd25519Account
    case globalPreallocatedSecp256k1Identity
    case globalPreallocatedEd25519Identity
    case globalOneResourcePool
    case globalTwoResourcePool
    case globalMultiResourcePool
    case globalAccountLocker
    case globalTransactionTracker
    case internalFungibleVault
    case internalNonFungibleVault
    case internalGenericComponent
    case internalKeyValueStore
}

public struct FfiConverterTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = EntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .globalPackage
        
        case 2: return .globalFungibleResourceManager
        
        case 3: return .globalNonFungibleResourceManager
        
        case 4: return .globalConsensusManager
        
        case 5: return .globalValidator
        
        case 6: return .globalAccessController
        
        case 7: return .globalAccount
        
        case 8: return .globalIdentity
        
        case 9: return .globalGenericComponent
        
        case 10: return .globalPreallocatedSecp256k1Account
        
        case 11: return .globalPreallocatedEd25519Account
        
        case 12: return .globalPreallocatedSecp256k1Identity
        
        case 13: return .globalPreallocatedEd25519Identity
        
        case 14: return .globalOneResourcePool
        
        case 15: return .globalTwoResourcePool
        
        case 16: return .globalMultiResourcePool
        
        case 17: return .globalAccountLocker
        
        case 18: return .globalTransactionTracker
        
        case 19: return .internalFungibleVault
        
        case 20: return .internalNonFungibleVault
        
        case 21: return .internalGenericComponent
        
        case 22: return .internalKeyValueStore
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .globalPackage:
            writeInt(&buf, Int32(1))
        
        
        case .globalFungibleResourceManager:
            writeInt(&buf, Int32(2))
        
        
        case .globalNonFungibleResourceManager:
            writeInt(&buf, Int32(3))
        
        
        case .globalConsensusManager:
            writeInt(&buf, Int32(4))
        
        
        case .globalValidator:
            writeInt(&buf, Int32(5))
        
        
        case .globalAccessController:
            writeInt(&buf, Int32(6))
        
        
        case .globalAccount:
            writeInt(&buf, Int32(7))
        
        
        case .globalIdentity:
            writeInt(&buf, Int32(8))
        
        
        case .globalGenericComponent:
            writeInt(&buf, Int32(9))
        
        
        case .globalPreallocatedSecp256k1Account:
            writeInt(&buf, Int32(10))
        
        
        case .globalPreallocatedEd25519Account:
            writeInt(&buf, Int32(11))
        
        
        case .globalPreallocatedSecp256k1Identity:
            writeInt(&buf, Int32(12))
        
        
        case .globalPreallocatedEd25519Identity:
            writeInt(&buf, Int32(13))
        
        
        case .globalOneResourcePool:
            writeInt(&buf, Int32(14))
        
        
        case .globalTwoResourcePool:
            writeInt(&buf, Int32(15))
        
        
        case .globalMultiResourcePool:
            writeInt(&buf, Int32(16))
        
        
        case .globalAccountLocker:
            writeInt(&buf, Int32(17))
        
        
        case .globalTransactionTracker:
            writeInt(&buf, Int32(18))
        
        
        case .internalFungibleVault:
            writeInt(&buf, Int32(19))
        
        
        case .internalNonFungibleVault:
            writeInt(&buf, Int32(20))
        
        
        case .internalGenericComponent:
            writeInt(&buf, Int32(21))
        
        
        case .internalKeyValueStore:
            writeInt(&buf, Int32(22))
        
        }
    }
}


public func FfiConverterTypeEntityType_lift(_ buf: RustBuffer) throws -> EntityType {
    return try FfiConverterTypeEntityType.lift(buf)
}

public func FfiConverterTypeEntityType_lower(_ value: EntityType) -> RustBuffer {
    return FfiConverterTypeEntityType.lower(value)
}


extension EntityType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FungibleResourceIndicator {
    
    case guaranteed(amount: Decimal)
    case predicted(predictedAmount: PredictedDecimal)
}

public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .guaranteed(
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .predicted(
            predictedAmount: try FfiConverterTypePredictedDecimal.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .guaranteed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .predicted(predictedAmount):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
    return try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeFungibleResourceIndicator.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InstructionV1 {
    
    case takeAllFromWorktop(resourceAddress: Address)
    case takeFromWorktop(resourceAddress: Address, amount: Decimal)
    case takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId])
    case returnToWorktop(bucketId: ManifestBucket)
    case assertWorktopContains(resourceAddress: Address, amount: Decimal)
    case assertWorktopContainsAny(resourceAddress: Address)
    case assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case popFromAuthZone
    case pushToAuthZone(proofId: ManifestProof)
    case createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal)
    case createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case createProofFromAuthZoneOfAll(resourceAddress: Address)
    case dropAllProofs
    case dropNamedProofs
    case dropAuthZoneProofs
    case dropAuthZoneRegularProofs
    case dropAuthZoneSignatureProofs
    case createProofFromBucketOfAmount(bucketId: ManifestBucket, amount: Decimal)
    case createProofFromBucketOfNonFungibles(bucketId: ManifestBucket, ids: [NonFungibleLocalId])
    case createProofFromBucketOfAll(bucketId: ManifestBucket)
    case burnResource(bucketId: ManifestBucket)
    case cloneProof(proofId: ManifestProof)
    case dropProof(proofId: ManifestProof)
    case callFunction(packageAddress: ManifestAddress, blueprintName: String, functionName: String, args: ManifestValue)
    case callMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callRoyaltyMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callMetadataMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callRoleAssignmentMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callDirectVaultMethod(address: Address, methodName: String, args: ManifestValue)
    case allocateGlobalAddress(packageAddress: Address, blueprintName: String)
}

public struct FfiConverterTypeInstructionV1: FfiConverterRustBuffer {
    typealias SwiftType = InstructionV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .takeAllFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 2: return .takeFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .takeNonFungiblesFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 4: return .returnToWorktop(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 5: return .assertWorktopContains(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 6: return .assertWorktopContainsAny(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 7: return .assertWorktopContainsNonFungibles(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 8: return .popFromAuthZone
        
        case 9: return .pushToAuthZone(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 10: return .createProofFromAuthZoneOfAmount(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 11: return .createProofFromAuthZoneOfNonFungibles(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 12: return .createProofFromAuthZoneOfAll(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 13: return .dropAllProofs
        
        case 14: return .dropNamedProofs
        
        case 15: return .dropAuthZoneProofs
        
        case 16: return .dropAuthZoneRegularProofs
        
        case 17: return .dropAuthZoneSignatureProofs
        
        case 18: return .createProofFromBucketOfAmount(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 19: return .createProofFromBucketOfNonFungibles(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 20: return .createProofFromBucketOfAll(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 21: return .burnResource(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 22: return .cloneProof(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 23: return .dropProof(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 24: return .callFunction(
            packageAddress: try FfiConverterTypeManifestAddress.read(from: &buf), 
            blueprintName: try FfiConverterString.read(from: &buf), 
            functionName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 25: return .callMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 26: return .callRoyaltyMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 27: return .callMetadataMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 28: return .callRoleAssignmentMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 29: return .callDirectVaultMethod(
            address: try FfiConverterTypeAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 30: return .allocateGlobalAddress(
            packageAddress: try FfiConverterTypeAddress.read(from: &buf), 
            blueprintName: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InstructionV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .takeAllFromWorktop(resourceAddress):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case let .takeFromWorktop(resourceAddress,amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .takeNonFungiblesFromWorktop(resourceAddress,ids):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .returnToWorktop(bucketId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .assertWorktopContains(resourceAddress,amount):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .assertWorktopContainsAny(resourceAddress):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case let .assertWorktopContainsNonFungibles(resourceAddress,ids):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case .popFromAuthZone:
            writeInt(&buf, Int32(8))
        
        
        case let .pushToAuthZone(proofId):
            writeInt(&buf, Int32(9))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .createProofFromAuthZoneOfAmount(resourceAddress,amount):
            writeInt(&buf, Int32(10))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .createProofFromAuthZoneOfNonFungibles(resourceAddress,ids):
            writeInt(&buf, Int32(11))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .createProofFromAuthZoneOfAll(resourceAddress):
            writeInt(&buf, Int32(12))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case .dropAllProofs:
            writeInt(&buf, Int32(13))
        
        
        case .dropNamedProofs:
            writeInt(&buf, Int32(14))
        
        
        case .dropAuthZoneProofs:
            writeInt(&buf, Int32(15))
        
        
        case .dropAuthZoneRegularProofs:
            writeInt(&buf, Int32(16))
        
        
        case .dropAuthZoneSignatureProofs:
            writeInt(&buf, Int32(17))
        
        
        case let .createProofFromBucketOfAmount(bucketId,amount):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .createProofFromBucketOfNonFungibles(bucketId,ids):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .createProofFromBucketOfAll(bucketId):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .burnResource(bucketId):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .cloneProof(proofId):
            writeInt(&buf, Int32(22))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .dropProof(proofId):
            writeInt(&buf, Int32(23))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .callFunction(packageAddress,blueprintName,functionName,args):
            writeInt(&buf, Int32(24))
            FfiConverterTypeManifestAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            FfiConverterString.write(functionName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callMethod(address,methodName,args):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callRoyaltyMethod(address,methodName,args):
            writeInt(&buf, Int32(26))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callMetadataMethod(address,methodName,args):
            writeInt(&buf, Int32(27))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callRoleAssignmentMethod(address,methodName,args):
            writeInt(&buf, Int32(28))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callDirectVaultMethod(address,methodName,args):
            writeInt(&buf, Int32(29))
            FfiConverterTypeAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .allocateGlobalAddress(packageAddress,blueprintName):
            writeInt(&buf, Int32(30))
            FfiConverterTypeAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInstructionV1_lift(_ buf: RustBuffer) throws -> InstructionV1 {
    return try FfiConverterTypeInstructionV1.lift(buf)
}

public func FfiConverterTypeInstructionV1_lower(_ value: InstructionV1) -> RustBuffer {
    return FfiConverterTypeInstructionV1.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InstructionV2 {
    
    case takeAllFromWorktop(resourceAddress: Address)
    case takeFromWorktop(resourceAddress: Address, amount: Decimal)
    case takeNonFungiblesFromWorktop(resourceAddress: Address, ids: [NonFungibleLocalId])
    case returnToWorktop(bucketId: ManifestBucket)
    case assertWorktopContains(resourceAddress: Address, amount: Decimal)
    case assertWorktopContainsAny(resourceAddress: Address)
    case assertWorktopContainsNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case popFromAuthZone
    case pushToAuthZone(proofId: ManifestProof)
    case createProofFromAuthZoneOfAmount(resourceAddress: Address, amount: Decimal)
    case createProofFromAuthZoneOfNonFungibles(resourceAddress: Address, ids: [NonFungibleLocalId])
    case createProofFromAuthZoneOfAll(resourceAddress: Address)
    case dropAllProofs
    case dropNamedProofs
    case dropAuthZoneProofs
    case dropAuthZoneRegularProofs
    case dropAuthZoneSignatureProofs
    case createProofFromBucketOfAmount(bucketId: ManifestBucket, amount: Decimal)
    case createProofFromBucketOfNonFungibles(bucketId: ManifestBucket, ids: [NonFungibleLocalId])
    case createProofFromBucketOfAll(bucketId: ManifestBucket)
    case burnResource(bucketId: ManifestBucket)
    case cloneProof(proofId: ManifestProof)
    case dropProof(proofId: ManifestProof)
    case callFunction(packageAddress: ManifestAddress, blueprintName: String, functionName: String, args: ManifestValue)
    case callMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callRoyaltyMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callMetadataMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callRoleAssignmentMethod(address: ManifestAddress, methodName: String, args: ManifestValue)
    case callDirectVaultMethod(address: Address, methodName: String, args: ManifestValue)
    case allocateGlobalAddress(packageAddress: Address, blueprintName: String)
    case yieldToParent(args: ManifestValue)
    case yieldToChild(childIndex: UInt32, args: ManifestValue)
    case verifyParent(accessRule: AccessRule)
    case assertWorktopResourcesOnly(constraints: [String: ManifestResourceConstraint])
    case assertWorktopResourcesInclude(constraints: [String: ManifestResourceConstraint])
    case assertNextCallReturnsOnly(constraints: [String: ManifestResourceConstraint])
    case assertNextCallReturnsInclude(constraints: [String: ManifestResourceConstraint])
    case assertBucketContents(bucketId: ManifestBucket, constraint: ManifestResourceConstraint)
}

public struct FfiConverterTypeInstructionV2: FfiConverterRustBuffer {
    typealias SwiftType = InstructionV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .takeAllFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 2: return .takeFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .takeNonFungiblesFromWorktop(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 4: return .returnToWorktop(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 5: return .assertWorktopContains(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 6: return .assertWorktopContainsAny(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 7: return .assertWorktopContainsNonFungibles(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 8: return .popFromAuthZone
        
        case 9: return .pushToAuthZone(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 10: return .createProofFromAuthZoneOfAmount(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 11: return .createProofFromAuthZoneOfNonFungibles(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 12: return .createProofFromAuthZoneOfAll(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 13: return .dropAllProofs
        
        case 14: return .dropNamedProofs
        
        case 15: return .dropAuthZoneProofs
        
        case 16: return .dropAuthZoneRegularProofs
        
        case 17: return .dropAuthZoneSignatureProofs
        
        case 18: return .createProofFromBucketOfAmount(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 19: return .createProofFromBucketOfNonFungibles(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 20: return .createProofFromBucketOfAll(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 21: return .burnResource(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 22: return .cloneProof(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 23: return .dropProof(
            proofId: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 24: return .callFunction(
            packageAddress: try FfiConverterTypeManifestAddress.read(from: &buf), 
            blueprintName: try FfiConverterString.read(from: &buf), 
            functionName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 25: return .callMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 26: return .callRoyaltyMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 27: return .callMetadataMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 28: return .callRoleAssignmentMethod(
            address: try FfiConverterTypeManifestAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 29: return .callDirectVaultMethod(
            address: try FfiConverterTypeAddress.read(from: &buf), 
            methodName: try FfiConverterString.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 30: return .allocateGlobalAddress(
            packageAddress: try FfiConverterTypeAddress.read(from: &buf), 
            blueprintName: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .yieldToParent(
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 32: return .yieldToChild(
            childIndex: try FfiConverterUInt32.read(from: &buf), 
            args: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 33: return .verifyParent(
            accessRule: try FfiConverterTypeAccessRule.read(from: &buf)
        )
        
        case 34: return .assertWorktopResourcesOnly(
            constraints: try FfiConverterDictionaryStringTypeManifestResourceConstraint.read(from: &buf)
        )
        
        case 35: return .assertWorktopResourcesInclude(
            constraints: try FfiConverterDictionaryStringTypeManifestResourceConstraint.read(from: &buf)
        )
        
        case 36: return .assertNextCallReturnsOnly(
            constraints: try FfiConverterDictionaryStringTypeManifestResourceConstraint.read(from: &buf)
        )
        
        case 37: return .assertNextCallReturnsInclude(
            constraints: try FfiConverterDictionaryStringTypeManifestResourceConstraint.read(from: &buf)
        )
        
        case 38: return .assertBucketContents(
            bucketId: try FfiConverterTypeManifestBucket.read(from: &buf), 
            constraint: try FfiConverterTypeManifestResourceConstraint.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InstructionV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .takeAllFromWorktop(resourceAddress):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case let .takeFromWorktop(resourceAddress,amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .takeNonFungiblesFromWorktop(resourceAddress,ids):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .returnToWorktop(bucketId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .assertWorktopContains(resourceAddress,amount):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .assertWorktopContainsAny(resourceAddress):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case let .assertWorktopContainsNonFungibles(resourceAddress,ids):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case .popFromAuthZone:
            writeInt(&buf, Int32(8))
        
        
        case let .pushToAuthZone(proofId):
            writeInt(&buf, Int32(9))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .createProofFromAuthZoneOfAmount(resourceAddress,amount):
            writeInt(&buf, Int32(10))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .createProofFromAuthZoneOfNonFungibles(resourceAddress,ids):
            writeInt(&buf, Int32(11))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .createProofFromAuthZoneOfAll(resourceAddress):
            writeInt(&buf, Int32(12))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            
        
        case .dropAllProofs:
            writeInt(&buf, Int32(13))
        
        
        case .dropNamedProofs:
            writeInt(&buf, Int32(14))
        
        
        case .dropAuthZoneProofs:
            writeInt(&buf, Int32(15))
        
        
        case .dropAuthZoneRegularProofs:
            writeInt(&buf, Int32(16))
        
        
        case .dropAuthZoneSignatureProofs:
            writeInt(&buf, Int32(17))
        
        
        case let .createProofFromBucketOfAmount(bucketId,amount):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .createProofFromBucketOfNonFungibles(bucketId,ids):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .createProofFromBucketOfAll(bucketId):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .burnResource(bucketId):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            
        
        case let .cloneProof(proofId):
            writeInt(&buf, Int32(22))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .dropProof(proofId):
            writeInt(&buf, Int32(23))
            FfiConverterTypeManifestProof.write(proofId, into: &buf)
            
        
        case let .callFunction(packageAddress,blueprintName,functionName,args):
            writeInt(&buf, Int32(24))
            FfiConverterTypeManifestAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            FfiConverterString.write(functionName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callMethod(address,methodName,args):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callRoyaltyMethod(address,methodName,args):
            writeInt(&buf, Int32(26))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callMetadataMethod(address,methodName,args):
            writeInt(&buf, Int32(27))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callRoleAssignmentMethod(address,methodName,args):
            writeInt(&buf, Int32(28))
            FfiConverterTypeManifestAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .callDirectVaultMethod(address,methodName,args):
            writeInt(&buf, Int32(29))
            FfiConverterTypeAddress.write(address, into: &buf)
            FfiConverterString.write(methodName, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .allocateGlobalAddress(packageAddress,blueprintName):
            writeInt(&buf, Int32(30))
            FfiConverterTypeAddress.write(packageAddress, into: &buf)
            FfiConverterString.write(blueprintName, into: &buf)
            
        
        case let .yieldToParent(args):
            writeInt(&buf, Int32(31))
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .yieldToChild(childIndex,args):
            writeInt(&buf, Int32(32))
            FfiConverterUInt32.write(childIndex, into: &buf)
            FfiConverterTypeManifestValue.write(args, into: &buf)
            
        
        case let .verifyParent(accessRule):
            writeInt(&buf, Int32(33))
            FfiConverterTypeAccessRule.write(accessRule, into: &buf)
            
        
        case let .assertWorktopResourcesOnly(constraints):
            writeInt(&buf, Int32(34))
            FfiConverterDictionaryStringTypeManifestResourceConstraint.write(constraints, into: &buf)
            
        
        case let .assertWorktopResourcesInclude(constraints):
            writeInt(&buf, Int32(35))
            FfiConverterDictionaryStringTypeManifestResourceConstraint.write(constraints, into: &buf)
            
        
        case let .assertNextCallReturnsOnly(constraints):
            writeInt(&buf, Int32(36))
            FfiConverterDictionaryStringTypeManifestResourceConstraint.write(constraints, into: &buf)
            
        
        case let .assertNextCallReturnsInclude(constraints):
            writeInt(&buf, Int32(37))
            FfiConverterDictionaryStringTypeManifestResourceConstraint.write(constraints, into: &buf)
            
        
        case let .assertBucketContents(bucketId,constraint):
            writeInt(&buf, Int32(38))
            FfiConverterTypeManifestBucket.write(bucketId, into: &buf)
            FfiConverterTypeManifestResourceConstraint.write(constraint, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInstructionV2_lift(_ buf: RustBuffer) throws -> InstructionV2 {
    return try FfiConverterTypeInstructionV2.lift(buf)
}

public func FfiConverterTypeInstructionV2_lower(_ value: InstructionV2) -> RustBuffer {
    return FfiConverterTypeInstructionV2.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTypeId {
    
    case wellKnown(value: UInt8)
    case schemaLocalIndex(value: UInt64)
}

public struct FfiConverterTypeLocalTypeId: FfiConverterRustBuffer {
    typealias SwiftType = LocalTypeId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalTypeId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .wellKnown(
            value: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 2: return .schemaLocalIndex(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LocalTypeId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .wellKnown(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt8.write(value, into: &buf)
            
        
        case let .schemaLocalIndex(value):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLocalTypeId_lift(_ buf: RustBuffer) throws -> LocalTypeId {
    return try FfiConverterTypeLocalTypeId.lift(buf)
}

public func FfiConverterTypeLocalTypeId_lower(_ value: LocalTypeId) -> RustBuffer {
    return FfiConverterTypeLocalTypeId.lower(value)
}


extension LocalTypeId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LowerBound {
    
    case nonZero
    case inclusive(value: Decimal)
}

public struct FfiConverterTypeLowerBound: FfiConverterRustBuffer {
    typealias SwiftType = LowerBound

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LowerBound {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonZero
        
        case 2: return .inclusive(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LowerBound, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nonZero:
            writeInt(&buf, Int32(1))
        
        
        case let .inclusive(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLowerBound_lift(_ buf: RustBuffer) throws -> LowerBound {
    return try FfiConverterTypeLowerBound.lift(buf)
}

public func FfiConverterTypeLowerBound_lower(_ value: LowerBound) -> RustBuffer {
    return FfiConverterTypeLowerBound.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestAddress {
    
    case named(value: UInt32)
    case `static`(value: Address)
}

public struct FfiConverterTypeManifestAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .named(
            value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .`static`(
            value: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestAddress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .named(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .`static`(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestAddress_lift(_ buf: RustBuffer) throws -> ManifestAddress {
    return try FfiConverterTypeManifestAddress.lift(buf)
}

public func FfiConverterTypeManifestAddress_lower(_ value: ManifestAddress) -> RustBuffer {
    return FfiConverterTypeManifestAddress.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderAddress {
    
    case named(value: ManifestBuilderNamedAddress)
    case `static`(value: Address)
}

public struct FfiConverterTypeManifestBuilderAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .named(
            value: try FfiConverterTypeManifestBuilderNamedAddress.read(from: &buf)
        )
        
        case 2: return .`static`(
            value: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderAddress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .named(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeManifestBuilderNamedAddress.write(value, into: &buf)
            
        
        case let .`static`(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestBuilderAddress_lift(_ buf: RustBuffer) throws -> ManifestBuilderAddress {
    return try FfiConverterTypeManifestBuilderAddress.lift(buf)
}

public func FfiConverterTypeManifestBuilderAddress_lower(_ value: ManifestBuilderAddress) -> RustBuffer {
    return FfiConverterTypeManifestBuilderAddress.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderValue {
    
    case boolValue(value: Bool)
    case i8Value(value: Int8)
    case i16Value(value: Int16)
    case i32Value(value: Int32)
    case i64Value(value: Int64)
    case i128Value(value: String)
    case u8Value(value: UInt8)
    case u16Value(value: UInt16)
    case u32Value(value: UInt32)
    case u64Value(value: UInt64)
    case u128Value(value: String)
    case stringValue(value: String)
    case enumValue(discriminator: UInt8, fields: [ManifestBuilderValue])
    case arrayValue(elementValueKind: ManifestBuilderValueKind, elements: [ManifestBuilderValue])
    case tupleValue(fields: [ManifestBuilderValue])
    case mapValue(keyValueKind: ManifestBuilderValueKind, valueValueKind: ManifestBuilderValueKind, entries: [ManifestBuilderMapEntry])
    case addressValue(value: ManifestBuilderAddress)
    case bucketValue(value: ManifestBuilderBucket)
    case proofValue(value: ManifestBuilderProof)
    case expressionValue(value: ManifestExpression)
    case blobValue(value: ManifestBlobRef)
    case decimalValue(value: Decimal)
    case preciseDecimalValue(value: PreciseDecimal)
    case nonFungibleLocalIdValue(value: NonFungibleLocalId)
    case addressReservationValue(value: ManifestBuilderAddressReservation)
}

public struct FfiConverterTypeManifestBuilderValue: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .boolValue(
            value: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .i8Value(
            value: try FfiConverterInt8.read(from: &buf)
        )
        
        case 3: return .i16Value(
            value: try FfiConverterInt16.read(from: &buf)
        )
        
        case 4: return .i32Value(
            value: try FfiConverterInt32.read(from: &buf)
        )
        
        case 5: return .i64Value(
            value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 6: return .i128Value(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .u8Value(
            value: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 8: return .u16Value(
            value: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 9: return .u32Value(
            value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .u64Value(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 11: return .u128Value(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .stringValue(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .enumValue(
            discriminator: try FfiConverterUInt8.read(from: &buf), 
            fields: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 14: return .arrayValue(
            elementValueKind: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            elements: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 15: return .tupleValue(
            fields: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 16: return .mapValue(
            keyValueKind: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            valueValueKind: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            entries: try FfiConverterSequenceTypeManifestBuilderMapEntry.read(from: &buf)
        )
        
        case 17: return .addressValue(
            value: try FfiConverterTypeManifestBuilderAddress.read(from: &buf)
        )
        
        case 18: return .bucketValue(
            value: try FfiConverterTypeManifestBuilderBucket.read(from: &buf)
        )
        
        case 19: return .proofValue(
            value: try FfiConverterTypeManifestBuilderProof.read(from: &buf)
        )
        
        case 20: return .expressionValue(
            value: try FfiConverterTypeManifestExpression.read(from: &buf)
        )
        
        case 21: return .blobValue(
            value: try FfiConverterTypeManifestBlobRef.read(from: &buf)
        )
        
        case 22: return .decimalValue(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 23: return .preciseDecimalValue(
            value: try FfiConverterTypePreciseDecimal.read(from: &buf)
        )
        
        case 24: return .nonFungibleLocalIdValue(
            value: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 25: return .addressReservationValue(
            value: try FfiConverterTypeManifestBuilderAddressReservation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .boolValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .i8Value(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(value, into: &buf)
            
        
        case let .i16Value(value):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(value, into: &buf)
            
        
        case let .i32Value(value):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(value, into: &buf)
            
        
        case let .i64Value(value):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .i128Value(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .u8Value(value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(value, into: &buf)
            
        
        case let .u16Value(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(value, into: &buf)
            
        
        case let .u32Value(value):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .u64Value(value):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .u128Value(value):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .stringValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .enumValue(discriminator,fields):
            writeInt(&buf, Int32(13))
            FfiConverterUInt8.write(discriminator, into: &buf)
            FfiConverterSequenceTypeManifestBuilderValue.write(fields, into: &buf)
            
        
        case let .arrayValue(elementValueKind,elements):
            writeInt(&buf, Int32(14))
            FfiConverterTypeManifestBuilderValueKind.write(elementValueKind, into: &buf)
            FfiConverterSequenceTypeManifestBuilderValue.write(elements, into: &buf)
            
        
        case let .tupleValue(fields):
            writeInt(&buf, Int32(15))
            FfiConverterSequenceTypeManifestBuilderValue.write(fields, into: &buf)
            
        
        case let .mapValue(keyValueKind,valueValueKind,entries):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestBuilderValueKind.write(keyValueKind, into: &buf)
            FfiConverterTypeManifestBuilderValueKind.write(valueValueKind, into: &buf)
            FfiConverterSequenceTypeManifestBuilderMapEntry.write(entries, into: &buf)
            
        
        case let .addressValue(value):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestBuilderAddress.write(value, into: &buf)
            
        
        case let .bucketValue(value):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBuilderBucket.write(value, into: &buf)
            
        
        case let .proofValue(value):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestBuilderProof.write(value, into: &buf)
            
        
        case let .expressionValue(value):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestExpression.write(value, into: &buf)
            
        
        case let .blobValue(value):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBlobRef.write(value, into: &buf)
            
        
        case let .decimalValue(value):
            writeInt(&buf, Int32(22))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .preciseDecimalValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterTypePreciseDecimal.write(value, into: &buf)
            
        
        case let .nonFungibleLocalIdValue(value):
            writeInt(&buf, Int32(24))
            FfiConverterTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .addressReservationValue(value):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestBuilderAddressReservation.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestBuilderValue_lift(_ buf: RustBuffer) throws -> ManifestBuilderValue {
    return try FfiConverterTypeManifestBuilderValue.lift(buf)
}

public func FfiConverterTypeManifestBuilderValue_lower(_ value: ManifestBuilderValue) -> RustBuffer {
    return FfiConverterTypeManifestBuilderValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderValueKind {
    
    case boolValue
    case i8Value
    case i16Value
    case i32Value
    case i64Value
    case i128Value
    case u8Value
    case u16Value
    case u32Value
    case u64Value
    case u128Value
    case stringValue
    case enumValue
    case arrayValue
    case tupleValue
    case mapValue
    case addressValue
    case bucketValue
    case proofValue
    case expressionValue
    case blobValue
    case decimalValue
    case preciseDecimalValue
    case nonFungibleLocalIdValue
    case addressReservationValue
}

public struct FfiConverterTypeManifestBuilderValueKind: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderValueKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderValueKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .boolValue
        
        case 2: return .i8Value
        
        case 3: return .i16Value
        
        case 4: return .i32Value
        
        case 5: return .i64Value
        
        case 6: return .i128Value
        
        case 7: return .u8Value
        
        case 8: return .u16Value
        
        case 9: return .u32Value
        
        case 10: return .u64Value
        
        case 11: return .u128Value
        
        case 12: return .stringValue
        
        case 13: return .enumValue
        
        case 14: return .arrayValue
        
        case 15: return .tupleValue
        
        case 16: return .mapValue
        
        case 17: return .addressValue
        
        case 18: return .bucketValue
        
        case 19: return .proofValue
        
        case 20: return .expressionValue
        
        case 21: return .blobValue
        
        case 22: return .decimalValue
        
        case 23: return .preciseDecimalValue
        
        case 24: return .nonFungibleLocalIdValue
        
        case 25: return .addressReservationValue
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderValueKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .boolValue:
            writeInt(&buf, Int32(1))
        
        
        case .i8Value:
            writeInt(&buf, Int32(2))
        
        
        case .i16Value:
            writeInt(&buf, Int32(3))
        
        
        case .i32Value:
            writeInt(&buf, Int32(4))
        
        
        case .i64Value:
            writeInt(&buf, Int32(5))
        
        
        case .i128Value:
            writeInt(&buf, Int32(6))
        
        
        case .u8Value:
            writeInt(&buf, Int32(7))
        
        
        case .u16Value:
            writeInt(&buf, Int32(8))
        
        
        case .u32Value:
            writeInt(&buf, Int32(9))
        
        
        case .u64Value:
            writeInt(&buf, Int32(10))
        
        
        case .u128Value:
            writeInt(&buf, Int32(11))
        
        
        case .stringValue:
            writeInt(&buf, Int32(12))
        
        
        case .enumValue:
            writeInt(&buf, Int32(13))
        
        
        case .arrayValue:
            writeInt(&buf, Int32(14))
        
        
        case .tupleValue:
            writeInt(&buf, Int32(15))
        
        
        case .mapValue:
            writeInt(&buf, Int32(16))
        
        
        case .addressValue:
            writeInt(&buf, Int32(17))
        
        
        case .bucketValue:
            writeInt(&buf, Int32(18))
        
        
        case .proofValue:
            writeInt(&buf, Int32(19))
        
        
        case .expressionValue:
            writeInt(&buf, Int32(20))
        
        
        case .blobValue:
            writeInt(&buf, Int32(21))
        
        
        case .decimalValue:
            writeInt(&buf, Int32(22))
        
        
        case .preciseDecimalValue:
            writeInt(&buf, Int32(23))
        
        
        case .nonFungibleLocalIdValue:
            writeInt(&buf, Int32(24))
        
        
        case .addressReservationValue:
            writeInt(&buf, Int32(25))
        
        }
    }
}


public func FfiConverterTypeManifestBuilderValueKind_lift(_ buf: RustBuffer) throws -> ManifestBuilderValueKind {
    return try FfiConverterTypeManifestBuilderValueKind.lift(buf)
}

public func FfiConverterTypeManifestBuilderValueKind_lower(_ value: ManifestBuilderValueKind) -> RustBuffer {
    return FfiConverterTypeManifestBuilderValueKind.lower(value)
}


extension ManifestBuilderValueKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestClass {
    
    case general
    case transfer
    case poolContribution
    case poolRedemption
    case validatorStake
    case validatorUnstake
    case validatorClaim
    case accountDepositSettingsUpdate
}

public struct FfiConverterTypeManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = ManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .transfer
        
        case 3: return .poolContribution
        
        case 4: return .poolRedemption
        
        case 5: return .validatorStake
        
        case 6: return .validatorUnstake
        
        case 7: return .validatorClaim
        
        case 8: return .accountDepositSettingsUpdate
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestClass, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case .transfer:
            writeInt(&buf, Int32(2))
        
        
        case .poolContribution:
            writeInt(&buf, Int32(3))
        
        
        case .poolRedemption:
            writeInt(&buf, Int32(4))
        
        
        case .validatorStake:
            writeInt(&buf, Int32(5))
        
        
        case .validatorUnstake:
            writeInt(&buf, Int32(6))
        
        
        case .validatorClaim:
            writeInt(&buf, Int32(7))
        
        
        case .accountDepositSettingsUpdate:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeManifestClass_lift(_ buf: RustBuffer) throws -> ManifestClass {
    return try FfiConverterTypeManifestClass.lift(buf)
}

public func FfiConverterTypeManifestClass_lower(_ value: ManifestClass) -> RustBuffer {
    return FfiConverterTypeManifestClass.lower(value)
}


extension ManifestClass: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestExpression {
    
    case entireWorktop
    case entireAuthZone
}

public struct FfiConverterTypeManifestExpression: FfiConverterRustBuffer {
    typealias SwiftType = ManifestExpression

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestExpression {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .entireWorktop
        
        case 2: return .entireAuthZone
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestExpression, into buf: inout [UInt8]) {
        switch value {
        
        
        case .entireWorktop:
            writeInt(&buf, Int32(1))
        
        
        case .entireAuthZone:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeManifestExpression_lift(_ buf: RustBuffer) throws -> ManifestExpression {
    return try FfiConverterTypeManifestExpression.lift(buf)
}

public func FfiConverterTypeManifestExpression_lower(_ value: ManifestExpression) -> RustBuffer {
    return FfiConverterTypeManifestExpression.lower(value)
}


extension ManifestExpression: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestResourceConstraint {
    
    case nonZeroAmount
    case exactAmount(value: Decimal)
    case atLeastAmount(value: Decimal)
    case exactNonFungibles(value: [NonFungibleLocalId])
    case atLeastNonFungibles(value: [NonFungibleLocalId])
    case general(value: GeneralResourceConstraint)
}

public struct FfiConverterTypeManifestResourceConstraint: FfiConverterRustBuffer {
    typealias SwiftType = ManifestResourceConstraint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestResourceConstraint {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonZeroAmount
        
        case 2: return .exactAmount(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .atLeastAmount(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 4: return .exactNonFungibles(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 5: return .atLeastNonFungibles(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 6: return .general(
            value: try FfiConverterTypeGeneralResourceConstraint.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestResourceConstraint, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nonZeroAmount:
            writeInt(&buf, Int32(1))
        
        
        case let .exactAmount(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .atLeastAmount(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .exactNonFungibles(value):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .atLeastNonFungibles(value):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .general(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeGeneralResourceConstraint.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestResourceConstraint_lift(_ buf: RustBuffer) throws -> ManifestResourceConstraint {
    return try FfiConverterTypeManifestResourceConstraint.lift(buf)
}

public func FfiConverterTypeManifestResourceConstraint_lower(_ value: ManifestResourceConstraint) -> RustBuffer {
    return FfiConverterTypeManifestResourceConstraint.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestSborStringRepresentation {
    
    case manifestString
    case json(value: SerializationMode)
}

public struct FfiConverterTypeManifestSborStringRepresentation: FfiConverterRustBuffer {
    typealias SwiftType = ManifestSborStringRepresentation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSborStringRepresentation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .manifestString
        
        case 2: return .json(
            value: try FfiConverterTypeSerializationMode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestSborStringRepresentation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .manifestString:
            writeInt(&buf, Int32(1))
        
        
        case let .json(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSerializationMode.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestSborStringRepresentation_lift(_ buf: RustBuffer) throws -> ManifestSborStringRepresentation {
    return try FfiConverterTypeManifestSborStringRepresentation.lift(buf)
}

public func FfiConverterTypeManifestSborStringRepresentation_lower(_ value: ManifestSborStringRepresentation) -> RustBuffer {
    return FfiConverterTypeManifestSborStringRepresentation.lower(value)
}


extension ManifestSborStringRepresentation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValue {
    
    case boolValue(value: Bool)
    case i8Value(value: Int8)
    case i16Value(value: Int16)
    case i32Value(value: Int32)
    case i64Value(value: Int64)
    case i128Value(value: String)
    case u8Value(value: UInt8)
    case u16Value(value: UInt16)
    case u32Value(value: UInt32)
    case u64Value(value: UInt64)
    case u128Value(value: String)
    case stringValue(value: String)
    case enumValue(discriminator: UInt8, fields: [ManifestValue])
    case arrayValue(elementValueKind: ManifestValueKind, elements: [ManifestValue])
    case tupleValue(fields: [ManifestValue])
    case mapValue(keyValueKind: ManifestValueKind, valueValueKind: ManifestValueKind, entries: [MapEntry])
    case addressValue(value: ManifestAddress)
    case bucketValue(value: ManifestBucket)
    case proofValue(value: ManifestProof)
    case expressionValue(value: ManifestExpression)
    case blobValue(value: ManifestBlobRef)
    case decimalValue(value: Decimal)
    case preciseDecimalValue(value: PreciseDecimal)
    case nonFungibleLocalIdValue(value: NonFungibleLocalId)
    case addressReservationValue(value: ManifestAddressReservation)
}

public struct FfiConverterTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .boolValue(
            value: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .i8Value(
            value: try FfiConverterInt8.read(from: &buf)
        )
        
        case 3: return .i16Value(
            value: try FfiConverterInt16.read(from: &buf)
        )
        
        case 4: return .i32Value(
            value: try FfiConverterInt32.read(from: &buf)
        )
        
        case 5: return .i64Value(
            value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 6: return .i128Value(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .u8Value(
            value: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 8: return .u16Value(
            value: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 9: return .u32Value(
            value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .u64Value(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 11: return .u128Value(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .stringValue(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .enumValue(
            discriminator: try FfiConverterUInt8.read(from: &buf), 
            fields: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 14: return .arrayValue(
            elementValueKind: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            elements: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 15: return .tupleValue(
            fields: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 16: return .mapValue(
            keyValueKind: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            valueValueKind: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            entries: try FfiConverterSequenceTypeMapEntry.read(from: &buf)
        )
        
        case 17: return .addressValue(
            value: try FfiConverterTypeManifestAddress.read(from: &buf)
        )
        
        case 18: return .bucketValue(
            value: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 19: return .proofValue(
            value: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 20: return .expressionValue(
            value: try FfiConverterTypeManifestExpression.read(from: &buf)
        )
        
        case 21: return .blobValue(
            value: try FfiConverterTypeManifestBlobRef.read(from: &buf)
        )
        
        case 22: return .decimalValue(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 23: return .preciseDecimalValue(
            value: try FfiConverterTypePreciseDecimal.read(from: &buf)
        )
        
        case 24: return .nonFungibleLocalIdValue(
            value: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 25: return .addressReservationValue(
            value: try FfiConverterTypeManifestAddressReservation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .boolValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .i8Value(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(value, into: &buf)
            
        
        case let .i16Value(value):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(value, into: &buf)
            
        
        case let .i32Value(value):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(value, into: &buf)
            
        
        case let .i64Value(value):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .i128Value(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .u8Value(value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(value, into: &buf)
            
        
        case let .u16Value(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(value, into: &buf)
            
        
        case let .u32Value(value):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .u64Value(value):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .u128Value(value):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .stringValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .enumValue(discriminator,fields):
            writeInt(&buf, Int32(13))
            FfiConverterUInt8.write(discriminator, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(fields, into: &buf)
            
        
        case let .arrayValue(elementValueKind,elements):
            writeInt(&buf, Int32(14))
            FfiConverterTypeManifestValueKind.write(elementValueKind, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(elements, into: &buf)
            
        
        case let .tupleValue(fields):
            writeInt(&buf, Int32(15))
            FfiConverterSequenceTypeManifestValue.write(fields, into: &buf)
            
        
        case let .mapValue(keyValueKind,valueValueKind,entries):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestValueKind.write(keyValueKind, into: &buf)
            FfiConverterTypeManifestValueKind.write(valueValueKind, into: &buf)
            FfiConverterSequenceTypeMapEntry.write(entries, into: &buf)
            
        
        case let .addressValue(value):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestAddress.write(value, into: &buf)
            
        
        case let .bucketValue(value):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(value, into: &buf)
            
        
        case let .proofValue(value):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestProof.write(value, into: &buf)
            
        
        case let .expressionValue(value):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestExpression.write(value, into: &buf)
            
        
        case let .blobValue(value):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBlobRef.write(value, into: &buf)
            
        
        case let .decimalValue(value):
            writeInt(&buf, Int32(22))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .preciseDecimalValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterTypePreciseDecimal.write(value, into: &buf)
            
        
        case let .nonFungibleLocalIdValue(value):
            writeInt(&buf, Int32(24))
            FfiConverterTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .addressReservationValue(value):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddressReservation.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestValue_lift(_ buf: RustBuffer) throws -> ManifestValue {
    return try FfiConverterTypeManifestValue.lift(buf)
}

public func FfiConverterTypeManifestValue_lower(_ value: ManifestValue) -> RustBuffer {
    return FfiConverterTypeManifestValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValueKind {
    
    case boolValue
    case i8Value
    case i16Value
    case i32Value
    case i64Value
    case i128Value
    case u8Value
    case u16Value
    case u32Value
    case u64Value
    case u128Value
    case stringValue
    case enumValue
    case arrayValue
    case tupleValue
    case mapValue
    case addressValue
    case bucketValue
    case proofValue
    case expressionValue
    case blobValue
    case decimalValue
    case preciseDecimalValue
    case nonFungibleLocalIdValue
    case addressReservationValue
}

public struct FfiConverterTypeManifestValueKind: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValueKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValueKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .boolValue
        
        case 2: return .i8Value
        
        case 3: return .i16Value
        
        case 4: return .i32Value
        
        case 5: return .i64Value
        
        case 6: return .i128Value
        
        case 7: return .u8Value
        
        case 8: return .u16Value
        
        case 9: return .u32Value
        
        case 10: return .u64Value
        
        case 11: return .u128Value
        
        case 12: return .stringValue
        
        case 13: return .enumValue
        
        case 14: return .arrayValue
        
        case 15: return .tupleValue
        
        case 16: return .mapValue
        
        case 17: return .addressValue
        
        case 18: return .bucketValue
        
        case 19: return .proofValue
        
        case 20: return .expressionValue
        
        case 21: return .blobValue
        
        case 22: return .decimalValue
        
        case 23: return .preciseDecimalValue
        
        case 24: return .nonFungibleLocalIdValue
        
        case 25: return .addressReservationValue
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValueKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .boolValue:
            writeInt(&buf, Int32(1))
        
        
        case .i8Value:
            writeInt(&buf, Int32(2))
        
        
        case .i16Value:
            writeInt(&buf, Int32(3))
        
        
        case .i32Value:
            writeInt(&buf, Int32(4))
        
        
        case .i64Value:
            writeInt(&buf, Int32(5))
        
        
        case .i128Value:
            writeInt(&buf, Int32(6))
        
        
        case .u8Value:
            writeInt(&buf, Int32(7))
        
        
        case .u16Value:
            writeInt(&buf, Int32(8))
        
        
        case .u32Value:
            writeInt(&buf, Int32(9))
        
        
        case .u64Value:
            writeInt(&buf, Int32(10))
        
        
        case .u128Value:
            writeInt(&buf, Int32(11))
        
        
        case .stringValue:
            writeInt(&buf, Int32(12))
        
        
        case .enumValue:
            writeInt(&buf, Int32(13))
        
        
        case .arrayValue:
            writeInt(&buf, Int32(14))
        
        
        case .tupleValue:
            writeInt(&buf, Int32(15))
        
        
        case .mapValue:
            writeInt(&buf, Int32(16))
        
        
        case .addressValue:
            writeInt(&buf, Int32(17))
        
        
        case .bucketValue:
            writeInt(&buf, Int32(18))
        
        
        case .proofValue:
            writeInt(&buf, Int32(19))
        
        
        case .expressionValue:
            writeInt(&buf, Int32(20))
        
        
        case .blobValue:
            writeInt(&buf, Int32(21))
        
        
        case .decimalValue:
            writeInt(&buf, Int32(22))
        
        
        case .preciseDecimalValue:
            writeInt(&buf, Int32(23))
        
        
        case .nonFungibleLocalIdValue:
            writeInt(&buf, Int32(24))
        
        
        case .addressReservationValue:
            writeInt(&buf, Int32(25))
        
        }
    }
}


public func FfiConverterTypeManifestValueKind_lift(_ buf: RustBuffer) throws -> ManifestValueKind {
    return try FfiConverterTypeManifestValueKind.lift(buf)
}

public func FfiConverterTypeManifestValueKind_lower(_ value: ManifestValueKind) -> RustBuffer {
    return FfiConverterTypeManifestValueKind.lower(value)
}


extension ManifestValueKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageContentV1 {
    
    case str(value: String)
    case bytes(value: Data)
}

public struct FfiConverterTypeMessageContentV1: FfiConverterRustBuffer {
    typealias SwiftType = MessageContentV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContentV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .str(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .bytes(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContentV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .str(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .bytes(value):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageContentV1_lift(_ buf: RustBuffer) throws -> MessageContentV1 {
    return try FfiConverterTypeMessageContentV1.lift(buf)
}

public func FfiConverterTypeMessageContentV1_lower(_ value: MessageContentV1) -> RustBuffer {
    return FfiConverterTypeMessageContentV1.lower(value)
}


extension MessageContentV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageContentsV2 {
    
    case str(value: String)
    case bytes(value: Data)
}

public struct FfiConverterTypeMessageContentsV2: FfiConverterRustBuffer {
    typealias SwiftType = MessageContentsV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContentsV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .str(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .bytes(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContentsV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .str(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .bytes(value):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageContentsV2_lift(_ buf: RustBuffer) throws -> MessageContentsV2 {
    return try FfiConverterTypeMessageContentsV2.lift(buf)
}

public func FfiConverterTypeMessageContentsV2_lower(_ value: MessageContentsV2) -> RustBuffer {
    return FfiConverterTypeMessageContentsV2.lower(value)
}


extension MessageContentsV2: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageV1 {
    
    case none
    case plainText(value: PlainTextMessageV1)
    case encrypted(value: EncryptedMessageV1)
}

public struct FfiConverterTypeMessageV1: FfiConverterRustBuffer {
    typealias SwiftType = MessageV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .plainText(
            value: try FfiConverterTypePlainTextMessageV1.read(from: &buf)
        )
        
        case 3: return .encrypted(
            value: try FfiConverterTypeEncryptedMessageV1.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .plainText(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypePlainTextMessageV1.write(value, into: &buf)
            
        
        case let .encrypted(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEncryptedMessageV1.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageV1_lift(_ buf: RustBuffer) throws -> MessageV1 {
    return try FfiConverterTypeMessageV1.lift(buf)
}

public func FfiConverterTypeMessageV1_lower(_ value: MessageV1) -> RustBuffer {
    return FfiConverterTypeMessageV1.lower(value)
}


extension MessageV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageV2 {
    
    case none
    case plainText(value: PlainTextMessageV2)
    case encrypted(value: EncryptedMessageV2)
}

public struct FfiConverterTypeMessageV2: FfiConverterRustBuffer {
    typealias SwiftType = MessageV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .plainText(
            value: try FfiConverterTypePlainTextMessageV2.read(from: &buf)
        )
        
        case 3: return .encrypted(
            value: try FfiConverterTypeEncryptedMessageV2.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .plainText(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypePlainTextMessageV2.write(value, into: &buf)
            
        
        case let .encrypted(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEncryptedMessageV2.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageV2_lift(_ buf: RustBuffer) throws -> MessageV2 {
    return try FfiConverterTypeMessageV2.lift(buf)
}

public func FfiConverterTypeMessageV2_lower(_ value: MessageV2) -> RustBuffer {
    return FfiConverterTypeMessageV2.lower(value)
}


extension MessageV2: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MetadataValue {
    
    case stringValue(value: String)
    case boolValue(value: Bool)
    case u8Value(value: UInt8)
    case u32Value(value: UInt32)
    case u64Value(value: UInt64)
    case i32Value(value: Int32)
    case i64Value(value: Int64)
    case decimalValue(value: Decimal)
    case globalAddressValue(value: Address)
    case publicKeyValue(value: PublicKey)
    case nonFungibleGlobalIdValue(value: NonFungibleGlobalId)
    case nonFungibleLocalIdValue(value: NonFungibleLocalId)
    case instantValue(value: Int64)
    case urlValue(value: String)
    case originValue(value: String)
    case publicKeyHashValue(value: PublicKeyHash)
    case stringArrayValue(value: [String])
    case boolArrayValue(value: [Bool])
    case u8ArrayValue(value: Data)
    case u32ArrayValue(value: [UInt32])
    case u64ArrayValue(value: [UInt64])
    case i32ArrayValue(value: [Int32])
    case i64ArrayValue(value: [Int64])
    case decimalArrayValue(value: [Decimal])
    case globalAddressArrayValue(value: [Address])
    case publicKeyArrayValue(value: [PublicKey])
    case nonFungibleGlobalIdArrayValue(value: [NonFungibleGlobalId])
    case nonFungibleLocalIdArrayValue(value: [NonFungibleLocalId])
    case instantArrayValue(value: [Int64])
    case urlArrayValue(value: [String])
    case originArrayValue(value: [String])
    case publicKeyHashArrayValue(value: [PublicKeyHash])
}

public struct FfiConverterTypeMetadataValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .stringValue(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .boolValue(
            value: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .u8Value(
            value: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 4: return .u32Value(
            value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .u64Value(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 6: return .i32Value(
            value: try FfiConverterInt32.read(from: &buf)
        )
        
        case 7: return .i64Value(
            value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 8: return .decimalValue(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 9: return .globalAddressValue(
            value: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 10: return .publicKeyValue(
            value: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 11: return .nonFungibleGlobalIdValue(
            value: try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 12: return .nonFungibleLocalIdValue(
            value: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 13: return .instantValue(
            value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 14: return .urlValue(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .originValue(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .publicKeyHashValue(
            value: try FfiConverterTypePublicKeyHash.read(from: &buf)
        )
        
        case 17: return .stringArrayValue(
            value: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 18: return .boolArrayValue(
            value: try FfiConverterSequenceBool.read(from: &buf)
        )
        
        case 19: return .u8ArrayValue(
            value: try FfiConverterData.read(from: &buf)
        )
        
        case 20: return .u32ArrayValue(
            value: try FfiConverterSequenceUInt32.read(from: &buf)
        )
        
        case 21: return .u64ArrayValue(
            value: try FfiConverterSequenceUInt64.read(from: &buf)
        )
        
        case 22: return .i32ArrayValue(
            value: try FfiConverterSequenceInt32.read(from: &buf)
        )
        
        case 23: return .i64ArrayValue(
            value: try FfiConverterSequenceInt64.read(from: &buf)
        )
        
        case 24: return .decimalArrayValue(
            value: try FfiConverterSequenceTypeDecimal.read(from: &buf)
        )
        
        case 25: return .globalAddressArrayValue(
            value: try FfiConverterSequenceTypeAddress.read(from: &buf)
        )
        
        case 26: return .publicKeyArrayValue(
            value: try FfiConverterSequenceTypePublicKey.read(from: &buf)
        )
        
        case 27: return .nonFungibleGlobalIdArrayValue(
            value: try FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 28: return .nonFungibleLocalIdArrayValue(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 29: return .instantArrayValue(
            value: try FfiConverterSequenceInt64.read(from: &buf)
        )
        
        case 30: return .urlArrayValue(
            value: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 31: return .originArrayValue(
            value: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 32: return .publicKeyHashArrayValue(
            value: try FfiConverterSequenceTypePublicKeyHash.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MetadataValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .stringValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .boolValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .u8Value(value):
            writeInt(&buf, Int32(3))
            FfiConverterUInt8.write(value, into: &buf)
            
        
        case let .u32Value(value):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .u64Value(value):
            writeInt(&buf, Int32(5))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .i32Value(value):
            writeInt(&buf, Int32(6))
            FfiConverterInt32.write(value, into: &buf)
            
        
        case let .i64Value(value):
            writeInt(&buf, Int32(7))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .decimalValue(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .globalAddressValue(value):
            writeInt(&buf, Int32(9))
            FfiConverterTypeAddress.write(value, into: &buf)
            
        
        case let .publicKeyValue(value):
            writeInt(&buf, Int32(10))
            FfiConverterTypePublicKey.write(value, into: &buf)
            
        
        case let .nonFungibleGlobalIdValue(value):
            writeInt(&buf, Int32(11))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
            
        
        case let .nonFungibleLocalIdValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .instantValue(value):
            writeInt(&buf, Int32(13))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .urlValue(value):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .originValue(value):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .publicKeyHashValue(value):
            writeInt(&buf, Int32(16))
            FfiConverterTypePublicKeyHash.write(value, into: &buf)
            
        
        case let .stringArrayValue(value):
            writeInt(&buf, Int32(17))
            FfiConverterSequenceString.write(value, into: &buf)
            
        
        case let .boolArrayValue(value):
            writeInt(&buf, Int32(18))
            FfiConverterSequenceBool.write(value, into: &buf)
            
        
        case let .u8ArrayValue(value):
            writeInt(&buf, Int32(19))
            FfiConverterData.write(value, into: &buf)
            
        
        case let .u32ArrayValue(value):
            writeInt(&buf, Int32(20))
            FfiConverterSequenceUInt32.write(value, into: &buf)
            
        
        case let .u64ArrayValue(value):
            writeInt(&buf, Int32(21))
            FfiConverterSequenceUInt64.write(value, into: &buf)
            
        
        case let .i32ArrayValue(value):
            writeInt(&buf, Int32(22))
            FfiConverterSequenceInt32.write(value, into: &buf)
            
        
        case let .i64ArrayValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterSequenceInt64.write(value, into: &buf)
            
        
        case let .decimalArrayValue(value):
            writeInt(&buf, Int32(24))
            FfiConverterSequenceTypeDecimal.write(value, into: &buf)
            
        
        case let .globalAddressArrayValue(value):
            writeInt(&buf, Int32(25))
            FfiConverterSequenceTypeAddress.write(value, into: &buf)
            
        
        case let .publicKeyArrayValue(value):
            writeInt(&buf, Int32(26))
            FfiConverterSequenceTypePublicKey.write(value, into: &buf)
            
        
        case let .nonFungibleGlobalIdArrayValue(value):
            writeInt(&buf, Int32(27))
            FfiConverterSequenceTypeNonFungibleGlobalId.write(value, into: &buf)
            
        
        case let .nonFungibleLocalIdArrayValue(value):
            writeInt(&buf, Int32(28))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        
        case let .instantArrayValue(value):
            writeInt(&buf, Int32(29))
            FfiConverterSequenceInt64.write(value, into: &buf)
            
        
        case let .urlArrayValue(value):
            writeInt(&buf, Int32(30))
            FfiConverterSequenceString.write(value, into: &buf)
            
        
        case let .originArrayValue(value):
            writeInt(&buf, Int32(31))
            FfiConverterSequenceString.write(value, into: &buf)
            
        
        case let .publicKeyHashArrayValue(value):
            writeInt(&buf, Int32(32))
            FfiConverterSequenceTypePublicKeyHash.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMetadataValue_lift(_ buf: RustBuffer) throws -> MetadataValue {
    return try FfiConverterTypeMetadataValue.lift(buf)
}

public func FfiConverterTypeMetadataValue_lower(_ value: MetadataValue) -> RustBuffer {
    return FfiConverterTypeMetadataValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ModuleId {
    
    case main
    case metadata
    case royalty
    case roleAssignment
}

public struct FfiConverterTypeModuleId: FfiConverterRustBuffer {
    typealias SwiftType = ModuleId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .metadata
        
        case 3: return .royalty
        
        case 4: return .roleAssignment
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModuleId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .metadata:
            writeInt(&buf, Int32(2))
        
        
        case .royalty:
            writeInt(&buf, Int32(3))
        
        
        case .roleAssignment:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeModuleId_lift(_ buf: RustBuffer) throws -> ModuleId {
    return try FfiConverterTypeModuleId.lift(buf)
}

public func FfiConverterTypeModuleId_lower(_ value: ModuleId) -> RustBuffer {
    return FfiConverterTypeModuleId.lower(value)
}


extension ModuleId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NameRecordError {
    
    case objectNameIsAlreadyTaken(object: String, name: String)
    case objectDoesNotExist(object: String, name: String)
}

public struct FfiConverterTypeNameRecordError: FfiConverterRustBuffer {
    typealias SwiftType = NameRecordError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NameRecordError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .objectNameIsAlreadyTaken(
            object: try FfiConverterString.read(from: &buf), 
            name: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .objectDoesNotExist(
            object: try FfiConverterString.read(from: &buf), 
            name: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NameRecordError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .objectNameIsAlreadyTaken(object,name):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(object, into: &buf)
            FfiConverterString.write(name, into: &buf)
            
        
        case let .objectDoesNotExist(object,name):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(object, into: &buf)
            FfiConverterString.write(name, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNameRecordError_lift(_ buf: RustBuffer) throws -> NameRecordError {
    return try FfiConverterTypeNameRecordError.lift(buf)
}

public func FfiConverterTypeNameRecordError_lower(_ value: NameRecordError) -> RustBuffer {
    return FfiConverterTypeNameRecordError.lower(value)
}


extension NameRecordError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleLocalId {
    
    case integer(value: UInt64)
    case str(value: String)
    case bytes(value: Data)
    case ruid(value: Data)
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .integer(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .str(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .bytes(
            value: try FfiConverterData.read(from: &buf)
        )
        
        case 4: return .ruid(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterData.write(value, into: &buf)
            
        
        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}


extension NonFungibleLocalId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleResourceIndicator {
    
    case byAll(predictedAmount: PredictedDecimal, predictedIds: PredictedNonFungibleIds)
    case byAmount(amount: Decimal, predictedIds: PredictedNonFungibleIds)
    case byIds(ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .byAll(
            predictedAmount: try FfiConverterTypePredictedDecimal.read(from: &buf), 
            predictedIds: try FfiConverterTypePredictedNonFungibleIds.read(from: &buf)
        )
        
        case 2: return .byAmount(
            amount: try FfiConverterTypeDecimal.read(from: &buf), 
            predictedIds: try FfiConverterTypePredictedNonFungibleIds.read(from: &buf)
        )
        
        case 3: return .byIds(
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .byAll(predictedAmount,predictedIds):
            writeInt(&buf, Int32(1))
            FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
            FfiConverterTypePredictedNonFungibleIds.write(predictedIds, into: &buf)
            
        
        case let .byAmount(amount,predictedIds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal.write(amount, into: &buf)
            FfiConverterTypePredictedNonFungibleIds.write(predictedIds, into: &buf)
            
        
        case let .byIds(ids):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
    return try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OlympiaNetwork {
    
    case mainnet
    case stokenet
    case releasenet
    case rcNet
    case milestonenet
    case devopsnet
    case sandpitnet
    case localnet
}

public struct FfiConverterTypeOlympiaNetwork: FfiConverterRustBuffer {
    typealias SwiftType = OlympiaNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .stokenet
        
        case 3: return .releasenet
        
        case 4: return .rcNet
        
        case 5: return .milestonenet
        
        case 6: return .devopsnet
        
        case 7: return .sandpitnet
        
        case 8: return .localnet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OlympiaNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .stokenet:
            writeInt(&buf, Int32(2))
        
        
        case .releasenet:
            writeInt(&buf, Int32(3))
        
        
        case .rcNet:
            writeInt(&buf, Int32(4))
        
        
        case .milestonenet:
            writeInt(&buf, Int32(5))
        
        
        case .devopsnet:
            writeInt(&buf, Int32(6))
        
        
        case .sandpitnet:
            writeInt(&buf, Int32(7))
        
        
        case .localnet:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeOlympiaNetwork_lift(_ buf: RustBuffer) throws -> OlympiaNetwork {
    return try FfiConverterTypeOlympiaNetwork.lift(buf)
}

public func FfiConverterTypeOlympiaNetwork_lower(_ value: OlympiaNetwork) -> RustBuffer {
    return FfiConverterTypeOlympiaNetwork.lower(value)
}


extension OlympiaNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Operation {
    
    case add
    case remove
}

public struct FfiConverterTypeOperation: FfiConverterRustBuffer {
    typealias SwiftType = Operation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Operation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .add
        
        case 2: return .remove
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Operation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .add:
            writeInt(&buf, Int32(1))
        
        
        case .remove:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeOperation_lift(_ buf: RustBuffer) throws -> Operation {
    return try FfiConverterTypeOperation.lift(buf)
}

public func FfiConverterTypeOperation_lower(_ value: Operation) -> RustBuffer {
    return FfiConverterTypeOperation.lower(value)
}


extension Operation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OwnerRole {
    
    case none
    case fixed(value: AccessRule)
    case updatable(value: AccessRule)
}

public struct FfiConverterTypeOwnerRole: FfiConverterRustBuffer {
    typealias SwiftType = OwnerRole

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnerRole {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .fixed(
            value: try FfiConverterTypeAccessRule.read(from: &buf)
        )
        
        case 3: return .updatable(
            value: try FfiConverterTypeAccessRule.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OwnerRole, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .fixed(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccessRule.write(value, into: &buf)
            
        
        case let .updatable(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccessRule.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOwnerRole_lift(_ buf: RustBuffer) throws -> OwnerRole {
    return try FfiConverterTypeOwnerRole.lift(buf)
}

public func FfiConverterTypeOwnerRole_lower(_ value: OwnerRole) -> RustBuffer {
    return FfiConverterTypeOwnerRole.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Proposer {
    
    case primary
    case recovery
}

public struct FfiConverterTypeProposer: FfiConverterRustBuffer {
    typealias SwiftType = Proposer

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proposer {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primary
        
        case 2: return .recovery
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Proposer, into buf: inout [UInt8]) {
        switch value {
        
        
        case .primary:
            writeInt(&buf, Int32(1))
        
        
        case .recovery:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeProposer_lift(_ buf: RustBuffer) throws -> Proposer {
    return try FfiConverterTypeProposer.lift(buf)
}

public func FfiConverterTypeProposer_lower(_ value: Proposer) -> RustBuffer {
    return FfiConverterTypeProposer.lower(value)
}


extension Proposer: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKey {
    
    case secp256k1(value: Data)
    case ed25519(value: Data)
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(
            value: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .ed25519(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(value, into: &buf)
            
        
        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}


extension PublicKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKeyHash {
    
    case secp256k1(value: Data)
    case ed25519(value: Data)
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(
            value: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .ed25519(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(value, into: &buf)
            
        
        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}


extension PublicKeyHash: Equatable, Hashable {}



public enum RadixEngineToolkitError {

    
    
    case InvalidLength(expected: UInt64, actual: UInt64, data: Data)
    case FailedToExtractNetwork(address: String)
    case Bech32DecodeError(error: String)
    case ParseError(typeName: String, error: String)
    case NonFungibleContentValidationError(error: String)
    case EntityTypeMismatchError(expected: [EntityType], actual: EntityType)
    case DerivationError(error: String)
    case InvalidPublicKey
    case InstructionAddError(error: String)
    case CompileError(error: String)
    case DecompileError(error: String)
    case PrepareError(error: String)
    case EncodeError(error: String)
    case DecodeError(error: String)
    case TransactionValidationFailed(error: String)
    case ExecutionModuleError(error: String)
    case ManifestSborError(error: String)
    case ScryptoSborError(error: String)
    case TypedNativeEventError(error: String)
    case FailedToDecodeTransactionHash(error: String)
    case ManifestBuilderNameRecordError(error: NameRecordError)
    case InvalidEntityTypeIdError(error: String)
    case DecimalError
    case SignerError(error: String)
    case InvalidReceipt
    case StaticAnalysisFailed(error: String)
    case NotAllBuilderItemsWereSpecified
    case ManifestValidationError(error: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRadixEngineToolkitError.lift(error)
    }
}


public struct FfiConverterTypeRadixEngineToolkitError: FfiConverterRustBuffer {
    typealias SwiftType = RadixEngineToolkitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixEngineToolkitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLength(
            expected: try FfiConverterUInt64.read(from: &buf), 
            actual: try FfiConverterUInt64.read(from: &buf), 
            data: try FfiConverterData.read(from: &buf)
            )
        case 2: return .FailedToExtractNetwork(
            address: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Bech32DecodeError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParseError(
            typeName: try FfiConverterString.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
            )
        case 5: return .NonFungibleContentValidationError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 6: return .EntityTypeMismatchError(
            expected: try FfiConverterSequenceTypeEntityType.read(from: &buf), 
            actual: try FfiConverterTypeEntityType.read(from: &buf)
            )
        case 7: return .DerivationError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 8: return .InvalidPublicKey
        case 9: return .InstructionAddError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 10: return .CompileError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 11: return .DecompileError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 12: return .PrepareError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 13: return .EncodeError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 14: return .DecodeError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 15: return .TransactionValidationFailed(
            error: try FfiConverterString.read(from: &buf)
            )
        case 16: return .ExecutionModuleError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 17: return .ManifestSborError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 18: return .ScryptoSborError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 19: return .TypedNativeEventError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 20: return .FailedToDecodeTransactionHash(
            error: try FfiConverterString.read(from: &buf)
            )
        case 21: return .ManifestBuilderNameRecordError(
            error: try FfiConverterTypeNameRecordError.read(from: &buf)
            )
        case 22: return .InvalidEntityTypeIdError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 23: return .DecimalError
        case 24: return .SignerError(
            error: try FfiConverterString.read(from: &buf)
            )
        case 25: return .InvalidReceipt
        case 26: return .StaticAnalysisFailed(
            error: try FfiConverterString.read(from: &buf)
            )
        case 27: return .NotAllBuilderItemsWereSpecified
        case 28: return .ManifestValidationError(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixEngineToolkitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidLength(expected,actual,data):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(actual, into: &buf)
            FfiConverterData.write(data, into: &buf)
            
        
        case let .FailedToExtractNetwork(address):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(address, into: &buf)
            
        
        case let .Bech32DecodeError(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .ParseError(typeName,error):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(typeName, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .NonFungibleContentValidationError(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .EntityTypeMismatchError(expected,actual):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeEntityType.write(expected, into: &buf)
            FfiConverterTypeEntityType.write(actual, into: &buf)
            
        
        case let .DerivationError(error):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(error, into: &buf)
            
        
        case .InvalidPublicKey:
            writeInt(&buf, Int32(8))
        
        
        case let .InstructionAddError(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .CompileError(error):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .DecompileError(error):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .PrepareError(error):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .EncodeError(error):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .DecodeError(error):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .TransactionValidationFailed(error):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .ExecutionModuleError(error):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .ManifestSborError(error):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .ScryptoSborError(error):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .TypedNativeEventError(error):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .FailedToDecodeTransactionHash(error):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .ManifestBuilderNameRecordError(error):
            writeInt(&buf, Int32(21))
            FfiConverterTypeNameRecordError.write(error, into: &buf)
            
        
        case let .InvalidEntityTypeIdError(error):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(error, into: &buf)
            
        
        case .DecimalError:
            writeInt(&buf, Int32(23))
        
        
        case let .SignerError(error):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(error, into: &buf)
            
        
        case .InvalidReceipt:
            writeInt(&buf, Int32(25))
        
        
        case let .StaticAnalysisFailed(error):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(error, into: &buf)
            
        
        case .NotAllBuilderItemsWereSpecified:
            writeInt(&buf, Int32(27))
        
        
        case let .ManifestValidationError(error):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension RadixEngineToolkitError: Equatable, Hashable {}

extension RadixEngineToolkitError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RecallResourceEvent {
    
    case amount(value: Decimal)
    case ids(value: [NonFungibleLocalId])
}

public struct FfiConverterTypeRecallResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = RecallResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecallResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .ids(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecallResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .ids(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRecallResourceEvent_lift(_ buf: RustBuffer) throws -> RecallResourceEvent {
    return try FfiConverterTypeRecallResourceEvent.lift(buf)
}

public func FfiConverterTypeRecallResourceEvent_lower(_ value: RecallResourceEvent) -> RustBuffer {
    return FfiConverterTypeRecallResourceEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ReservedInstruction {
    
    case accountLockFee
    case accountSecurify
    case identitySecurify
    case accessControllerMethod
}

public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountLockFee
        
        case 2: return .accountSecurify
        
        case 3: return .identitySecurify
        
        case 4: return .accessControllerMethod
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .accountLockFee:
            writeInt(&buf, Int32(1))
        
        
        case .accountSecurify:
            writeInt(&buf, Int32(2))
        
        
        case .identitySecurify:
            writeInt(&buf, Int32(3))
        
        
        case .accessControllerMethod:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}


extension ReservedInstruction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceIndicator {
    
    case fungible(resourceAddress: Address, indicator: FungibleResourceIndicator)
    case nonFungible(resourceAddress: Address, indicator: NonFungibleResourceIndicator)
}

public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            indicator: try FfiConverterTypeFungibleResourceIndicator.read(from: &buf)
        )
        
        case 2: return .nonFungible(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            indicator: try FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,indicator):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)
            
        
        case let .nonFungible(resourceAddress,indicator):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
    return try FfiConverterTypeResourceIndicator.lift(buf)
}

public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
    return FfiConverterTypeResourceIndicator.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceOrNonFungible {
    
    case nonFungible(value: NonFungibleGlobalId)
    case resource(value: Address)
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonFungible(
            value: try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 2: return .resource(
            value: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nonFungible(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
            
        
        case let .resource(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourcePreference {
    
    case allowed
    case disallowed
}

public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allowed
        
        case 2: return .disallowed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allowed:
            writeInt(&buf, Int32(1))
        
        
        case .disallowed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}


extension ResourcePreference: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourcePreferenceUpdate {
    
    case set(value: ResourcePreference)
    case remove
}

public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .set(
            value: try FfiConverterTypeResourcePreference.read(from: &buf)
        )
        
        case 2: return .remove
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .set(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(value, into: &buf)
            
        
        case .remove:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
    return try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceUpdate.lower(value)
}


extension ResourcePreferenceUpdate: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceSpecifier {
    
    case amount(resourceAddress: Address, amount: Decimal)
    case ids(resourceAddress: Address, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            amount: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .ids(
            resourceAddress: try FfiConverterTypeAddress.read(from: &buf), 
            ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal.write(amount, into: &buf)
            
        
        case let .ids(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Role {
    
    case primary
    case recovery
    case confirmation
}

public struct FfiConverterTypeRole: FfiConverterRustBuffer {
    typealias SwiftType = Role

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Role {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primary
        
        case 2: return .recovery
        
        case 3: return .confirmation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Role, into buf: inout [UInt8]) {
        switch value {
        
        
        case .primary:
            writeInt(&buf, Int32(1))
        
        
        case .recovery:
            writeInt(&buf, Int32(2))
        
        
        case .confirmation:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRole_lift(_ buf: RustBuffer) throws -> Role {
    return try FfiConverterTypeRole.lift(buf)
}

public func FfiConverterTypeRole_lower(_ value: Role) -> RustBuffer {
    return FfiConverterTypeRole.lower(value)
}


extension Role: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoundingMode {
    
    case toPositiveInfinity
    case toNegativeInfinity
    case toZero
    case awayFromZero
    case toNearestMidpointTowardZero
    case toNearestMidpointAwayFromZero
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toPositiveInfinity
        
        case 2: return .toNegativeInfinity
        
        case 3: return .toZero
        
        case 4: return .awayFromZero
        
        case 5: return .toNearestMidpointTowardZero
        
        case 6: return .toNearestMidpointAwayFromZero
        
        case 7: return .toNearestMidpointToEven
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))
        
        
        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))
        
        
        case .toZero:
            writeInt(&buf, Int32(3))
        
        
        case .awayFromZero:
            writeInt(&buf, Int32(4))
        
        
        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))
        
        
        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))
        
        
        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}


extension RoundingMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoyaltyAmount {
    
    case free
    case xrd(value: Decimal)
    case usd(value: Decimal)
}

public struct FfiConverterTypeRoyaltyAmount: FfiConverterRustBuffer {
    typealias SwiftType = RoyaltyAmount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoyaltyAmount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .free
        
        case 2: return .xrd(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .usd(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoyaltyAmount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .free:
            writeInt(&buf, Int32(1))
        
        
        case let .xrd(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .usd(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoyaltyAmount_lift(_ buf: RustBuffer) throws -> RoyaltyAmount {
    return try FfiConverterTypeRoyaltyAmount.lift(buf)
}

public func FfiConverterTypeRoyaltyAmount_lower(_ value: RoyaltyAmount) -> RustBuffer {
    return FfiConverterTypeRoyaltyAmount.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ScryptoSborString {
    
    case programmaticJson(value: String)
}

public struct FfiConverterTypeScryptoSborString: FfiConverterRustBuffer {
    typealias SwiftType = ScryptoSborString

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoSborString {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .programmaticJson(
            value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScryptoSborString, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .programmaticJson(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeScryptoSborString_lift(_ buf: RustBuffer) throws -> ScryptoSborString {
    return try FfiConverterTypeScryptoSborString.lift(buf)
}

public func FfiConverterTypeScryptoSborString_lower(_ value: ScryptoSborString) -> RustBuffer {
    return FfiConverterTypeScryptoSborString.lower(value)
}


extension ScryptoSborString: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SerializationMode {
    
    case programmatic
    case natural
}

public struct FfiConverterTypeSerializationMode: FfiConverterRustBuffer {
    typealias SwiftType = SerializationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerializationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .programmatic
        
        case 2: return .natural
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerializationMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .programmatic:
            writeInt(&buf, Int32(1))
        
        
        case .natural:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeSerializationMode_lift(_ buf: RustBuffer) throws -> SerializationMode {
    return try FfiConverterTypeSerializationMode.lift(buf)
}

public func FfiConverterTypeSerializationMode_lower(_ value: SerializationMode) -> RustBuffer {
    return FfiConverterTypeSerializationMode.lower(value)
}


extension SerializationMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureV1 {
    
    case secp256k1(value: Data)
    case ed25519(value: Data)
}

public struct FfiConverterTypeSignatureV1: FfiConverterRustBuffer {
    typealias SwiftType = SignatureV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(
            value: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .ed25519(
            value: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(value, into: &buf)
            
        
        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSignatureV1_lift(_ buf: RustBuffer) throws -> SignatureV1 {
    return try FfiConverterTypeSignatureV1.lift(buf)
}

public func FfiConverterTypeSignatureV1_lower(_ value: SignatureV1) -> RustBuffer {
    return FfiConverterTypeSignatureV1.lower(value)
}


extension SignatureV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureWithPublicKeyV1 {
    
    case secp256k1(signature: Data)
    case ed25519(signature: Data, publicKey: Data)
}

public struct FfiConverterTypeSignatureWithPublicKeyV1: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKeyV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKeyV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(
            signature: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .ed25519(
            signature: try FfiConverterData.read(from: &buf), 
            publicKey: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKeyV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(signature):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(signature, into: &buf)
            
        
        case let .ed25519(signature,publicKey):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(signature, into: &buf)
            FfiConverterData.write(publicKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSignatureWithPublicKeyV1_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKeyV1 {
    return try FfiConverterTypeSignatureWithPublicKeyV1.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKeyV1_lower(_ value: SignatureWithPublicKeyV1) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKeyV1.lower(value)
}


extension SignatureWithPublicKeyV1: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SimpleFungibleResourceBounds {
    
    case exact(value: Decimal)
    case atMost(value: Decimal)
    case atLeast(value: Decimal)
    case between(lowerBoundInclusive: Decimal, upperBoundInclusive: Decimal)
    case unknownAmount
}

public struct FfiConverterTypeSimpleFungibleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleFungibleResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleFungibleResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exact(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .atMost(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .atLeast(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 4: return .between(
            lowerBoundInclusive: try FfiConverterTypeDecimal.read(from: &buf), 
            upperBoundInclusive: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 5: return .unknownAmount
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleFungibleResourceBounds, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .exact(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .atMost(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .atLeast(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .between(lowerBoundInclusive,upperBoundInclusive):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDecimal.write(lowerBoundInclusive, into: &buf)
            FfiConverterTypeDecimal.write(upperBoundInclusive, into: &buf)
            
        
        case .unknownAmount:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeSimpleFungibleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleFungibleResourceBounds {
    return try FfiConverterTypeSimpleFungibleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleFungibleResourceBounds_lower(_ value: SimpleFungibleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleFungibleResourceBounds.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SimpleNonFungibleResourceBounds {
    
    case exact(amount: Decimal, certainIds: [NonFungibleLocalId])
    case notExact(certainIds: [NonFungibleLocalId], lowerBound: LowerBound, upperBound: UpperBound, allowedIds: AllowedIds)
}

public struct FfiConverterTypeSimpleNonFungibleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleNonFungibleResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleNonFungibleResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exact(
            amount: try FfiConverterTypeDecimal.read(from: &buf), 
            certainIds: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 2: return .notExact(
            certainIds: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
            lowerBound: try FfiConverterTypeLowerBound.read(from: &buf), 
            upperBound: try FfiConverterTypeUpperBound.read(from: &buf), 
            allowedIds: try FfiConverterTypeAllowedIds.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleNonFungibleResourceBounds, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .exact(amount,certainIds):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(amount, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(certainIds, into: &buf)
            
        
        case let .notExact(certainIds,lowerBound,upperBound,allowedIds):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(certainIds, into: &buf)
            FfiConverterTypeLowerBound.write(lowerBound, into: &buf)
            FfiConverterTypeUpperBound.write(upperBound, into: &buf)
            FfiConverterTypeAllowedIds.write(allowedIds, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSimpleNonFungibleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleNonFungibleResourceBounds {
    return try FfiConverterTypeSimpleNonFungibleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleNonFungibleResourceBounds_lower(_ value: SimpleNonFungibleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleNonFungibleResourceBounds.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccessControllerBlueprintEvent {
    
    case initiateRecoveryEventValue(value: InitiateRecoveryEvent)
    case initiateBadgeWithdrawAttemptEventValue(value: InitiateBadgeWithdrawAttemptEvent)
    case ruleSetUpdateEventValue(value: RuleSetUpdateEvent)
    case badgeWithdrawEventValue(value: BadgeWithdrawEvent)
    case cancelRecoveryProposalEventValue(value: CancelRecoveryProposalEvent)
    case cancelBadgeWithdrawAttemptEventValue(value: CancelBadgeWithdrawAttemptEvent)
    case lockPrimaryRoleEventValue(value: LockPrimaryRoleEvent)
    case unlockPrimaryRoleEventValue(value: UnlockPrimaryRoleEvent)
    case stopTimedRecoveryEventValue(value: StopTimedRecoveryEvent)
    case depositRecoveryXrdEventValue(value: DepositRecoveryXrdEvent)
    case withdrawRecoveryXrdEventValue(value: WithdrawRecoveryXrdEvent)
}

public struct FfiConverterTypeTypedAccessControllerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccessControllerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccessControllerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initiateRecoveryEventValue(
            value: try FfiConverterTypeInitiateRecoveryEvent.read(from: &buf)
        )
        
        case 2: return .initiateBadgeWithdrawAttemptEventValue(
            value: try FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.read(from: &buf)
        )
        
        case 3: return .ruleSetUpdateEventValue(
            value: try FfiConverterTypeRuleSetUpdateEvent.read(from: &buf)
        )
        
        case 4: return .badgeWithdrawEventValue(
            value: try FfiConverterTypeBadgeWithdrawEvent.read(from: &buf)
        )
        
        case 5: return .cancelRecoveryProposalEventValue(
            value: try FfiConverterTypeCancelRecoveryProposalEvent.read(from: &buf)
        )
        
        case 6: return .cancelBadgeWithdrawAttemptEventValue(
            value: try FfiConverterTypeCancelBadgeWithdrawAttemptEvent.read(from: &buf)
        )
        
        case 7: return .lockPrimaryRoleEventValue(
            value: try FfiConverterTypeLockPrimaryRoleEvent.read(from: &buf)
        )
        
        case 8: return .unlockPrimaryRoleEventValue(
            value: try FfiConverterTypeUnlockPrimaryRoleEvent.read(from: &buf)
        )
        
        case 9: return .stopTimedRecoveryEventValue(
            value: try FfiConverterTypeStopTimedRecoveryEvent.read(from: &buf)
        )
        
        case 10: return .depositRecoveryXrdEventValue(
            value: try FfiConverterTypeDepositRecoveryXrdEvent.read(from: &buf)
        )
        
        case 11: return .withdrawRecoveryXrdEventValue(
            value: try FfiConverterTypeWithdrawRecoveryXrdEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccessControllerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .initiateRecoveryEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeInitiateRecoveryEvent.write(value, into: &buf)
            
        
        case let .initiateBadgeWithdrawAttemptEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.write(value, into: &buf)
            
        
        case let .ruleSetUpdateEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRuleSetUpdateEvent.write(value, into: &buf)
            
        
        case let .badgeWithdrawEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBadgeWithdrawEvent.write(value, into: &buf)
            
        
        case let .cancelRecoveryProposalEventValue(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeCancelRecoveryProposalEvent.write(value, into: &buf)
            
        
        case let .cancelBadgeWithdrawAttemptEventValue(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelBadgeWithdrawAttemptEvent.write(value, into: &buf)
            
        
        case let .lockPrimaryRoleEventValue(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLockPrimaryRoleEvent.write(value, into: &buf)
            
        
        case let .unlockPrimaryRoleEventValue(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeUnlockPrimaryRoleEvent.write(value, into: &buf)
            
        
        case let .stopTimedRecoveryEventValue(value):
            writeInt(&buf, Int32(9))
            FfiConverterTypeStopTimedRecoveryEvent.write(value, into: &buf)
            
        
        case let .depositRecoveryXrdEventValue(value):
            writeInt(&buf, Int32(10))
            FfiConverterTypeDepositRecoveryXrdEvent.write(value, into: &buf)
            
        
        case let .withdrawRecoveryXrdEventValue(value):
            writeInt(&buf, Int32(11))
            FfiConverterTypeWithdrawRecoveryXrdEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccessControllerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedAccessControllerBlueprintEvent {
    return try FfiConverterTypeTypedAccessControllerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedAccessControllerBlueprintEvent_lower(_ value: TypedAccessControllerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccessControllerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccessControllerPackageEvent {
    
    case accessController(value: TypedAccessControllerBlueprintEvent)
}

public struct FfiConverterTypeTypedAccessControllerPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccessControllerPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccessControllerPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accessController(
            value: try FfiConverterTypeTypedAccessControllerBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccessControllerPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accessController(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccessControllerBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccessControllerPackageEvent_lift(_ buf: RustBuffer) throws -> TypedAccessControllerPackageEvent {
    return try FfiConverterTypeTypedAccessControllerPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedAccessControllerPackageEvent_lower(_ value: TypedAccessControllerPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccessControllerPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccountBlueprintEvent {
    
    case accountWithdrawEventValue(value: AccountWithdrawEvent)
    case accountDepositEventValue(value: AccountDepositEvent)
    case accountRejectedDepositEventValue(value: AccountRejectedDepositEvent)
    case accountSetResourcePreferenceEventValue(value: AccountSetResourcePreferenceEvent)
    case accountRemoveResourcePreferenceEventValue(value: AccountRemoveResourcePreferenceEvent)
    case accountSetDefaultDepositRuleEventValue(value: AccountSetDefaultDepositRuleEvent)
    case accountAddAuthorizedDepositorEventValue(value: AccountAddAuthorizedDepositorEvent)
    case accountRemoveAuthorizedDepositorEventValue(value: AccountRemoveAuthorizedDepositorEvent)
}

public struct FfiConverterTypeTypedAccountBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccountBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccountBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountWithdrawEventValue(
            value: try FfiConverterTypeAccountWithdrawEvent.read(from: &buf)
        )
        
        case 2: return .accountDepositEventValue(
            value: try FfiConverterTypeAccountDepositEvent.read(from: &buf)
        )
        
        case 3: return .accountRejectedDepositEventValue(
            value: try FfiConverterTypeAccountRejectedDepositEvent.read(from: &buf)
        )
        
        case 4: return .accountSetResourcePreferenceEventValue(
            value: try FfiConverterTypeAccountSetResourcePreferenceEvent.read(from: &buf)
        )
        
        case 5: return .accountRemoveResourcePreferenceEventValue(
            value: try FfiConverterTypeAccountRemoveResourcePreferenceEvent.read(from: &buf)
        )
        
        case 6: return .accountSetDefaultDepositRuleEventValue(
            value: try FfiConverterTypeAccountSetDefaultDepositRuleEvent.read(from: &buf)
        )
        
        case 7: return .accountAddAuthorizedDepositorEventValue(
            value: try FfiConverterTypeAccountAddAuthorizedDepositorEvent.read(from: &buf)
        )
        
        case 8: return .accountRemoveAuthorizedDepositorEventValue(
            value: try FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccountBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accountWithdrawEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountWithdrawEvent.write(value, into: &buf)
            
        
        case let .accountDepositEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountDepositEvent.write(value, into: &buf)
            
        
        case let .accountRejectedDepositEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountRejectedDepositEvent.write(value, into: &buf)
            
        
        case let .accountSetResourcePreferenceEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAccountSetResourcePreferenceEvent.write(value, into: &buf)
            
        
        case let .accountRemoveResourcePreferenceEventValue(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAccountRemoveResourcePreferenceEvent.write(value, into: &buf)
            
        
        case let .accountSetDefaultDepositRuleEventValue(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAccountSetDefaultDepositRuleEvent.write(value, into: &buf)
            
        
        case let .accountAddAuthorizedDepositorEventValue(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAccountAddAuthorizedDepositorEvent.write(value, into: &buf)
            
        
        case let .accountRemoveAuthorizedDepositorEventValue(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccountBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedAccountBlueprintEvent {
    return try FfiConverterTypeTypedAccountBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedAccountBlueprintEvent_lower(_ value: TypedAccountBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccountBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccountLockerBlueprintEvent {
    
    case storeEventValue(value: StoreEvent)
    case recoverEventValue(value: RecoverEvent)
    case claimEventValue(value: ClaimEvent)
}

public struct FfiConverterTypeTypedAccountLockerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccountLockerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccountLockerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .storeEventValue(
            value: try FfiConverterTypeStoreEvent.read(from: &buf)
        )
        
        case 2: return .recoverEventValue(
            value: try FfiConverterTypeRecoverEvent.read(from: &buf)
        )
        
        case 3: return .claimEventValue(
            value: try FfiConverterTypeClaimEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccountLockerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .storeEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeStoreEvent.write(value, into: &buf)
            
        
        case let .recoverEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRecoverEvent.write(value, into: &buf)
            
        
        case let .claimEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeClaimEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccountLockerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedAccountLockerBlueprintEvent {
    return try FfiConverterTypeTypedAccountLockerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedAccountLockerBlueprintEvent_lower(_ value: TypedAccountLockerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccountLockerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccountPackageEvent {
    
    case account(value: TypedAccountBlueprintEvent)
}

public struct FfiConverterTypeTypedAccountPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccountPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccountPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(
            value: try FfiConverterTypeTypedAccountBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccountPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccountBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccountPackageEvent_lift(_ buf: RustBuffer) throws -> TypedAccountPackageEvent {
    return try FfiConverterTypeTypedAccountPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedAccountPackageEvent_lower(_ value: TypedAccountPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccountPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedConsensusManagerBlueprintEvent {
    
    case roundChangeEventValue(value: RoundChangeEvent)
    case epochChangeEventValue(value: EpochChangeEvent)
}

public struct FfiConverterTypeTypedConsensusManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedConsensusManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedConsensusManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roundChangeEventValue(
            value: try FfiConverterTypeRoundChangeEvent.read(from: &buf)
        )
        
        case 2: return .epochChangeEventValue(
            value: try FfiConverterTypeEpochChangeEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedConsensusManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roundChangeEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoundChangeEvent.write(value, into: &buf)
            
        
        case let .epochChangeEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEpochChangeEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedConsensusManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedConsensusManagerBlueprintEvent {
    return try FfiConverterTypeTypedConsensusManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedConsensusManagerBlueprintEvent_lower(_ value: TypedConsensusManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedConsensusManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedConsensusManagerPackageEvent {
    
    case consensusManager(value: TypedConsensusManagerBlueprintEvent)
    case validator(value: TypedValidatorBlueprintEvent)
}

public struct FfiConverterTypeTypedConsensusManagerPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedConsensusManagerPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedConsensusManagerPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .consensusManager(
            value: try FfiConverterTypeTypedConsensusManagerBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .validator(
            value: try FfiConverterTypeTypedValidatorBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedConsensusManagerPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .consensusManager(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedConsensusManagerBlueprintEvent.write(value, into: &buf)
            
        
        case let .validator(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedValidatorBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedConsensusManagerPackageEvent_lift(_ buf: RustBuffer) throws -> TypedConsensusManagerPackageEvent {
    return try FfiConverterTypeTypedConsensusManagerPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedConsensusManagerPackageEvent_lower(_ value: TypedConsensusManagerPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedConsensusManagerPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedFungibleResourceManagerBlueprintEvent {
    
    case vaultCreationEventValue(value: VaultCreationEvent)
    case mintFungibleResourceEventValue(value: MintFungibleResourceEvent)
    case burnFungibleResourceEventValue(value: BurnFungibleResourceEvent)
}

public struct FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedFungibleResourceManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedFungibleResourceManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .vaultCreationEventValue(
            value: try FfiConverterTypeVaultCreationEvent.read(from: &buf)
        )
        
        case 2: return .mintFungibleResourceEventValue(
            value: try FfiConverterTypeMintFungibleResourceEvent.read(from: &buf)
        )
        
        case 3: return .burnFungibleResourceEventValue(
            value: try FfiConverterTypeBurnFungibleResourceEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedFungibleResourceManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .vaultCreationEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVaultCreationEvent.write(value, into: &buf)
            
        
        case let .mintFungibleResourceEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMintFungibleResourceEvent.write(value, into: &buf)
            
        
        case let .burnFungibleResourceEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBurnFungibleResourceEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedFungibleResourceManagerBlueprintEvent {
    return try FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent_lower(_ value: TypedFungibleResourceManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedFungibleVaultBlueprintEvent {
    
    case fungibleVaultLockFeeEventValue(value: FungibleVaultLockFeeEvent)
    case fungibleVaultWithdrawEventValue(value: FungibleVaultWithdrawEvent)
    case fungibleVaultDepositEventValue(value: FungibleVaultDepositEvent)
    case fungibleVaultRecallEventValue(value: FungibleVaultRecallEvent)
    case fungibleVaultPayFeeEventValue(value: FungibleVaultPayFeeEvent)
}

public struct FfiConverterTypeTypedFungibleVaultBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedFungibleVaultBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedFungibleVaultBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungibleVaultLockFeeEventValue(
            value: try FfiConverterTypeFungibleVaultLockFeeEvent.read(from: &buf)
        )
        
        case 2: return .fungibleVaultWithdrawEventValue(
            value: try FfiConverterTypeFungibleVaultWithdrawEvent.read(from: &buf)
        )
        
        case 3: return .fungibleVaultDepositEventValue(
            value: try FfiConverterTypeFungibleVaultDepositEvent.read(from: &buf)
        )
        
        case 4: return .fungibleVaultRecallEventValue(
            value: try FfiConverterTypeFungibleVaultRecallEvent.read(from: &buf)
        )
        
        case 5: return .fungibleVaultPayFeeEventValue(
            value: try FfiConverterTypeFungibleVaultPayFeeEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedFungibleVaultBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungibleVaultLockFeeEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFungibleVaultLockFeeEvent.write(value, into: &buf)
            
        
        case let .fungibleVaultWithdrawEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFungibleVaultWithdrawEvent.write(value, into: &buf)
            
        
        case let .fungibleVaultDepositEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFungibleVaultDepositEvent.write(value, into: &buf)
            
        
        case let .fungibleVaultRecallEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFungibleVaultRecallEvent.write(value, into: &buf)
            
        
        case let .fungibleVaultPayFeeEventValue(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFungibleVaultPayFeeEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedFungibleVaultBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedFungibleVaultBlueprintEvent {
    return try FfiConverterTypeTypedFungibleVaultBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedFungibleVaultBlueprintEvent_lower(_ value: TypedFungibleVaultBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedFungibleVaultBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedLockerPackageEvent {
    
    case accountLocker(value: TypedAccountLockerBlueprintEvent)
}

public struct FfiConverterTypeTypedLockerPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedLockerPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedLockerPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountLocker(
            value: try FfiConverterTypeTypedAccountLockerBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedLockerPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accountLocker(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccountLockerBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedLockerPackageEvent_lift(_ buf: RustBuffer) throws -> TypedLockerPackageEvent {
    return try FfiConverterTypeTypedLockerPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedLockerPackageEvent_lower(_ value: TypedLockerPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedLockerPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMetadataBlueprintEvent {
    
    case setMetadataEventValue(value: SetMetadataEvent)
    case removeMetadataEventValue(value: RemoveMetadataEvent)
}

public struct FfiConverterTypeTypedMetadataBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMetadataBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMetadataBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setMetadataEventValue(
            value: try FfiConverterTypeSetMetadataEvent.read(from: &buf)
        )
        
        case 2: return .removeMetadataEventValue(
            value: try FfiConverterTypeRemoveMetadataEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMetadataBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setMetadataEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetMetadataEvent.write(value, into: &buf)
            
        
        case let .removeMetadataEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRemoveMetadataEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMetadataBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedMetadataBlueprintEvent {
    return try FfiConverterTypeTypedMetadataBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedMetadataBlueprintEvent_lower(_ value: TypedMetadataBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedMetadataBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMetadataPackageEvent {
    
    case metadata(value: TypedMetadataBlueprintEvent)
}

public struct FfiConverterTypeTypedMetadataPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMetadataPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMetadataPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .metadata(
            value: try FfiConverterTypeTypedMetadataBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMetadataPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .metadata(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedMetadataBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMetadataPackageEvent_lift(_ buf: RustBuffer) throws -> TypedMetadataPackageEvent {
    return try FfiConverterTypeTypedMetadataPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedMetadataPackageEvent_lower(_ value: TypedMetadataPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedMetadataPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMultiResourcePoolBlueprintEvent {
    
    case multiResourcePoolContributionEventValue(value: MultiResourcePoolContributionEvent)
    case multiResourcePoolRedemptionEventValue(value: MultiResourcePoolRedemptionEvent)
    case multiResourcePoolWithdrawEventValue(value: MultiResourcePoolWithdrawEvent)
    case multiResourcePoolDepositEventValue(value: MultiResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedMultiResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMultiResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMultiResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .multiResourcePoolContributionEventValue(
            value: try FfiConverterTypeMultiResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .multiResourcePoolRedemptionEventValue(
            value: try FfiConverterTypeMultiResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .multiResourcePoolWithdrawEventValue(
            value: try FfiConverterTypeMultiResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .multiResourcePoolDepositEventValue(
            value: try FfiConverterTypeMultiResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMultiResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .multiResourcePoolContributionEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMultiResourcePoolContributionEvent.write(value, into: &buf)
            
        
        case let .multiResourcePoolRedemptionEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMultiResourcePoolRedemptionEvent.write(value, into: &buf)
            
        
        case let .multiResourcePoolWithdrawEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMultiResourcePoolWithdrawEvent.write(value, into: &buf)
            
        
        case let .multiResourcePoolDepositEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiResourcePoolDepositEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMultiResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedMultiResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedMultiResourcePoolBlueprintEvent_lower(_ value: TypedMultiResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNativeEvent {
    
    case accessController(value: TypedAccessControllerPackageEvent)
    case account(value: TypedAccountPackageEvent)
    case consensusManager(value: TypedConsensusManagerPackageEvent)
    case pool(value: TypedPoolPackageEvent)
    case resource(value: TypedResourcePackageEvent)
    case roleAssignment(value: TypedRoleAssignmentPackageEvent)
    case metadata(value: TypedMetadataPackageEvent)
    case locker(value: TypedLockerPackageEvent)
}

public struct FfiConverterTypeTypedNativeEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNativeEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNativeEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accessController(
            value: try FfiConverterTypeTypedAccessControllerPackageEvent.read(from: &buf)
        )
        
        case 2: return .account(
            value: try FfiConverterTypeTypedAccountPackageEvent.read(from: &buf)
        )
        
        case 3: return .consensusManager(
            value: try FfiConverterTypeTypedConsensusManagerPackageEvent.read(from: &buf)
        )
        
        case 4: return .pool(
            value: try FfiConverterTypeTypedPoolPackageEvent.read(from: &buf)
        )
        
        case 5: return .resource(
            value: try FfiConverterTypeTypedResourcePackageEvent.read(from: &buf)
        )
        
        case 6: return .roleAssignment(
            value: try FfiConverterTypeTypedRoleAssignmentPackageEvent.read(from: &buf)
        )
        
        case 7: return .metadata(
            value: try FfiConverterTypeTypedMetadataPackageEvent.read(from: &buf)
        )
        
        case 8: return .locker(
            value: try FfiConverterTypeTypedLockerPackageEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNativeEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accessController(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccessControllerPackageEvent.write(value, into: &buf)
            
        
        case let .account(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedAccountPackageEvent.write(value, into: &buf)
            
        
        case let .consensusManager(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedConsensusManagerPackageEvent.write(value, into: &buf)
            
        
        case let .pool(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTypedPoolPackageEvent.write(value, into: &buf)
            
        
        case let .resource(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeTypedResourcePackageEvent.write(value, into: &buf)
            
        
        case let .roleAssignment(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTypedRoleAssignmentPackageEvent.write(value, into: &buf)
            
        
        case let .metadata(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTypedMetadataPackageEvent.write(value, into: &buf)
            
        
        case let .locker(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeTypedLockerPackageEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNativeEvent_lift(_ buf: RustBuffer) throws -> TypedNativeEvent {
    return try FfiConverterTypeTypedNativeEvent.lift(buf)
}

public func FfiConverterTypeTypedNativeEvent_lower(_ value: TypedNativeEvent) -> RustBuffer {
    return FfiConverterTypeTypedNativeEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNonFungibleResourceManagerBlueprintEvent {
    
    case vaultCreationEventValue(value: VaultCreationEvent)
    case mintNonFungibleResourceEventValue(value: MintNonFungibleResourceEvent)
    case burnNonFungibleResourceEventValue(value: BurnNonFungibleResourceEvent)
}

public struct FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNonFungibleResourceManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNonFungibleResourceManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .vaultCreationEventValue(
            value: try FfiConverterTypeVaultCreationEvent.read(from: &buf)
        )
        
        case 2: return .mintNonFungibleResourceEventValue(
            value: try FfiConverterTypeMintNonFungibleResourceEvent.read(from: &buf)
        )
        
        case 3: return .burnNonFungibleResourceEventValue(
            value: try FfiConverterTypeBurnNonFungibleResourceEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNonFungibleResourceManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .vaultCreationEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVaultCreationEvent.write(value, into: &buf)
            
        
        case let .mintNonFungibleResourceEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMintNonFungibleResourceEvent.write(value, into: &buf)
            
        
        case let .burnNonFungibleResourceEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBurnNonFungibleResourceEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedNonFungibleResourceManagerBlueprintEvent {
    return try FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent_lower(_ value: TypedNonFungibleResourceManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNonFungibleVaultBlueprintEvent {
    
    case nonFungibleVaultWithdrawEventValue(value: NonFungibleVaultWithdrawEvent)
    case nonFungibleVaultDepositEventValue(value: NonFungibleVaultDepositEvent)
    case nonFungibleVaultRecallEventValue(value: NonFungibleVaultRecallEvent)
}

public struct FfiConverterTypeTypedNonFungibleVaultBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNonFungibleVaultBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNonFungibleVaultBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonFungibleVaultWithdrawEventValue(
            value: try FfiConverterTypeNonFungibleVaultWithdrawEvent.read(from: &buf)
        )
        
        case 2: return .nonFungibleVaultDepositEventValue(
            value: try FfiConverterTypeNonFungibleVaultDepositEvent.read(from: &buf)
        )
        
        case 3: return .nonFungibleVaultRecallEventValue(
            value: try FfiConverterTypeNonFungibleVaultRecallEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNonFungibleVaultBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nonFungibleVaultWithdrawEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNonFungibleVaultWithdrawEvent.write(value, into: &buf)
            
        
        case let .nonFungibleVaultDepositEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleVaultDepositEvent.write(value, into: &buf)
            
        
        case let .nonFungibleVaultRecallEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonFungibleVaultRecallEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNonFungibleVaultBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedNonFungibleVaultBlueprintEvent {
    return try FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedNonFungibleVaultBlueprintEvent_lower(_ value: TypedNonFungibleVaultBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.lower(value)
}


extension TypedNonFungibleVaultBlueprintEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedOneResourcePoolBlueprintEvent {
    
    case oneResourcePoolContributionEventValue(value: OneResourcePoolContributionEvent)
    case oneResourcePoolRedemptionEventValue(value: OneResourcePoolRedemptionEvent)
    case oneResourcePoolWithdrawEventValue(value: OneResourcePoolWithdrawEvent)
    case oneResourcePoolDepositEventValue(value: OneResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedOneResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedOneResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedOneResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .oneResourcePoolContributionEventValue(
            value: try FfiConverterTypeOneResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .oneResourcePoolRedemptionEventValue(
            value: try FfiConverterTypeOneResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .oneResourcePoolWithdrawEventValue(
            value: try FfiConverterTypeOneResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .oneResourcePoolDepositEventValue(
            value: try FfiConverterTypeOneResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedOneResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .oneResourcePoolContributionEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOneResourcePoolContributionEvent.write(value, into: &buf)
            
        
        case let .oneResourcePoolRedemptionEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOneResourcePoolRedemptionEvent.write(value, into: &buf)
            
        
        case let .oneResourcePoolWithdrawEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOneResourcePoolWithdrawEvent.write(value, into: &buf)
            
        
        case let .oneResourcePoolDepositEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeOneResourcePoolDepositEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedOneResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedOneResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedOneResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedOneResourcePoolBlueprintEvent_lower(_ value: TypedOneResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedOneResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedPoolPackageEvent {
    
    case oneResourcePool(value: TypedOneResourcePoolBlueprintEvent)
    case twoResourcePool(value: TypedTwoResourcePoolBlueprintEvent)
    case multiResourcePool(value: TypedMultiResourcePoolBlueprintEvent)
}

public struct FfiConverterTypeTypedPoolPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedPoolPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedPoolPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .oneResourcePool(
            value: try FfiConverterTypeTypedOneResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .twoResourcePool(
            value: try FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        case 3: return .multiResourcePool(
            value: try FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedPoolPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .oneResourcePool(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedOneResourcePoolBlueprintEvent.write(value, into: &buf)
            
        
        case let .twoResourcePool(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.write(value, into: &buf)
            
        
        case let .multiResourcePool(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedPoolPackageEvent_lift(_ buf: RustBuffer) throws -> TypedPoolPackageEvent {
    return try FfiConverterTypeTypedPoolPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedPoolPackageEvent_lower(_ value: TypedPoolPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedPoolPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedResourcePackageEvent {
    
    case fungibleVault(value: TypedFungibleVaultBlueprintEvent)
    case nonFungibleVault(value: TypedNonFungibleVaultBlueprintEvent)
    case fungibleResourceManager(value: TypedFungibleResourceManagerBlueprintEvent)
    case nonFungibleResourceManager(value: TypedNonFungibleResourceManagerBlueprintEvent)
}

public struct FfiConverterTypeTypedResourcePackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedResourcePackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedResourcePackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungibleVault(
            value: try FfiConverterTypeTypedFungibleVaultBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .nonFungibleVault(
            value: try FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.read(from: &buf)
        )
        
        case 3: return .fungibleResourceManager(
            value: try FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.read(from: &buf)
        )
        
        case 4: return .nonFungibleResourceManager(
            value: try FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedResourcePackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungibleVault(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedFungibleVaultBlueprintEvent.write(value, into: &buf)
            
        
        case let .nonFungibleVault(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.write(value, into: &buf)
            
        
        case let .fungibleResourceManager(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.write(value, into: &buf)
            
        
        case let .nonFungibleResourceManager(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedResourcePackageEvent_lift(_ buf: RustBuffer) throws -> TypedResourcePackageEvent {
    return try FfiConverterTypeTypedResourcePackageEvent.lift(buf)
}

public func FfiConverterTypeTypedResourcePackageEvent_lower(_ value: TypedResourcePackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedResourcePackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedRoleAssignmentBlueprintEvent {
    
    case setRoleEventValue(value: SetRoleEvent)
    case setOwnerRoleEventValue(value: SetOwnerRoleEvent)
    case lockOwnerRoleEventValue(value: LockOwnerRoleEvent)
}

public struct FfiConverterTypeTypedRoleAssignmentBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedRoleAssignmentBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedRoleAssignmentBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setRoleEventValue(
            value: try FfiConverterTypeSetRoleEvent.read(from: &buf)
        )
        
        case 2: return .setOwnerRoleEventValue(
            value: try FfiConverterTypeSetOwnerRoleEvent.read(from: &buf)
        )
        
        case 3: return .lockOwnerRoleEventValue(
            value: try FfiConverterTypeLockOwnerRoleEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedRoleAssignmentBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setRoleEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetRoleEvent.write(value, into: &buf)
            
        
        case let .setOwnerRoleEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSetOwnerRoleEvent.write(value, into: &buf)
            
        
        case let .lockOwnerRoleEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeLockOwnerRoleEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedRoleAssignmentBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedRoleAssignmentBlueprintEvent {
    return try FfiConverterTypeTypedRoleAssignmentBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedRoleAssignmentBlueprintEvent_lower(_ value: TypedRoleAssignmentBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedRoleAssignmentBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedRoleAssignmentPackageEvent {
    
    case roleAssignment(value: TypedRoleAssignmentBlueprintEvent)
}

public struct FfiConverterTypeTypedRoleAssignmentPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedRoleAssignmentPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedRoleAssignmentPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roleAssignment(
            value: try FfiConverterTypeTypedRoleAssignmentBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedRoleAssignmentPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roleAssignment(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedRoleAssignmentBlueprintEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedRoleAssignmentPackageEvent_lift(_ buf: RustBuffer) throws -> TypedRoleAssignmentPackageEvent {
    return try FfiConverterTypeTypedRoleAssignmentPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedRoleAssignmentPackageEvent_lower(_ value: TypedRoleAssignmentPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedRoleAssignmentPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedTwoResourcePoolBlueprintEvent {
    
    case twoResourcePoolContributionEventValue(value: TwoResourcePoolContributionEvent)
    case twoResourcePoolRedemptionEventValue(value: TwoResourcePoolRedemptionEvent)
    case twoResourcePoolWithdrawEventValue(value: TwoResourcePoolWithdrawEvent)
    case twoResourcePoolDepositEventValue(value: TwoResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedTwoResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedTwoResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedTwoResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .twoResourcePoolContributionEventValue(
            value: try FfiConverterTypeTwoResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .twoResourcePoolRedemptionEventValue(
            value: try FfiConverterTypeTwoResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .twoResourcePoolWithdrawEventValue(
            value: try FfiConverterTypeTwoResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .twoResourcePoolDepositEventValue(
            value: try FfiConverterTypeTwoResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedTwoResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .twoResourcePoolContributionEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTwoResourcePoolContributionEvent.write(value, into: &buf)
            
        
        case let .twoResourcePoolRedemptionEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTwoResourcePoolRedemptionEvent.write(value, into: &buf)
            
        
        case let .twoResourcePoolWithdrawEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTwoResourcePoolWithdrawEvent.write(value, into: &buf)
            
        
        case let .twoResourcePoolDepositEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTwoResourcePoolDepositEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedTwoResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedTwoResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedTwoResourcePoolBlueprintEvent_lower(_ value: TypedTwoResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedValidatorBlueprintEvent {
    
    case registerValidatorEventValue(value: RegisterValidatorEvent)
    case unregisterValidatorEventValue(value: UnregisterValidatorEvent)
    case stakeEventValue(value: StakeEvent)
    case unstakeEventValue(value: UnstakeEvent)
    case claimXrdEventValue(value: ClaimXrdEvent)
    case updateAcceptingStakeDelegationStateEventValue(value: UpdateAcceptingStakeDelegationStateEvent)
    case protocolUpdateReadinessSignalEventValue(value: ProtocolUpdateReadinessSignalEvent)
    case validatorEmissionAppliedEventValue(value: ValidatorEmissionAppliedEvent)
    case validatorRewardAppliedEventValue(value: ValidatorRewardAppliedEvent)
}

public struct FfiConverterTypeTypedValidatorBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedValidatorBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedValidatorBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .registerValidatorEventValue(
            value: try FfiConverterTypeRegisterValidatorEvent.read(from: &buf)
        )
        
        case 2: return .unregisterValidatorEventValue(
            value: try FfiConverterTypeUnregisterValidatorEvent.read(from: &buf)
        )
        
        case 3: return .stakeEventValue(
            value: try FfiConverterTypeStakeEvent.read(from: &buf)
        )
        
        case 4: return .unstakeEventValue(
            value: try FfiConverterTypeUnstakeEvent.read(from: &buf)
        )
        
        case 5: return .claimXrdEventValue(
            value: try FfiConverterTypeClaimXrdEvent.read(from: &buf)
        )
        
        case 6: return .updateAcceptingStakeDelegationStateEventValue(
            value: try FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.read(from: &buf)
        )
        
        case 7: return .protocolUpdateReadinessSignalEventValue(
            value: try FfiConverterTypeProtocolUpdateReadinessSignalEvent.read(from: &buf)
        )
        
        case 8: return .validatorEmissionAppliedEventValue(
            value: try FfiConverterTypeValidatorEmissionAppliedEvent.read(from: &buf)
        )
        
        case 9: return .validatorRewardAppliedEventValue(
            value: try FfiConverterTypeValidatorRewardAppliedEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedValidatorBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .registerValidatorEventValue(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRegisterValidatorEvent.write(value, into: &buf)
            
        
        case let .unregisterValidatorEventValue(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnregisterValidatorEvent.write(value, into: &buf)
            
        
        case let .stakeEventValue(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeStakeEvent.write(value, into: &buf)
            
        
        case let .unstakeEventValue(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeUnstakeEvent.write(value, into: &buf)
            
        
        case let .claimXrdEventValue(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeClaimXrdEvent.write(value, into: &buf)
            
        
        case let .updateAcceptingStakeDelegationStateEventValue(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.write(value, into: &buf)
            
        
        case let .protocolUpdateReadinessSignalEventValue(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeProtocolUpdateReadinessSignalEvent.write(value, into: &buf)
            
        
        case let .validatorEmissionAppliedEventValue(value):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorEmissionAppliedEvent.write(value, into: &buf)
            
        
        case let .validatorRewardAppliedEventValue(value):
            writeInt(&buf, Int32(9))
            FfiConverterTypeValidatorRewardAppliedEvent.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedValidatorBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedValidatorBlueprintEvent {
    return try FfiConverterTypeTypedValidatorBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedValidatorBlueprintEvent_lower(_ value: TypedValidatorBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedValidatorBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UpperBound {
    
    case inclusive(value: Decimal)
    case unbounded
}

public struct FfiConverterTypeUpperBound: FfiConverterRustBuffer {
    typealias SwiftType = UpperBound

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpperBound {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inclusive(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .unbounded
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UpperBound, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .inclusive(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case .unbounded:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeUpperBound_lift(_ buf: RustBuffer) throws -> UpperBound {
    return try FfiConverterTypeUpperBound.lift(buf)
}

public func FfiConverterTypeUpperBound_lower(_ value: UpperBound) -> RustBuffer {
    return FfiConverterTypeUpperBound.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WithdrawResourceEvent {
    
    case amount(value: Decimal)
    case ids(value: [NonFungibleLocalId])
}

public struct FfiConverterTypeWithdrawResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = WithdrawResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WithdrawResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(
            value: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .ids(
            value: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WithdrawResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(value, into: &buf)
            
        
        case let .ids(value):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWithdrawResourceEvent_lift(_ buf: RustBuffer) throws -> WithdrawResourceEvent {
    return try FfiConverterTypeWithdrawResourceEvent.lift(buf)
}

public func FfiConverterTypeWithdrawResourceEvent_lower(_ value: WithdrawResourceEvent) -> RustBuffer {
    return FfiConverterTypeWithdrawResourceEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WithdrawStrategy {
    
    case exact
    case rounded(roundingMode: RoundingMode)
}

public struct FfiConverterTypeWithdrawStrategy: FfiConverterRustBuffer {
    typealias SwiftType = WithdrawStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WithdrawStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exact
        
        case 2: return .rounded(
            roundingMode: try FfiConverterTypeRoundingMode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WithdrawStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exact:
            writeInt(&buf, Int32(1))
        
        
        case let .rounded(roundingMode):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRoundingMode.write(roundingMode, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWithdrawStrategy_lift(_ buf: RustBuffer) throws -> WithdrawStrategy {
    return try FfiConverterTypeWithdrawStrategy.lift(buf)
}

public func FfiConverterTypeWithdrawStrategy_lower(_ value: WithdrawStrategy) -> RustBuffer {
    return FfiConverterTypeWithdrawStrategy.lower(value)
}


extension WithdrawStrategy: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Signer Callback Interface

public protocol Signer : AnyObject {
    func sign(hash: Hash)  -> Data
    func signToSignature(hash: Hash)  -> SignatureV1
    func signToSignatureWithPublicKey(hash: Hash)  -> SignatureWithPublicKeyV1
    func publicKey()  -> PublicKey
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSigner : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeSign(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.sign(
                    hash:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterData.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeSignToSignature(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.signToSignature(
                    hash:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeSignatureV1.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeSignToSignatureWithPublicKey(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.signToSignatureWithPublicKey(
                    hash:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeSignatureWithPublicKeyV1.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokePublicKey(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.publicKey(
                    )
            var writer = [UInt8]()
            FfiConverterTypePublicKey.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSigner.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeSign(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeSignToSignature(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeSignToSignatureWithPublicKey(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokePublicKey(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSigner {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(foreignCallbackCallbackInterfaceSigner, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Signer>()
}

extension FfiConverterCallbackInterfaceSigner : FfiConverter {
    typealias SwiftType = Signer
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAccessRule: FfiConverterRustBuffer {
    typealias SwiftType = AccessRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccessRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccessRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = Decimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePreciseDecimal: FfiConverterRustBuffer {
    typealias SwiftType = PreciseDecimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePreciseDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePreciseDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTransactionManifestV2: FfiConverterRustBuffer {
    typealias SwiftType = TransactionManifestV2?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionManifestV2.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionManifestV2.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeManifestBuilderAddressReservation: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderAddressReservation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeManifestBuilderAddressReservation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeManifestBuilderAddressReservation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeResourceManagerRole: FfiConverterRustBuffer {
    typealias SwiftType = ResourceManagerRole?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResourceManagerRole.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResourceManagerRole.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSchema: FfiConverterRustBuffer {
    typealias SwiftType = Schema?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSchema.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSchema.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMetadataValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMetadataValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMetadataValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt64: FfiConverterRustBuffer {
    typealias SwiftType = [Int64]

    public static func write(_ value: [Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int64] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = [Decimal]

    public static func write(_ value: [Decimal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDecimal.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Decimal] {
        let len: Int32 = try readInt(&buf)
        var seq = [Decimal]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDecimal.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeHash: FfiConverterRustBuffer {
    typealias SwiftType = [Hash]

    public static func write(_ value: [Hash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Hash] {
        let len: Int32 = try readInt(&buf)
        var seq = [Hash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHash.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSubintentV2: FfiConverterRustBuffer {
    typealias SwiftType = [SubintentV2]

    public static func write(_ value: [SubintentV2], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSubintentV2.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SubintentV2] {
        let len: Int32 = try readInt(&buf)
        var seq = [SubintentV2]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSubintentV2.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestBuilderBucket: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestBuilderBucket]

    public static func write(_ value: [ManifestBuilderBucket], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestBuilderBucket.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestBuilderBucket] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestBuilderBucket]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestBuilderBucket.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestBuilderMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestBuilderMapEntry]

    public static func write(_ value: [ManifestBuilderMapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestBuilderMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestBuilderMapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestBuilderMapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestBuilderMapEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [MapEntry]

    public static func write(_ value: [MapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [MapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMapEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolContribution]

    public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolContribution]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedPoolContribution.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolRedemption]

    public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolRedemption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorClaim]

    public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorStake]

    public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorStake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedValidatorStake.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTrackedValidatorUnstake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorUnstake]

    public static func write(_ value: [TrackedValidatorUnstake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorUnstake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorUnstake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorUnstake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedValidatorUnstake.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnstakeDataEntry: FfiConverterRustBuffer {
    typealias SwiftType = [UnstakeDataEntry]

    public static func write(_ value: [UnstakeDataEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnstakeDataEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnstakeDataEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnstakeDataEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnstakeDataEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAccountDeposit: FfiConverterRustBuffer {
    typealias SwiftType = [AccountDeposit]

    public static func write(_ value: [AccountDeposit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountDeposit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountDeposit] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountDeposit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountDeposit.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = [AccountWithdraw]

    public static func write(_ value: [AccountWithdraw], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountWithdraw.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountWithdraw] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountWithdraw]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountWithdraw.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [DetailedManifestClass]

    public static func write(_ value: [DetailedManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDetailedManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DetailedManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [DetailedManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDetailedManifestClass.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = [EntityType]

    public static func write(_ value: [EntityType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntityType.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeInstructionV1: FfiConverterRustBuffer {
    typealias SwiftType = [InstructionV1]

    public static func write(_ value: [InstructionV1], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInstructionV1.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InstructionV1] {
        let len: Int32 = try readInt(&buf)
        var seq = [InstructionV1]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInstructionV1.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeInstructionV2: FfiConverterRustBuffer {
    typealias SwiftType = [InstructionV2]

    public static func write(_ value: [InstructionV2], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInstructionV2.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InstructionV2] {
        let len: Int32 = try readInt(&buf)
        var seq = [InstructionV2]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInstructionV2.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestBuilderValue: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestBuilderValue]

    public static func write(_ value: [ManifestBuilderValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestBuilderValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestBuilderValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestBuilderValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestBuilderValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestClass]

    public static func write(_ value: [ManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestClass.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestValue]

    public static func write(_ value: [ManifestValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIndicator]

    public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIndicator.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIndicator]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceIndicator.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceSpecifier]

    public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceSpecifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceSpecifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceSpecifier.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSignatureWithPublicKeyV1: FfiConverterRustBuffer {
    typealias SwiftType = [SignatureWithPublicKeyV1]

    public static func write(_ value: [SignatureWithPublicKeyV1], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSignatureWithPublicKeyV1.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SignatureWithPublicKeyV1] {
        let len: Int32 = try readInt(&buf)
        var seq = [SignatureWithPublicKeyV1]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSignatureWithPublicKeyV1.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [[PublicKey]]

    public static func write(_ value: [[PublicKey]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[PublicKey]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[PublicKey]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceTypeSignatureWithPublicKeyV1: FfiConverterRustBuffer {
    typealias SwiftType = [[SignatureWithPublicKeyV1]]

    public static func write(_ value: [[SignatureWithPublicKeyV1]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeSignatureWithPublicKeyV1.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[SignatureWithPublicKeyV1]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[SignatureWithPublicKeyV1]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeSignatureWithPublicKeyV1.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeDecimal: FfiConverterRustBuffer {
    public static func write(_ value: [String: Decimal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeDecimal.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Decimal] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Decimal]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeDecimal.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeMetadataInitEntry: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetadataInitEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMetadataInitEntry.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetadataInitEntry] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetadataInitEntry]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMetadataInitEntry.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeValidatorInfo: FfiConverterRustBuffer {
    public static func write(_ value: [String: ValidatorInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeValidatorInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ValidatorInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ValidatorInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeValidatorInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeAccountDefaultDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [String: AccountDefaultDepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeAccountDefaultDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: AccountDefaultDepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: AccountDefaultDepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeAccountDefaultDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeManifestResourceConstraint: FfiConverterRustBuffer {
    public static func write(_ value: [String: ManifestResourceConstraint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeManifestResourceConstraint.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ManifestResourceConstraint] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ManifestResourceConstraint]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeManifestResourceConstraint.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [String: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ResourcePreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ResourcePreferenceUpdate]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeResourceSpecifier: FfiConverterRustBuffer {
    public static func write(_ value: [String: ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeResourceSpecifier.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ResourceSpecifier]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeResourceSpecifier.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeAccessRule: FfiConverterRustBuffer {
    public static func write(_ value: [String: AccessRule?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeAccessRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: AccessRule?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: AccessRule?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeAccessRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetadataValue?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetadataValue?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetadataValue?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeAccountDeposit: FfiConverterRustBuffer {
    public static func write(_ value: [String: [AccountDeposit]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeAccountDeposit.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [AccountDeposit]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [AccountDeposit]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeAccountDeposit.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    public static func write(_ value: [String: [AccountWithdraw]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeAccountWithdraw.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [AccountWithdraw]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [AccountWithdraw]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeAccountWithdraw.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ResourceIndicator]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ResourceIndicator]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ResourceIndicator]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ResourceOrNonFungible]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ResourceOrNonFungible]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ResourceSpecifier]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeResourceSpecifier.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ResourceSpecifier]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ResourceSpecifier]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceSpecifier.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: ResourcePreferenceUpdate]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: ResourcePreferenceUpdate]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MetadataValue?]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringOptionTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MetadataValue?]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MetadataValue?]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringOptionTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePublicKeyFingerprintData: FfiConverterRustBuffer {
    public static func write(_ value: [PublicKeyFingerprint: Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePublicKeyFingerprint.write(key, into: &buf)
            FfiConverterData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyFingerprint: Data] {
        let len: Int32 = try readInt(&buf)
        var dict = [PublicKeyFingerprint: Data]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePublicKeyFingerprint.read(from: &buf)
            let value = try FfiConverterData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePublicKeyFingerprintV1Data: FfiConverterRustBuffer {
    public static func write(_ value: [PublicKeyFingerprintV1: Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePublicKeyFingerprintV1.write(key, into: &buf)
            FfiConverterData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyFingerprintV1: Data] {
        let len: Int32 = try readInt(&buf)
        var dict = [PublicKeyFingerprintV1: Data]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePublicKeyFingerprintV1.read(from: &buf)
            let value = try FfiConverterData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeCurveTypeV1TypeDecryptorsByCurveV1: FfiConverterRustBuffer {
    public static func write(_ value: [CurveTypeV1: DecryptorsByCurveV1], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeCurveTypeV1.write(key, into: &buf)
            FfiConverterTypeDecryptorsByCurveV1.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CurveTypeV1: DecryptorsByCurveV1] {
        let len: Int32 = try readInt(&buf)
        var dict = [CurveTypeV1: DecryptorsByCurveV1]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeCurveTypeV1.read(from: &buf)
            let value = try FfiConverterTypeDecryptorsByCurveV1.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeCurveTypeV2TypeDecryptorsByCurveV2: FfiConverterRustBuffer {
    public static func write(_ value: [CurveTypeV2: DecryptorsByCurveV2], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeCurveTypeV2.write(key, into: &buf)
            FfiConverterTypeDecryptorsByCurveV2.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CurveTypeV2: DecryptorsByCurveV2] {
        let len: Int32 = try readInt(&buf)
        var dict = [CurveTypeV2: DecryptorsByCurveV2]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeCurveTypeV2.read(from: &buf)
            let value = try FfiConverterTypeDecryptorsByCurveV2.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress: FfiConverterRustBuffer {
    public static func write(_ value: [EntityType: [Address]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeEntityType.write(key, into: &buf)
            FfiConverterSequenceTypeAddress.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType: [Address]] {
        let len: Int32 = try readInt(&buf)
        var dict = [EntityType: [Address]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeEntityType.read(from: &buf)
            let value = try FfiConverterSequenceTypeAddress.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias HashableBytes = Data
public struct FfiConverterTypeHashableBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashableBytes {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: HashableBytes, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> HashableBytes {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: HashableBytes) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


public func FfiConverterTypeHashableBytes_lift(_ value: RustBuffer) throws -> HashableBytes {
    return try FfiConverterTypeHashableBytes.lift(value)
}

public func FfiConverterTypeHashableBytes_lower(_ value: HashableBytes) -> RustBuffer {
    return FfiConverterTypeHashableBytes.lower(value)
}


public func deriveGlobalCallerNonFungibleGlobalIdFromComponentAddress(componentAddress: Address, networkId: UInt8) throws -> NonFungibleGlobalId {
    return try  FfiConverterTypeNonFungibleGlobalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_global_caller_non_fungible_global_id_from_component_address(
        FfiConverterTypeAddress.lower(componentAddress),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func deriveOlympiaAccountAddressFromPublicKey(publicKey: PublicKey, olympiaNetwork: OlympiaNetwork) throws -> OlympiaAddress {
    return try  FfiConverterTypeOlympiaAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeOlympiaNetwork.lower(olympiaNetwork),$0)
}
    )
}

public func derivePackageOfDirectCallerNonFungibleGlobalIdFromComponentAddress(packageAddress: Address, networkId: UInt8) throws -> NonFungibleGlobalId {
    return try  FfiConverterTypeNonFungibleGlobalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_package_of_direct_caller_non_fungible_global_id_from_component_address(
        FfiConverterTypeAddress.lower(packageAddress),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func derivePreallocatedAccountAddressFromOlympiaAccountAddress(olympiaAccountAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_preallocated_account_address_from_olympia_account_address(
        FfiConverterTypeOlympiaAddress.lower(olympiaAccountAddress),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func derivePreallocatedAccountAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_preallocated_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func derivePreallocatedIdentityAddressFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_preallocated_identity_address_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func derivePublicKeyFromOlympiaAccountAddress(olympiaResourceAddress: OlympiaAddress) throws -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address(
        FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress),$0)
}
    )
}

public func deriveResourceAddressFromOlympiaResourceAddress(olympiaResourceAddress: OlympiaAddress, networkId: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address(
        FfiConverterTypeOlympiaAddress.lower(olympiaResourceAddress),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func deriveSignatureBadgeNonFungibleGlobalIdFromPublicKey(publicKey: PublicKey, networkId: UInt8) throws -> NonFungibleGlobalId {
    return try  FfiConverterTypeNonFungibleGlobalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_signature_badge_non_fungible_global_id_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func getBuildInformation()  -> BuildInformation {
    return try!  FfiConverterTypeBuildInformation.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_get_build_information($0)
}
    )
}

public func getHash(data: Data)  -> Hash {
    return try!  FfiConverterTypeHash.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_get_hash(
        FfiConverterData.lower(data),$0)
}
    )
}

public func getKnownAddresses(networkId: UInt8)  -> KnownAddresses {
    return try!  FfiConverterTypeKnownAddresses.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_get_known_addresses(
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func manifestSborDecodeToStringRepresentation(bytes: Data, representation: ManifestSborStringRepresentation, networkId: UInt8, schema: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation(
        FfiConverterData.lower(bytes),
        FfiConverterTypeManifestSborStringRepresentation.lower(representation),
        FfiConverterUInt8.lower(networkId),
        FfiConverterOptionTypeSchema.lower(schema),$0)
}
    )
}

public func metadataSborDecode(bytes: Data, networkId: UInt8) throws -> MetadataValue {
    return try  FfiConverterTypeMetadataValue.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode(
        FfiConverterData.lower(bytes),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func metadataSborEncode(value: MetadataValue) throws -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode(
        FfiConverterTypeMetadataValue.lower(value),$0)
}
    )
}

public func nonFungibleLocalIdAsStr(value: NonFungibleLocalId) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str(
        FfiConverterTypeNonFungibleLocalId.lower(value),$0)
}
    )
}

public func nonFungibleLocalIdFromStr(string: String) throws -> NonFungibleLocalId {
    return try  FfiConverterTypeNonFungibleLocalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str(
        FfiConverterString.lower(string),$0)
}
    )
}

public func nonFungibleLocalIdSborDecode(bytes: Data) throws -> NonFungibleLocalId {
    return try  FfiConverterTypeNonFungibleLocalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode(
        FfiConverterData.lower(bytes),$0)
}
    )
}

public func nonFungibleLocalIdSborEncode(value: NonFungibleLocalId) throws -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode(
        FfiConverterTypeNonFungibleLocalId.lower(value),$0)
}
    )
}

public func publicKeyFingerprintV1FromVec(bytes: Data)  -> PublicKeyFingerprintV1 {
    return try!  FfiConverterTypePublicKeyFingerprintV1.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_v1_from_vec(
        FfiConverterData.lower(bytes),$0)
}
    )
}

public func publicKeyFingerprintV1ToVec(value: PublicKeyFingerprintV1)  -> Data {
    return try!  FfiConverterData.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_v1_to_vec(
        FfiConverterTypePublicKeyFingerprintV1.lower(value),$0)
}
    )
}

public func publicKeyFingerprintV2FromVec(bytes: Data)  -> PublicKeyFingerprint {
    return try!  FfiConverterTypePublicKeyFingerprint.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_v2_from_vec(
        FfiConverterData.lower(bytes),$0)
}
    )
}

public func publicKeyFingerprintV2ToVec(value: PublicKeyFingerprint)  -> Data {
    return try!  FfiConverterData.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_v2_to_vec(
        FfiConverterTypePublicKeyFingerprint.lower(value),$0)
}
    )
}

public func sborDecodeToStringRepresentation(bytes: Data, representation: SerializationMode, networkId: UInt8, schema: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation(
        FfiConverterData.lower(bytes),
        FfiConverterTypeSerializationMode.lower(representation),
        FfiConverterUInt8.lower(networkId),
        FfiConverterOptionTypeSchema.lower(schema),$0)
}
    )
}

public func scryptoSborDecodeToNativeEvent(eventTypeIdentifier: EventTypeIdentifier, eventData: Data, networkId: UInt8) throws -> TypedNativeEvent {
    return try  FfiConverterTypeTypedNativeEvent.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_native_event(
        FfiConverterTypeEventTypeIdentifier.lower(eventTypeIdentifier),
        FfiConverterData.lower(eventData),
        FfiConverterUInt8.lower(networkId),$0)
}
    )
}

public func scryptoSborDecodeToStringRepresentation(bytes: Data, representation: SerializationMode, networkId: UInt8, schema: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation(
        FfiConverterData.lower(bytes),
        FfiConverterTypeSerializationMode.lower(representation),
        FfiConverterUInt8.lower(networkId),
        FfiConverterOptionTypeSchema.lower(schema),$0)
}
    )
}

public func scryptoSborEncodeStringRepresentation(representation: ScryptoSborString) throws -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation(
        FfiConverterTypeScryptoSborString.lower(representation),$0)
}
    )
}

public func testPanic(message: String) throws {
    try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic(
        FfiConverterString.lower(message),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_global_caller_non_fungible_global_id_from_component_address() != 25519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key() != 19647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_package_of_direct_caller_non_fungible_global_id_from_component_address() != 37898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_preallocated_account_address_from_olympia_account_address() != 54) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_preallocated_account_address_from_public_key() != 57908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_preallocated_identity_address_from_public_key() != 26480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address() != 45205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address() != 11639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_signature_badge_non_fungible_global_id_from_public_key() != 47850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_get_build_information() != 61037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_get_hash() != 23353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_get_known_addresses() != 16556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation() != 19578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode() != 54114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode() != 11090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str() != 10663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str() != 27404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode() != 5482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode() != 44017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_v1_from_vec() != 25402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_v1_to_vec() != 206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_v2_from_vec() != 21486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_v2_to_vec() != 14661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation() != 11831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_native_event() != 58943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation() != 50232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation() != 24947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic() != 25407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and() != 5785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or() != 27266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string() != 5709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type() != 40172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global() != 25808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component() != 58252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager() != 48841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager() != 55847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager() != 16959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package() != 10761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_preallocated() != 59221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager() != 34705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal() != 34745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault() != 26605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store() != 4366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault() != 30524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault() != 10507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id() != 20026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 31072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 42883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 18756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling() != 62165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 25038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than() != 16609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal() != 3170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative() != 27762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive() != 15349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero() != 27694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than() != 30546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal() != 2387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa() != 41794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 18912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal() != 61801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root() != 6178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 35861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 31873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 26365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_to_le_bytes() != 17037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv1_as_str() != 31128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv1_instructions_list() != 39835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv1_network_id() != 57001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv2_as_str() != 15711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv2_instructions_list() != 30444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructionsv2_network_id() != 23684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_blobs() != 35056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_children() != 63939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_header() != 42313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_instructions() != 30446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_into_subintent() != 3577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentcorev2_message() != 9657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_hash() != 25295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_header() != 46007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_intent_hash() != 7772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_manifest() != 9393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_message() != 52669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_statically_validate() != 12456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intentv1_to_payload_bytes() != 52266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_cancel_primary_role_badge_withdraw_attempt() != 60531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_cancel_primary_role_recovery_proposal() != 8817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_cancel_recovery_role_badge_withdraw_attempt() != 16478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_cancel_recovery_role_recovery_proposal() != 35272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_create() != 35312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_create_proof() != 27962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_create_with_security_structure() != 41437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_initiate_badge_withdraw_as_primary() != 58093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_initiate_badge_withdraw_as_recovery() != 5978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_initiate_recovery_as_primary() != 22846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_initiate_recovery_as_recovery() != 4060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_lock_primary_role() != 58099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_mint_recovery_badges() != 41443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_new_from_public_keys() != 56637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt() != 41101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_quick_confirm_primary_role_recovery_proposal() != 26388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt() != 26819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_quick_confirm_recovery_role_recovery_proposal() != 22260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_stop_timed_recovery() != 6246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_timed_confirm_recovery() != 54754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_access_controller_unlock_primary_role() != 48648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_add_authorized_depositor() != 12277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_burn() != 57724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_burn_non_fungibles() != 41992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_create() != 23699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_create_advanced() != 58004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_create_proof_of_amount() != 25465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_create_proof_of_non_fungibles() != 11505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_deposit() != 31148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_deposit_batch() != 1563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_deposit_entire_worktop() != 39520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_lock_contingent_fee() != 26646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_lock_fee() != 58072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_lock_fee_and_withdraw() != 502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_lock_fee_and_withdraw_non_fungibles() != 53305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_airdrop() != 49282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_claim() != 29828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_claim_non_fungibles() != 41808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_get_amount() != 41686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_get_non_fungible_local_ids() != 20198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_instantiate() != 36961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_instantiate_simple() != 20970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_recover() != 24835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_recover_non_fungibles() != 21986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_locker_store() != 33048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_remove_authorized_depositor() != 2590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_remove_resource_preference() != 25208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_securify() != 19075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_set_default_deposit_rule() != 43162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_set_resource_preference() != 25573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_batch_or_abort() != 7148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_batch_or_refund() != 20454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_entire_worktop_or_abort() != 20038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_entire_worktop_or_refund() != 16818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_or_abort() != 11985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_try_deposit_or_refund() != 10519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_withdraw() != 18692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_account_withdraw_non_fungibles() != 53016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_allocate_global_address() != 46029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_assert_worktop_contains() != 36403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_assert_worktop_contains_any() != 37888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_assert_worktop_contains_non_fungibles() != 35596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_build() != 29340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_burn_resource() != 58332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_access_rules_method() != 24143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_direct_vault_method() != 43046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_function() != 21038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_metadata_method() != 25760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_method() != 19609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_call_royalty_method() != 22006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_clone_proof() != 56236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_fungible_resource_manager() != 56966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_auth_zone_of_all() != 50330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_auth_zone_of_amount() != 21961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_auth_zone_of_non_fungibles() != 51504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_bucket_of_all() != 1032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_bucket_of_amount() != 47905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_create_proof_from_bucket_of_non_fungibles() != 373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_drop_all_proofs() != 63018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_drop_auth_zone_proofs() != 23844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_drop_auth_zone_signature_proofs() != 43912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_drop_proof() != 15794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_faucet_free_xrd() != 47292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_faucet_lock_fee() != 8590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_identity_create() != 43498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_identity_create_advanced() != 16521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_identity_securify() != 19339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_metadata_get() != 53144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_metadata_lock() != 4573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_metadata_remove() != 43632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_metadata_set() != 65149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_mint_fungible() != 56621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_contribute() != 34378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_get_redemption_value() != 22642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_get_vault_amount() != 49212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_instantiate() != 37955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_protected_deposit() != 49988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_protected_withdraw() != 51169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_multi_resource_pool_redeem() != 14336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_contribute() != 7573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_get_redemption_value() != 12824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_get_vault_amount() != 40253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_instantiate() != 47027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_protected_deposit() != 51072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_protected_withdraw() != 28364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_one_resource_pool_redeem() != 30657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_package_claim_royalty() != 58285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_package_publish() != 54702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_package_publish_advanced() != 13809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_pop_from_auth_zone() != 47232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_push_to_auth_zone() != 7649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_return_to_worktop() != 7068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_role_assignment_get() != 8943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_role_assignment_lock_owner() != 8343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_role_assignment_set() != 54453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_role_assignment_set_owner() != 49233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_royalty_claim() != 3260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_royalty_lock() != 43069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_royalty_set() != 15446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_take_all_from_worktop() != 40187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_take_from_worktop() != 41784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_take_non_fungibles_from_worktop() != 26835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_contribute() != 63652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_get_redemption_value() != 19476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_get_vault_amount() != 37680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_instantiate() != 59493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_protected_deposit() != 58737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_protected_withdraw() != 1401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_two_resource_pool_redeem() != 49803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_accepts_delegated_stake() != 28360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_claim_xrd() != 17473) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_finish_unlock_owner_stake_units() != 49096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_get_protocol_update_readiness() != 25029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_get_redemption_value() != 693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_lock_owner_stake_units() != 42510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_register() != 30436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_signal_protocol_update_readiness() != 30161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_stake() != 49515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_stake_as_owner() != 13257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_start_unlock_owner_stake_units() != 52933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_total_stake_unit_supply() != 3880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_total_stake_xrd_amount() != 59231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_unregister() != 1649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_unstake() != 56891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_update_accept_delegated_stake() != 53701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_update_fee() != 43552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv1builder_validator_update_key() != 7439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_cancel_primary_role_badge_withdraw_attempt() != 33510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_cancel_primary_role_recovery_proposal() != 33702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_cancel_recovery_role_badge_withdraw_attempt() != 20474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_cancel_recovery_role_recovery_proposal() != 62802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_create() != 34664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_create_proof() != 39379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_create_with_security_structure() != 37918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_initiate_badge_withdraw_as_primary() != 42109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_initiate_badge_withdraw_as_recovery() != 43420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_initiate_recovery_as_primary() != 51352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_initiate_recovery_as_recovery() != 37482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_lock_primary_role() != 53379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_mint_recovery_badges() != 61459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_new_from_public_keys() != 61918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt() != 14490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_quick_confirm_primary_role_recovery_proposal() != 31754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt() != 8429) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_quick_confirm_recovery_role_recovery_proposal() != 37273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_stop_timed_recovery() != 32275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_timed_confirm_recovery() != 31265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_access_controller_unlock_primary_role() != 18385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_add_authorized_depositor() != 63090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_burn() != 4502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_burn_non_fungibles() != 49170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_create() != 19500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_create_advanced() != 22780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_create_proof_of_amount() != 55207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_create_proof_of_non_fungibles() != 8925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_deposit() != 39893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_deposit_batch() != 54367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_deposit_entire_worktop() != 59338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_lock_contingent_fee() != 27507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_lock_fee() != 10837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_lock_fee_and_withdraw() != 4567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_lock_fee_and_withdraw_non_fungibles() != 22712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_airdrop() != 44690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_claim() != 15012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_claim_non_fungibles() != 48686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_get_amount() != 23353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_get_non_fungible_local_ids() != 4528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_instantiate() != 27300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_instantiate_simple() != 44417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_recover() != 51581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_recover_non_fungibles() != 11316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_locker_store() != 15149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_remove_authorized_depositor() != 26785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_remove_resource_preference() != 8050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_securify() != 22484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_set_default_deposit_rule() != 38217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_set_resource_preference() != 47757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_batch_or_abort() != 30140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_batch_or_refund() != 17973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_entire_worktop_or_abort() != 18189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_entire_worktop_or_refund() != 3430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_or_abort() != 27778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_try_deposit_or_refund() != 43918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_withdraw() != 16133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_account_withdraw_non_fungibles() != 33553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_add_instruction() != 35858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_allocate_global_address() != 19420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_assert_worktop_contains() != 52948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_assert_worktop_contains_any() != 42814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_assert_worktop_contains_non_fungibles() != 16655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_build() != 60418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_burn_resource() != 12566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_access_rules_method() != 23464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_direct_vault_method() != 34996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_function() != 46798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_metadata_method() != 12082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_method() != 19732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_call_royalty_method() != 58845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_clone_proof() != 29910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_fungible_resource_manager() != 8008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_auth_zone_of_all() != 43180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_auth_zone_of_amount() != 46492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_auth_zone_of_non_fungibles() != 11198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_bucket_of_all() != 6166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_bucket_of_amount() != 36692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_create_proof_from_bucket_of_non_fungibles() != 42676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_drop_all_proofs() != 6643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_drop_auth_zone_proofs() != 45714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_drop_auth_zone_signature_proofs() != 50588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_drop_proof() != 23537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_faucet_free_xrd() != 54032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_faucet_lock_fee() != 51943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_identity_create() != 51631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_identity_create_advanced() != 25544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_identity_securify() != 64346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_metadata_get() != 48123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_metadata_lock() != 41835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_metadata_remove() != 26501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_metadata_set() != 6610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_mint_fungible() != 47316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_contribute() != 34502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_get_redemption_value() != 44971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_get_vault_amount() != 15355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_instantiate() != 30062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_protected_deposit() != 45754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_protected_withdraw() != 49166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_multi_resource_pool_redeem() != 49990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_contribute() != 64298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_get_redemption_value() != 16153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_get_vault_amount() != 47438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_instantiate() != 4200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_protected_deposit() != 7032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_protected_withdraw() != 40018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_one_resource_pool_redeem() != 35146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_package_claim_royalty() != 33050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_package_publish() != 47159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_package_publish_advanced() != 37576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_pop_from_auth_zone() != 41570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_push_to_auth_zone() != 38749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_return_to_worktop() != 3045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_role_assignment_get() != 40328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_role_assignment_lock_owner() != 1482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_role_assignment_set() != 4736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_role_assignment_set_owner() != 50136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_royalty_claim() != 57093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_royalty_lock() != 7902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_royalty_set() != 9665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_take_all_from_worktop() != 42429) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_take_from_worktop() != 31951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_take_non_fungibles_from_worktop() != 46778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_contribute() != 57341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_get_redemption_value() != 25543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_get_vault_amount() != 23880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_instantiate() != 8171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_protected_deposit() != 19877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_protected_withdraw() != 15459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_two_resource_pool_redeem() != 8311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_use_child() != 25776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_accepts_delegated_stake() != 63270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_claim_xrd() != 14720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_finish_unlock_owner_stake_units() != 10672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_get_protocol_update_readiness() != 43346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_get_redemption_value() != 32889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_lock_owner_stake_units() != 60417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_register() != 6761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_signal_protocol_update_readiness() != 37612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_stake() != 21668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_stake_as_owner() != 11392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_start_unlock_owner_stake_units() != 61315) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_total_stake_unit_supply() != 21570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_total_stake_xrd_amount() != 36484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_unregister() != 36109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_unstake() != 30979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_update_accept_delegated_stake() != 13955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_update_fee() != 5561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_validator_update_key() != 6401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_verify_parent() != 52793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_yield_to_child() != 29761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestv2builder_yield_to_parent() != 31210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str() != 12617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id() != 42729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address() != 26038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_hash() != 22172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_intent_hash() != 9212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_notarized_transaction_hash() != 51860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_notary_signature() != 51957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_signed_intent() != 36857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_signed_intent_hash() != 29894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_statically_validate() != 26435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv1_to_payload_bytes() != 59384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_hash() != 34375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_intent_hash() != 49055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_notarized_transaction_hash() != 7664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_notary_signature() != 41926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_signed_transaction_intent() != 14090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_signed_transaction_intent_hash() != 10799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_statically_validate() != 49965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransactionv2_to_payload_bytes() != 52602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str() != 211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key() != 33649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2_non_root_subintents() != 48381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2_root_subintent() != 44096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2_root_subintent_hash() != 47571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2_to_payload_bytes() != 40008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2builder_add_child() != 63936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2builder_build() != 44045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2builder_intent_header() != 22434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2builder_manifest() != 9515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_partialtransactionv2builder_message() != 49253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs() != 753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add() != 50067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str() != 50135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt() != 31353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling() != 6632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div() != 47336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal() != 35658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor() != 6297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than() != 21292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal() != 34931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative() != 11588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive() != 30868) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero() != 41566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than() != 50862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal() != 33893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa() != 2374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul() != 35568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal() != 17368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root() != 60037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi() != 57119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round() != 22122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt() != 18565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub() != 2969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_to_le_bytes() != 6841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2_non_root_subintent_signers() != 14111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2_partial_transaction() != 58385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2_root_subintent_hash() != 8019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2_root_subintent_signers() != 58907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_add_child() != 42126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_add_root_subintent_signer() != 45374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_build() != 62773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_intent_header() != 61016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_manifest() != 2732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewpartialtransactionv2builder_message() != 61966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_add_child() != 13075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_add_root_intent_signer() != 45430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_build() != 17377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_intent_header() != 11361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_manifest() != 64146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_message() != 34085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_previewtransactionv2builder_transaction_header() != 60706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_curve() != 56035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key() != 49403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key_bytes() != 8464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw() != 43216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw_hex() != 64460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign() != 21427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature() != 44322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key() != 3087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_non_root_subintent_signatures() != 60250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_partial_transaction() != 33675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_root_subintent_hash() != 56046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_root_subintent_signatures() != 17028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_statically_validate() != 18439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2_to_payload_bytes() != 13380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2builder_add_child() != 55617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2builder_intent_header() != 21500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2builder_manifest() != 15877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2builder_message() != 18736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2builder_prepare_for_signing() != 4884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2buildersignaturestep_build() != 49980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2buildersignaturestep_sign_with_private_key() != 17001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedpartialtransactionv2buildersignaturestep_sign_with_signer() != 39194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_hash() != 46173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_intent() != 32566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_intent_hash() != 8863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_intent_signatures() != 42237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_signed_intent_hash() != 55712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_statically_validate() != 13960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv1_to_payload_bytes() != 53590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_hash() != 11474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_intent_hash() != 4964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_signed_intent_hash() != 57716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_to_payload_bytes() != 16847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_transaction_intent() != 11642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedtransactionintentv2_transaction_intent_signatures() != 8514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_as_enclosed() != 7828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_blobs() != 53010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_extract_addresses() != 17889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_instructions() != 14630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_static_analysis() != 59806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_statically_validate() != 63790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentmanifestv2_to_payload_bytes() != 44508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_subintentv2_subintent_hash() != 63266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash() != 1343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str() != 9829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes() != 40875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id() != 4187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_hash() != 46670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_non_root_subintents() != 36705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_root_intent_core() != 41107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_to_payload_bytes() != 14821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_transaction_header() != 26458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionintentv2_transaction_intent_hash() != 33090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_blobs() != 37273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_dynamically_analyze() != 1239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_extract_addresses() != 24084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_instructions() != 28436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_statically_analyze() != 52728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_statically_analyze_and_validate() != 5080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_statically_validate() != 1391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv1_to_payload_bytes() != 12465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_blobs() != 59861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_dynamically_analyze() != 62016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_extract_addresses() != 31977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_instructions() != 30513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_statically_analyze() != 52561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_statically_analyze_and_validate() != 51639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_statically_validate() != 5014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifestv2_to_payload_bytes() != 126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builder_header() != 2206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builderheaderstep_manifest() != 30) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builderintentsignaturesstep_notarize_with_private_key() != 29658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builderintentsignaturesstep_notarize_with_signer() != 16311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builderintentsignaturesstep_sign_with_private_key() != 35472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1builderintentsignaturesstep_sign_with_signer() != 13661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1buildermessagestep_message() != 51476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1buildermessagestep_sign_with_private_key() != 44626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv1buildermessagestep_sign_with_signer() != 38774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_add_child() != 19864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_intent_header() != 8155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_manifest() != 24082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_message() != 7700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_prepare_for_signing() != 27222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2builder_transaction_header() != 42344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2buildersignaturestep_notarize_with_private_key() != 48137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2buildersignaturestep_notarize_with_signer() != 25051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2buildersignaturestep_sign_with_private_key() != 12688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionv2buildersignaturestep_sign_with_signer() != 49560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all() != 26074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all() != 40312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require() != 10110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of() != 11748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount() != 34714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of() != 30352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of() != 59472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_signature() != 24148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw() != 43797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new() != 37549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_preallocated_account_address_from_olympia_address() != 47319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_preallocated_account_address_from_public_key() != 41407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_preallocated_identity_address_from_public_key() != 56260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address() != 64771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_from_le_bytes() != 14760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max() != 38313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min() != 18079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new() != 15617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one() != 42470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero() != 39451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string() != 64410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes() != 17030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_sbor_decode() != 26443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructionsv1_from_instructions() != 24570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructionsv1_from_string() != 17597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructionsv2_from_instructions() != 21346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructionsv2_from_string() != 18755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intentcorev2_new() != 44152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intentv1_from_payload_bytes() != 24593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intentv1_new() != 29220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestv1builder_new() != 57381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestv2builder_new() != 15308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts() != 36478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_global_caller_badge() != 5635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new() != 58056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_package_of_direct_caller_badge() != 11141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_signature_badge() != 36312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransactionv1_from_payload_bytes() != 57930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransactionv1_new() != 39467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransactionv2_from_payload_bytes() != 53259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransactionv2_new() != 32248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new() != 12724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_partialtransactionv2_from_payload_bytes() != 49926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_partialtransactionv2_new() != 33234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_partialtransactionv2builder_new() != 30026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_from_le_bytes() != 24547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max() != 49495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min() != 4453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new() != 34846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one() != 9121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero() != 5648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_previewpartialtransactionv2_new() != 48844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_previewpartialtransactionv2builder_new() != 47773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_previewtransactionv2builder_new() != 64735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new() != 47612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519() != 4005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1() != 20991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedpartialtransactionv2_from_payload_bytes() != 60466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedpartialtransactionv2_new() != 3310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedpartialtransactionv2builder_new() != 18997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedtransactionintentv1_from_payload_bytes() != 1503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedtransactionintentv1_new() != 46779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedtransactionintentv2_from_payload_bytes() != 30111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedtransactionintentv2_new() != 13944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_subintentmanifestv2_from_payload_bytes() != 49882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_subintentmanifestv2_new() != 60741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_subintentv2_from_payload_bytes() != 32674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_subintentv2_new() != 39119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str() != 37610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionintentv2_from_payload_bytes() != 57262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionintentv2_new() != 41531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifestv1_from_payload_bytes() != 48079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifestv1_new() != 65285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifestv2_from_payload_bytes() != 25949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifestv2_new() != 60603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionv1builder_new() != 9969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionv1builderintentsignaturesstep_new() != 17328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionv2builder_new() != 62671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign() != 46892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature() != 59869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key() != 46998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key() != 61195) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}