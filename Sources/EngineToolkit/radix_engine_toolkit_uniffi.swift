// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(RadixEngineToolkit)
import RadixEngineToolkit
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_radix_engine_toolkit_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt16: FfiConverterPrimitive {
    typealias FfiType = Int16
    typealias SwiftType = Int16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int16, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol AccessRuleProtocol {
    func `and`(`other`: AccessRule)   -> AccessRule
    func `or`(`other`: AccessRule)   -> AccessRule
    
}

public class AccessRule: AccessRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule(pointer, $0) }
    }

    

    public static func `allowAll`()  -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all($0)
})
    }

    

    public static func `denyAll`()  -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all($0)
})
    }

    

    public static func `require`(`resourceOrNonFungible`: ResourceOrNonFungible) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require(
        FfiConverterTypeResourceOrNonFungible.lower(`resourceOrNonFungible`),$0)
})
    }

    

    public static func `requireAllOf`(`resources`: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of(
        FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),$0)
})
    }

    

    public static func `requireAmount`(`amount`: Decimal, `resource`: Address) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount(
        FfiConverterTypeDecimal.lower(`amount`),
        FfiConverterTypeAddress.lower(`resource`),$0)
})
    }

    

    public static func `requireAnyOf`(`resources`: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of(
        FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),$0)
})
    }

    

    public static func `requireCountOf`(`count`: UInt8, `resources`: [ResourceOrNonFungible]) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of(
        FfiConverterUInt8.lower(`count`),
        FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),$0)
})
    }

    

    public static func `requireVirtualSignature`(`publicKey`: PublicKey) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature(
        FfiConverterTypePublicKey.lower(`publicKey`),$0)
})
    }

    

    
    

    public func `and`(`other`: AccessRule)  -> AccessRule {
        return try!  FfiConverterTypeAccessRule.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and(self.pointer, 
        FfiConverterTypeAccessRule.lower(`other`),$0
    )
}
        )
    }

    public func `or`(`other`: AccessRule)  -> AccessRule {
        return try!  FfiConverterTypeAccessRule.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or(self.pointer, 
        FfiConverterTypeAccessRule.lower(`other`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeAccessRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AccessRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AccessRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AccessRule {
        return AccessRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AccessRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAccessRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> AccessRule {
    return try FfiConverterTypeAccessRule.lift(pointer)
}

public func FfiConverterTypeAccessRule_lower(_ value: AccessRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAccessRule.lower(value)
}


public protocol AddressProtocol {
    func `addressString`()   -> String
    func `asStr`()   -> String
    func `bytes`()   -> [UInt8]
    func `entityType`()   -> EntityType
    func `isGlobal`()   -> Bool
    func `isGlobalComponent`()   -> Bool
    func `isGlobalConsensusManager`()   -> Bool
    func `isGlobalFungibleResourceManager`()   -> Bool
    func `isGlobalNonFungibleResourceManager`()   -> Bool
    func `isGlobalPackage`()   -> Bool
    func `isGlobalResourceManager`()   -> Bool
    func `isGlobalVirtual`()   -> Bool
    func `isInternal`()   -> Bool
    func `isInternalFungibleVault`()   -> Bool
    func `isInternalKvStore`()   -> Bool
    func `isInternalNonFungibleVault`()   -> Bool
    func `isInternalVault`()   -> Bool
    func `networkId`()   -> UInt8
    
}

public class Address: AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`address`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new(
        FfiConverterString.lower(`address`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_address(pointer, $0) }
    }

    

    public static func `fromRaw`(`nodeIdBytes`: [UInt8], `networkId`: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw(
        FfiConverterSequenceUInt8.lower(`nodeIdBytes`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    public static func `resourceAddressFromOlympiaResourceAddress`(`olympiaResourceAddress`: OlympiaAddress, `networkId`: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address(
        FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    public static func `virtualAccountAddressFromOlympiaAddress`(`olympiaAccountAddress`: OlympiaAddress, `networkId`: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address(
        FfiConverterTypeOlympiaAddress.lower(`olympiaAccountAddress`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    public static func `virtualAccountAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    public static func `virtualIdentityAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> Address {
        return Address(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    
    

    public func `addressString`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string(self.pointer, $0
    )
}
        )
    }

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str(self.pointer, $0
    )
}
        )
    }

    public func `bytes`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes(self.pointer, $0
    )
}
        )
    }

    public func `entityType`()  -> EntityType {
        return try!  FfiConverterTypeEntityType.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type(self.pointer, $0
    )
}
        )
    }

    public func `isGlobal`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalComponent`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalConsensusManager`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalFungibleResourceManager`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalNonFungibleResourceManager`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalPackage`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalResourceManager`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager(self.pointer, $0
    )
}
        )
    }

    public func `isGlobalVirtual`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual(self.pointer, $0
    )
}
        )
    }

    public func `isInternal`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal(self.pointer, $0
    )
}
        )
    }

    public func `isInternalFungibleVault`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault(self.pointer, $0
    )
}
        )
    }

    public func `isInternalKvStore`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store(self.pointer, $0
    )
}
        )
    }

    public func `isInternalNonFungibleVault`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault(self.pointer, $0
    )
}
        )
    }

    public func `isInternalVault`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault(self.pointer, $0
    )
}
        )
    }

    public func `networkId`()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}


public protocol DecimalProtocol {
    func `abs`()  throws -> Decimal
    func `add`(`other`: Decimal)  throws -> Decimal
    func `asStr`()   -> String
    func `cbrt`()  throws -> Decimal
    func `ceiling`()  throws -> Decimal
    func `div`(`other`: Decimal)  throws -> Decimal
    func `equal`(`other`: Decimal)   -> Bool
    func `floor`()  throws -> Decimal
    func `greaterThan`(`other`: Decimal)   -> Bool
    func `greaterThanOrEqual`(`other`: Decimal)   -> Bool
    func `isNegative`()   -> Bool
    func `isPositive`()   -> Bool
    func `isZero`()   -> Bool
    func `lessThan`(`other`: Decimal)   -> Bool
    func `lessThanOrEqual`(`other`: Decimal)   -> Bool
    func `mul`(`other`: Decimal)  throws -> Decimal
    func `notEqual`(`other`: Decimal)   -> Bool
    func `nthRoot`(`n`: UInt32)   -> Decimal?
    func `powi`(`exp`: Int64)  throws -> Decimal
    func `round`(`decimalPlaces`: Int32, `roundingMode`: RoundingMode)  throws -> Decimal
    func `sqrt`()   -> Decimal?
    func `sub`(`other`: Decimal)  throws -> Decimal
    
}

public class Decimal: DecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`value`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new(
        FfiConverterString.lower(`value`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_decimal(pointer, $0) }
    }

    

    public static func `max`()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max($0)
})
    }

    

    public static func `min`()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min($0)
})
    }

    

    public static func `one`()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one($0)
})
    }

    

    public static func `zero`()  -> Decimal {
        return Decimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero($0)
})
    }

    

    
    

    public func `abs`() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs(self.pointer, $0
    )
}
        )
    }

    public func `add`(`other`: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str(self.pointer, $0
    )
}
        )
    }

    public func `cbrt`() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt(self.pointer, $0
    )
}
        )
    }

    public func `ceiling`() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling(self.pointer, $0
    )
}
        )
    }

    public func `div`(`other`: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `equal`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `floor`() throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor(self.pointer, $0
    )
}
        )
    }

    public func `greaterThan`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `greaterThanOrEqual`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `isNegative`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative(self.pointer, $0
    )
}
        )
    }

    public func `isPositive`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive(self.pointer, $0
    )
}
        )
    }

    public func `isZero`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero(self.pointer, $0
    )
}
        )
    }

    public func `lessThan`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `lessThanOrEqual`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `mul`(`other`: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `notEqual`(`other`: Decimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `nthRoot`(`n`: UInt32)  -> Decimal? {
        return try!  FfiConverterOptionTypeDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root(self.pointer, 
        FfiConverterUInt32.lower(`n`),$0
    )
}
        )
    }

    public func `powi`(`exp`: Int64) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi(self.pointer, 
        FfiConverterInt64.lower(`exp`),$0
    )
}
        )
    }

    public func `round`(`decimalPlaces`: Int32, `roundingMode`: RoundingMode) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round(self.pointer, 
        FfiConverterInt32.lower(`decimalPlaces`),
        FfiConverterTypeRoundingMode.lower(`roundingMode`),$0
    )
}
        )
    }

    public func `sqrt`()  -> Decimal? {
        return try!  FfiConverterOptionTypeDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt(self.pointer, $0
    )
}
        )
    }

    public func `sub`(`other`: Decimal) throws -> Decimal {
        return try  FfiConverterTypeDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub(self.pointer, 
        FfiConverterTypeDecimal.lower(`other`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Decimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Decimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
        return Decimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Decimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> Decimal {
    return try FfiConverterTypeDecimal.lift(pointer)
}

public func FfiConverterTypeDecimal_lower(_ value: Decimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDecimal.lower(value)
}


public protocol HashProtocol {
    func `asStr`()   -> String
    func `bytes`()   -> [UInt8]
    
}

public class Hash: HashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`hash`: [UInt8]) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new(
        FfiConverterSequenceUInt8.lower(`hash`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_hash(pointer, $0) }
    }

    

    public static func `fromHexString`(`hash`: String) throws -> Hash {
        return Hash(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string(
        FfiConverterString.lower(`hash`),$0)
})
    }

    

    public static func `fromUnhashedBytes`(`bytes`: [UInt8])  -> Hash {
        return Hash(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes(
        FfiConverterSequenceUInt8.lower(`bytes`),$0)
})
    }

    

    
    

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str(self.pointer, $0
    )
}
        )
    }

    public func `bytes`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Hash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
        return Hash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Hash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> Hash {
    return try FfiConverterTypeHash.lift(pointer)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHash.lower(value)
}


public protocol InstructionsProtocol {
    func `asStr`()  throws -> String
    func `instructionsList`()   -> [Instruction]
    func `networkId`()   -> UInt8
    
}

public class Instructions: InstructionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_instructions(pointer, $0) }
    }

    

    public static func `fromInstructions`(`instructions`: [Instruction], `networkId`: UInt8) throws -> Instructions {
        return Instructions(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions(
        FfiConverterSequenceTypeInstruction.lower(`instructions`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    public static func `fromString`(`string`: String, `networkId`: UInt8) throws -> Instructions {
        return Instructions(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string(
        FfiConverterString.lower(`string`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    
    

    public func `asStr`() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str(self.pointer, $0
    )
}
        )
    }

    public func `instructionsList`()  -> [Instruction] {
        return try!  FfiConverterSequenceTypeInstruction.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list(self.pointer, $0
    )
}
        )
    }

    public func `networkId`()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeInstructions: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Instructions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Instructions {
        return Instructions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Instructions) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeInstructions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(pointer)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInstructions.lower(value)
}


public protocol IntentProtocol {
    func `compile`()  throws -> [UInt8]
    func `hash`()  throws -> TransactionHash
    func `header`()   -> TransactionHeader
    func `intentHash`()  throws -> TransactionHash
    func `manifest`()   -> TransactionManifest
    func `message`()   -> Message
    func `staticallyValidate`(`validationConfig`: ValidationConfig)  throws
    
}

public class Intent: IntentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`header`: TransactionHeader, `manifest`: TransactionManifest, `message`: Message)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new(
        FfiConverterTypeTransactionHeader.lower(`header`),
        FfiConverterTypeTransactionManifest.lower(`manifest`),
        FfiConverterTypeMessage.lower(`message`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_intent(pointer, $0) }
    }

    

    public static func `decompile`(`compiledIntent`: [UInt8]) throws -> Intent {
        return Intent(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile(
        FfiConverterSequenceUInt8.lower(`compiledIntent`),$0)
})
    }

    

    
    

    public func `compile`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile(self.pointer, $0
    )
}
        )
    }

    public func `hash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `header`()  -> TransactionHeader {
        return try!  FfiConverterTypeTransactionHeader.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header(self.pointer, $0
    )
}
        )
    }

    public func `intentHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `manifest`()  -> TransactionManifest {
        return try!  FfiConverterTypeTransactionManifest.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest(self.pointer, $0
    )
}
        )
    }

    public func `message`()  -> Message {
        return try!  FfiConverterTypeMessage.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message(self.pointer, $0
    )
}
        )
    }

    public func `staticallyValidate`(`validationConfig`: ValidationConfig) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate(self.pointer, 
        FfiConverterTypeValidationConfig.lower(`validationConfig`),$0
    )
}
    }
}

public struct FfiConverterTypeIntent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Intent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Intent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Intent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Intent {
        return Intent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Intent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeIntent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Intent {
    return try FfiConverterTypeIntent.lift(pointer)
}

public func FfiConverterTypeIntent_lower(_ value: Intent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIntent.lower(value)
}


public protocol ManifestBuilderProtocol {
    func `accountDeposit`(`accountAddress`: Address, `bucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `accountDepositBatch`(`accountAddress`: Address)  throws -> ManifestBuilder
    func `accountTryDepositBatchOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?)  throws -> ManifestBuilder
    func `accountTryDepositBatchOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?)  throws -> ManifestBuilder
    func `accountTryDepositOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `accountTryDepositOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `allocateGlobalAddress`(`packageAddress`: Address, `blueprintName`: String, `intoAddressReservation`: ManifestBuilderAddressReservation, `intoNamedAddress`: ManifestBuilderNamedAddress)  throws -> ManifestBuilder
    func `assertWorktopContains`(`resourceAddress`: Address, `amount`: Decimal)  throws -> ManifestBuilder
    func `assertWorktopContainsAny`(`resourceAddress`: Address)  throws -> ManifestBuilder
    func `assertWorktopContainsNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])  throws -> ManifestBuilder
    func `build`(`networkId`: UInt8)   -> TransactionManifest
    func `burnResource`(`bucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `callAccessRulesMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `callDirectVaultMethod`(`address`: Address, `methodName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `callFunction`(`address`: ManifestBuilderAddress, `blueprintName`: String, `functionName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `callMetadataMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `callMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `callRoyaltyMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue])  throws -> ManifestBuilder
    func `cloneProof`(`proof`: ManifestBuilderProof, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createAccessControllerWithSecurifyStructure`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: SecurityStructureRole, `recoveryRole`: SecurityStructureRole, `confirmationRole`: SecurityStructureRole, `timedRecoveryDelayInMinutes`: UInt32?)  throws -> ManifestBuilder
    func `createAccountAdvanced`(`ownerRole`: OwnerRole)  throws -> ManifestBuilder
    func `createFungibleResourceManager`(`ownerRole`: OwnerRole, `trackTotalSupply`: Bool, `divisibility`: UInt8, `initialSupply`: Decimal?, `resourceRoles`: FungibleResourceRoles, `metadata`: MetadataModuleConfig, `addressReservation`: ManifestBuilderAddressReservation?)  throws -> ManifestBuilder
    func `createProofFromAuthZoneOfAll`(`resourceAddress`: Address, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createProofFromAuthZoneOfAmount`(`resourceAddress`: Address, `amount`: Decimal, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createProofFromAuthZoneOfNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId], `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createProofFromBucketOfAll`(`bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createProofFromBucketOfAmount`(`amount`: Decimal, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createProofFromBucketOfNonFungibles`(`ids`: [NonFungibleLocalId], `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `createSignatureBasedAccessController`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: PublicKey, `recoveryRole`: PublicKey, `confirmationRole`: PublicKey, `timedRecoveryDelayInMinutes`: UInt32?)  throws -> ManifestBuilder
    func `dropAllProofs`()  throws -> ManifestBuilder
    func `dropAuthZoneProofs`()  throws -> ManifestBuilder
    func `dropAuthZoneSignatureProofs`()  throws -> ManifestBuilder
    func `dropProof`(`proof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `faucetFreeXrd`()  throws -> ManifestBuilder
    func `faucetLockFee`()  throws -> ManifestBuilder
    func `mintFungible`(`resourceAddress`: Address, `amount`: Decimal)  throws -> ManifestBuilder
    func `popFromAuthZone`(`intoProof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `publishPackage`(`code`: [UInt8], `definition`: [UInt8], `metadata`: [String: MetadataInitEntry])  throws -> ManifestBuilder
    func `pushToAuthZone`(`proof`: ManifestBuilderProof)  throws -> ManifestBuilder
    func `returnToWorktop`(`bucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `setMetadata`(`address`: Address, `key`: String, `value`: MetadataValue)  throws -> ManifestBuilder
    func `setRole`(`address`: Address, `module`: ObjectModuleId, `roleKey`: String, `rule`: AccessRule)  throws -> ManifestBuilder
    func `takeAllFromWorktop`(`resourceAddress`: Address, `intoBucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `takeFromWorktop`(`resourceAddress`: Address, `amount`: Decimal, `intoBucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `takeNonFungiblesFromWorktop`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId], `intoBucket`: ManifestBuilderBucket)  throws -> ManifestBuilder
    func `withdrawFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `amount`: Decimal)  throws -> ManifestBuilder
    func `withdrawNonFungiblesFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `ids`: [NonFungibleLocalId])  throws -> ManifestBuilder
    
}

public class ManifestBuilder: ManifestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder(pointer, $0) }
    }

    

    
    

    public func `accountDeposit`(`accountAddress`: Address, `bucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),$0
    )
}
        )
    }

    public func `accountDepositBatch`(`accountAddress`: Address) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),$0
    )
}
        )
    }

    public func `accountTryDepositBatchOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterOptionTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),$0
    )
}
        )
    }

    public func `accountTryDepositBatchOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterOptionTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),$0
    )
}
        )
    }

    public func `accountTryDepositOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterOptionTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),$0
    )
}
        )
    }

    public func `accountTryDepositOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterOptionTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),$0
    )
}
        )
    }

    public func `allocateGlobalAddress`(`packageAddress`: Address, `blueprintName`: String, `intoAddressReservation`: ManifestBuilderAddressReservation, `intoNamedAddress`: ManifestBuilderNamedAddress) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address(self.pointer, 
        FfiConverterTypeAddress.lower(`packageAddress`),
        FfiConverterString.lower(`blueprintName`),
        FfiConverterTypeManifestBuilderAddressReservation.lower(`intoAddressReservation`),
        FfiConverterTypeManifestBuilderNamedAddress.lower(`intoNamedAddress`),$0
    )
}
        )
    }

    public func `assertWorktopContains`(`resourceAddress`: Address, `amount`: Decimal) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeDecimal.lower(`amount`),$0
    )
}
        )
    }

    public func `assertWorktopContainsAny`(`resourceAddress`: Address) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),$0
    )
}
        )
    }

    public func `assertWorktopContainsNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),$0
    )
}
        )
    }

    public func `build`(`networkId`: UInt8)  -> TransactionManifest {
        return try!  FfiConverterTypeTransactionManifest.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build(self.pointer, 
        FfiConverterUInt8.lower(`networkId`),$0
    )
}
        )
    }

    public func `burnResource`(`bucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),$0
    )
}
        )
    }

    public func `callAccessRulesMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(`address`),
        FfiConverterString.lower(`methodName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `callDirectVaultMethod`(`address`: Address, `methodName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method(self.pointer, 
        FfiConverterTypeAddress.lower(`address`),
        FfiConverterString.lower(`methodName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `callFunction`(`address`: ManifestBuilderAddress, `blueprintName`: String, `functionName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(`address`),
        FfiConverterString.lower(`blueprintName`),
        FfiConverterString.lower(`functionName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `callMetadataMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(`address`),
        FfiConverterString.lower(`methodName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `callMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(`address`),
        FfiConverterString.lower(`methodName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `callRoyaltyMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: [ManifestBuilderValue]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method(self.pointer, 
        FfiConverterTypeManifestBuilderAddress.lower(`address`),
        FfiConverterString.lower(`methodName`),
        FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),$0
    )
}
        )
    }

    public func `cloneProof`(`proof`: ManifestBuilderProof, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(`proof`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createAccessControllerWithSecurifyStructure`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: SecurityStructureRole, `recoveryRole`: SecurityStructureRole, `confirmationRole`: SecurityStructureRole, `timedRecoveryDelayInMinutes`: UInt32?) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(`controlledAsset`),
        FfiConverterTypeSecurityStructureRole.lower(`primaryRole`),
        FfiConverterTypeSecurityStructureRole.lower(`recoveryRole`),
        FfiConverterTypeSecurityStructureRole.lower(`confirmationRole`),
        FfiConverterOptionUInt32.lower(`timedRecoveryDelayInMinutes`),$0
    )
}
        )
    }

    public func `createAccountAdvanced`(`ownerRole`: OwnerRole) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced(self.pointer, 
        FfiConverterTypeOwnerRole.lower(`ownerRole`),$0
    )
}
        )
    }

    public func `createFungibleResourceManager`(`ownerRole`: OwnerRole, `trackTotalSupply`: Bool, `divisibility`: UInt8, `initialSupply`: Decimal?, `resourceRoles`: FungibleResourceRoles, `metadata`: MetadataModuleConfig, `addressReservation`: ManifestBuilderAddressReservation?) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager(self.pointer, 
        FfiConverterTypeOwnerRole.lower(`ownerRole`),
        FfiConverterBool.lower(`trackTotalSupply`),
        FfiConverterUInt8.lower(`divisibility`),
        FfiConverterOptionTypeDecimal.lower(`initialSupply`),
        FfiConverterTypeFungibleResourceRoles.lower(`resourceRoles`),
        FfiConverterTypeMetadataModuleConfig.lower(`metadata`),
        FfiConverterOptionTypeManifestBuilderAddressReservation.lower(`addressReservation`),$0
    )
}
        )
    }

    public func `createProofFromAuthZoneOfAll`(`resourceAddress`: Address, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createProofFromAuthZoneOfAmount`(`resourceAddress`: Address, `amount`: Decimal, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeDecimal.lower(`amount`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createProofFromAuthZoneOfNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId], `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createProofFromBucketOfAll`(`bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createProofFromBucketOfAmount`(`amount`: Decimal, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount(self.pointer, 
        FfiConverterTypeDecimal.lower(`amount`),
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createProofFromBucketOfNonFungibles`(`ids`: [NonFungibleLocalId], `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles(self.pointer, 
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `createSignatureBasedAccessController`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: PublicKey, `recoveryRole`: PublicKey, `confirmationRole`: PublicKey, `timedRecoveryDelayInMinutes`: UInt32?) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(`controlledAsset`),
        FfiConverterTypePublicKey.lower(`primaryRole`),
        FfiConverterTypePublicKey.lower(`recoveryRole`),
        FfiConverterTypePublicKey.lower(`confirmationRole`),
        FfiConverterOptionUInt32.lower(`timedRecoveryDelayInMinutes`),$0
    )
}
        )
    }

    public func `dropAllProofs`() throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs(self.pointer, $0
    )
}
        )
    }

    public func `dropAuthZoneProofs`() throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs(self.pointer, $0
    )
}
        )
    }

    public func `dropAuthZoneSignatureProofs`() throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs(self.pointer, $0
    )
}
        )
    }

    public func `dropProof`(`proof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(`proof`),$0
    )
}
        )
    }

    public func `faucetFreeXrd`() throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd(self.pointer, $0
    )
}
        )
    }

    public func `faucetLockFee`() throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee(self.pointer, $0
    )
}
        )
    }

    public func `mintFungible`(`resourceAddress`: Address, `amount`: Decimal) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeDecimal.lower(`amount`),$0
    )
}
        )
    }

    public func `popFromAuthZone`(`intoProof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),$0
    )
}
        )
    }

    public func `publishPackage`(`code`: [UInt8], `definition`: [UInt8], `metadata`: [String: MetadataInitEntry]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package(self.pointer, 
        FfiConverterSequenceUInt8.lower(`code`),
        FfiConverterSequenceUInt8.lower(`definition`),
        FfiConverterDictionaryStringTypeMetadataInitEntry.lower(`metadata`),$0
    )
}
        )
    }

    public func `pushToAuthZone`(`proof`: ManifestBuilderProof) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone(self.pointer, 
        FfiConverterTypeManifestBuilderProof.lower(`proof`),$0
    )
}
        )
    }

    public func `returnToWorktop`(`bucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop(self.pointer, 
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),$0
    )
}
        )
    }

    public func `setMetadata`(`address`: Address, `key`: String, `value`: MetadataValue) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata(self.pointer, 
        FfiConverterTypeAddress.lower(`address`),
        FfiConverterString.lower(`key`),
        FfiConverterTypeMetadataValue.lower(`value`),$0
    )
}
        )
    }

    public func `setRole`(`address`: Address, `module`: ObjectModuleId, `roleKey`: String, `rule`: AccessRule) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role(self.pointer, 
        FfiConverterTypeAddress.lower(`address`),
        FfiConverterTypeObjectModuleId.lower(`module`),
        FfiConverterString.lower(`roleKey`),
        FfiConverterTypeAccessRule.lower(`rule`),$0
    )
}
        )
    }

    public func `takeAllFromWorktop`(`resourceAddress`: Address, `intoBucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),$0
    )
}
        )
    }

    public func `takeFromWorktop`(`resourceAddress`: Address, `amount`: Decimal, `intoBucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeDecimal.lower(`amount`),
        FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),$0
    )
}
        )
    }

    public func `takeNonFungiblesFromWorktop`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId], `intoBucket`: ManifestBuilderBucket) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop(self.pointer, 
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),
        FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),$0
    )
}
        )
    }

    public func `withdrawFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `amount`: Decimal) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeDecimal.lower(`amount`),$0
    )
}
        )
    }

    public func `withdrawNonFungiblesFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `ids`: [NonFungibleLocalId]) throws -> ManifestBuilder {
        return try  FfiConverterTypeManifestBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account(self.pointer, 
        FfiConverterTypeAddress.lower(`accountAddress`),
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeManifestBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ManifestBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ManifestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestBuilder {
        return ManifestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ManifestBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeManifestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestBuilder {
    return try FfiConverterTypeManifestBuilder.lift(pointer)
}

public func FfiConverterTypeManifestBuilder_lower(_ value: ManifestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeManifestBuilder.lower(value)
}


public protocol MessageValidationConfigProtocol {
    func `maxDecryptors`()   -> UInt64
    func `maxEncryptedMessageLength`()   -> UInt64
    func `maxMimeTypeLength`()   -> UInt64
    func `maxPlaintextMessageLength`()   -> UInt64
    
}

public class MessageValidationConfig: MessageValidationConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`maxPlaintextMessageLength`: UInt64, `maxEncryptedMessageLength`: UInt64, `maxMimeTypeLength`: UInt64, `maxDecryptors`: UInt64)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new(
        FfiConverterUInt64.lower(`maxPlaintextMessageLength`),
        FfiConverterUInt64.lower(`maxEncryptedMessageLength`),
        FfiConverterUInt64.lower(`maxMimeTypeLength`),
        FfiConverterUInt64.lower(`maxDecryptors`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig(pointer, $0) }
    }

    

    public static func `default`()  -> MessageValidationConfig {
        return MessageValidationConfig(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default($0)
})
    }

    

    
    

    public func `maxDecryptors`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors(self.pointer, $0
    )
}
        )
    }

    public func `maxEncryptedMessageLength`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length(self.pointer, $0
    )
}
        )
    }

    public func `maxMimeTypeLength`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length(self.pointer, $0
    )
}
        )
    }

    public func `maxPlaintextMessageLength`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeMessageValidationConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MessageValidationConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageValidationConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MessageValidationConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageValidationConfig {
        return MessageValidationConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MessageValidationConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMessageValidationConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageValidationConfig {
    return try FfiConverterTypeMessageValidationConfig.lift(pointer)
}

public func FfiConverterTypeMessageValidationConfig_lower(_ value: MessageValidationConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessageValidationConfig.lower(value)
}


public protocol NonFungibleGlobalIdProtocol {
    func `asStr`()   -> String
    func `localId`()   -> NonFungibleLocalId
    func `resourceAddress`()   -> Address
    
}

public class NonFungibleGlobalId: NonFungibleGlobalIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`nonFungibleGlobalId`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new(
        FfiConverterString.lower(`nonFungibleGlobalId`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid(pointer, $0) }
    }

    

    public static func `fromParts`(`resourceAddress`: Address, `nonFungibleLocalId`: NonFungibleLocalId) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts(
        FfiConverterTypeAddress.lower(`resourceAddress`),
        FfiConverterTypeNonFungibleLocalId.lower(`nonFungibleLocalId`),$0)
})
    }

    

    public static func `virtualSignatureBadge`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    
    

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str(self.pointer, $0
    )
}
        )
    }

    public func `localId`()  -> NonFungibleLocalId {
        return try!  FfiConverterTypeNonFungibleLocalId.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id(self.pointer, $0
    )
}
        )
    }

    public func `resourceAddress`()  -> Address {
        return try!  FfiConverterTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NonFungibleGlobalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
        return NonFungibleGlobalId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNonFungibleGlobalId_lift(_ pointer: UnsafeMutableRawPointer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(pointer)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}


public protocol NotarizedTransactionProtocol {
    func `compile`()  throws -> [UInt8]
    func `hash`()  throws -> TransactionHash
    func `intentHash`()  throws -> TransactionHash
    func `notarizedTransactionHash`()  throws -> TransactionHash
    func `notarySignature`()   -> Signature
    func `signedIntent`()   -> SignedIntent
    func `signedIntentHash`()  throws -> TransactionHash
    func `staticallyValidate`(`validationConfig`: ValidationConfig)  throws
    
}

public class NotarizedTransaction: NotarizedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`signedIntent`: SignedIntent, `notarySignature`: Signature)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new(
        FfiConverterTypeSignedIntent.lower(`signedIntent`),
        FfiConverterTypeSignature.lower(`notarySignature`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction(pointer, $0) }
    }

    

    public static func `decompile`(`compiledNotarizedTransaction`: [UInt8]) throws -> NotarizedTransaction {
        return NotarizedTransaction(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile(
        FfiConverterSequenceUInt8.lower(`compiledNotarizedTransaction`),$0)
})
    }

    

    
    

    public func `compile`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile(self.pointer, $0
    )
}
        )
    }

    public func `hash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash(self.pointer, $0
    )
}
        )
    }

    public func `intentHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `notarizedTransactionHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash(self.pointer, $0
    )
}
        )
    }

    public func `notarySignature`()  -> Signature {
        return try!  FfiConverterTypeSignature.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature(self.pointer, $0
    )
}
        )
    }

    public func `signedIntent`()  -> SignedIntent {
        return try!  FfiConverterTypeSignedIntent.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent(self.pointer, $0
    )
}
        )
    }

    public func `signedIntentHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `staticallyValidate`(`validationConfig`: ValidationConfig) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate(self.pointer, 
        FfiConverterTypeValidationConfig.lower(`validationConfig`),$0
    )
}
    }
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotarizedTransaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransaction {
        return NotarizedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotarizedTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotarizedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(pointer)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}


public protocol OlympiaAddressProtocol {
    func `asStr`()   -> String
    func `publicKey`()  throws -> PublicKey
    
}

public class OlympiaAddress: OlympiaAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`address`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new(
        FfiConverterString.lower(`address`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress(pointer, $0) }
    }

    

    
    

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str(self.pointer, $0
    )
}
        )
    }

    public func `publicKey`() throws -> PublicKey {
        return try  FfiConverterTypePublicKey.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOlympiaAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlympiaAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlympiaAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
        return OlympiaAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOlympiaAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlympiaAddress {
    return try FfiConverterTypeOlympiaAddress.lift(pointer)
}

public func FfiConverterTypeOlympiaAddress_lower(_ value: OlympiaAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlympiaAddress.lower(value)
}


public protocol PreciseDecimalProtocol {
    func `abs`()  throws -> PreciseDecimal
    func `add`(`other`: PreciseDecimal)  throws -> PreciseDecimal
    func `asStr`()   -> String
    func `cbrt`()  throws -> PreciseDecimal
    func `ceiling`()  throws -> PreciseDecimal
    func `div`(`other`: PreciseDecimal)  throws -> PreciseDecimal
    func `equal`(`other`: PreciseDecimal)   -> Bool
    func `floor`()  throws -> PreciseDecimal
    func `greaterThan`(`other`: PreciseDecimal)   -> Bool
    func `greaterThanOrEqual`(`other`: PreciseDecimal)   -> Bool
    func `isNegative`()   -> Bool
    func `isPositive`()   -> Bool
    func `isZero`()   -> Bool
    func `lessThan`(`other`: PreciseDecimal)   -> Bool
    func `lessThanOrEqual`(`other`: PreciseDecimal)   -> Bool
    func `mul`(`other`: PreciseDecimal)  throws -> PreciseDecimal
    func `notEqual`(`other`: PreciseDecimal)   -> Bool
    func `nthRoot`(`n`: UInt32)   -> PreciseDecimal?
    func `powi`(`exp`: Int64)  throws -> PreciseDecimal
    func `round`(`decimalPlaces`: Int32, `roundingMode`: RoundingMode)  throws -> PreciseDecimal
    func `sqrt`()   -> PreciseDecimal?
    func `sub`(`other`: PreciseDecimal)  throws -> PreciseDecimal
    
}

public class PreciseDecimal: PreciseDecimalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`value`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new(
        FfiConverterString.lower(`value`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal(pointer, $0) }
    }

    

    public static func `max`()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max($0)
})
    }

    

    public static func `min`()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min($0)
})
    }

    

    public static func `one`()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one($0)
})
    }

    

    public static func `zero`()  -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero($0)
})
    }

    

    
    

    public func `abs`() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs(self.pointer, $0
    )
}
        )
    }

    public func `add`(`other`: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str(self.pointer, $0
    )
}
        )
    }

    public func `cbrt`() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt(self.pointer, $0
    )
}
        )
    }

    public func `ceiling`() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling(self.pointer, $0
    )
}
        )
    }

    public func `div`(`other`: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `equal`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `floor`() throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor(self.pointer, $0
    )
}
        )
    }

    public func `greaterThan`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `greaterThanOrEqual`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `isNegative`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative(self.pointer, $0
    )
}
        )
    }

    public func `isPositive`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive(self.pointer, $0
    )
}
        )
    }

    public func `isZero`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero(self.pointer, $0
    )
}
        )
    }

    public func `lessThan`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `lessThanOrEqual`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `mul`(`other`: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `notEqual`(`other`: PreciseDecimal)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }

    public func `nthRoot`(`n`: UInt32)  -> PreciseDecimal? {
        return try!  FfiConverterOptionTypePreciseDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root(self.pointer, 
        FfiConverterUInt32.lower(`n`),$0
    )
}
        )
    }

    public func `powi`(`exp`: Int64) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi(self.pointer, 
        FfiConverterInt64.lower(`exp`),$0
    )
}
        )
    }

    public func `round`(`decimalPlaces`: Int32, `roundingMode`: RoundingMode) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round(self.pointer, 
        FfiConverterInt32.lower(`decimalPlaces`),
        FfiConverterTypeRoundingMode.lower(`roundingMode`),$0
    )
}
        )
    }

    public func `sqrt`()  -> PreciseDecimal? {
        return try!  FfiConverterOptionTypePreciseDecimal.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt(self.pointer, $0
    )
}
        )
    }

    public func `sub`(`other`: PreciseDecimal) throws -> PreciseDecimal {
        return try  FfiConverterTypePreciseDecimal.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub(self.pointer, 
        FfiConverterTypePreciseDecimal.lower(`other`),$0
    )
}
        )
    }
}

public struct FfiConverterTypePreciseDecimal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PreciseDecimal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreciseDecimal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PreciseDecimal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
        return PreciseDecimal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePreciseDecimal_lift(_ pointer: UnsafeMutableRawPointer) throws -> PreciseDecimal {
    return try FfiConverterTypePreciseDecimal.lift(pointer)
}

public func FfiConverterTypePreciseDecimal_lower(_ value: PreciseDecimal) -> UnsafeMutableRawPointer {
    return FfiConverterTypePreciseDecimal.lower(value)
}


public protocol PrivateKeyProtocol {
    func `publicKey`()   -> PublicKey
    func `sign`(`hash`: Hash)   -> [UInt8]
    func `signToSignature`(`hash`: Hash)   -> Signature
    func `signToSignatureWithPublicKey`(`hash`: Hash)   -> SignatureWithPublicKey
    
}

public class PrivateKey: PrivateKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`bytes`: [UInt8], `curve`: Curve) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new(
        FfiConverterSequenceUInt8.lower(`bytes`),
        FfiConverterTypeCurve.lower(`curve`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey(pointer, $0) }
    }

    

    public static func `newEd25519`(`bytes`: [UInt8]) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519(
        FfiConverterSequenceUInt8.lower(`bytes`),$0)
})
    }

    

    public static func `newSecp256k1`(`bytes`: [UInt8]) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1(
        FfiConverterSequenceUInt8.lower(`bytes`),$0)
})
    }

    

    
    

    public func `publicKey`()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key(self.pointer, $0
    )
}
        )
    }

    public func `sign`(`hash`: Hash)  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign(self.pointer, 
        FfiConverterTypeHash.lower(`hash`),$0
    )
}
        )
    }

    public func `signToSignature`(`hash`: Hash)  -> Signature {
        return try!  FfiConverterTypeSignature.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature(self.pointer, 
        FfiConverterTypeHash.lower(`hash`),$0
    )
}
        )
    }

    public func `signToSignatureWithPublicKey`(`hash`: Hash)  -> SignatureWithPublicKey {
        return try!  FfiConverterTypeSignatureWithPublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key(self.pointer, 
        FfiConverterTypeHash.lower(`hash`),$0
    )
}
        )
    }
}

public struct FfiConverterTypePrivateKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PrivateKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PrivateKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PrivateKey {
        return PrivateKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PrivateKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePrivateKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PrivateKey {
    return try FfiConverterTypePrivateKey.lift(pointer)
}

public func FfiConverterTypePrivateKey_lower(_ value: PrivateKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePrivateKey.lower(value)
}


public protocol SignedIntentProtocol {
    func `compile`()  throws -> [UInt8]
    func `hash`()  throws -> TransactionHash
    func `intent`()   -> Intent
    func `intentHash`()  throws -> TransactionHash
    func `intentSignatures`()   -> [SignatureWithPublicKey]
    func `signedIntentHash`()  throws -> TransactionHash
    func `staticallyValidate`(`validationConfig`: ValidationConfig)  throws
    
}

public class SignedIntent: SignedIntentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`intent`: Intent, `intentSignatures`: [SignatureWithPublicKey])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new(
        FfiConverterTypeIntent.lower(`intent`),
        FfiConverterSequenceTypeSignatureWithPublicKey.lower(`intentSignatures`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent(pointer, $0) }
    }

    

    public static func `decompile`(`compiledSignedIntent`: [UInt8]) throws -> SignedIntent {
        return SignedIntent(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile(
        FfiConverterSequenceUInt8.lower(`compiledSignedIntent`),$0)
})
    }

    

    
    

    public func `compile`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile(self.pointer, $0
    )
}
        )
    }

    public func `hash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash(self.pointer, $0
    )
}
        )
    }

    public func `intent`()  -> Intent {
        return try!  FfiConverterTypeIntent.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent(self.pointer, $0
    )
}
        )
    }

    public func `intentHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `intentSignatures`()  -> [SignatureWithPublicKey] {
        return try!  FfiConverterSequenceTypeSignatureWithPublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures(self.pointer, $0
    )
}
        )
    }

    public func `signedIntentHash`() throws -> TransactionHash {
        return try  FfiConverterTypeTransactionHash.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash(self.pointer, $0
    )
}
        )
    }

    public func `staticallyValidate`(`validationConfig`: ValidationConfig) throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate(self.pointer, 
        FfiConverterTypeValidationConfig.lower(`validationConfig`),$0
    )
}
    }
}

public struct FfiConverterTypeSignedIntent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SignedIntent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedIntent {
        return SignedIntent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SignedIntent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSignedIntent_lift(_ pointer: UnsafeMutableRawPointer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(pointer)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSignedIntent.lower(value)
}


public protocol TransactionBuilderProtocol {
    func `header`(`header`: TransactionHeader)   -> TransactionBuilderHeaderStep
    
}

public class TransactionBuilder: TransactionBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder(pointer, $0) }
    }

    

    
    

    public func `header`(`header`: TransactionHeader)  -> TransactionBuilderHeaderStep {
        return try!  FfiConverterTypeTransactionBuilderHeaderStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header(self.pointer, 
        FfiConverterTypeTransactionHeader.lower(`header`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilder {
        return TransactionBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilder {
    return try FfiConverterTypeTransactionBuilder.lift(pointer)
}

public func FfiConverterTypeTransactionBuilder_lower(_ value: TransactionBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionBuilder.lower(value)
}


public protocol TransactionBuilderHeaderStepProtocol {
    func `manifest`(`manifest`: TransactionManifest)   -> TransactionBuilderMessageStep
    
}

public class TransactionBuilderHeaderStep: TransactionBuilderHeaderStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep(pointer, $0) }
    }

    

    
    

    public func `manifest`(`manifest`: TransactionManifest)  -> TransactionBuilderMessageStep {
        return try!  FfiConverterTypeTransactionBuilderMessageStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest(self.pointer, 
        FfiConverterTypeTransactionManifest.lower(`manifest`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionBuilderHeaderStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionBuilderHeaderStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionBuilderHeaderStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionBuilderHeaderStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderHeaderStep {
        return TransactionBuilderHeaderStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionBuilderHeaderStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionBuilderHeaderStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderHeaderStep {
    return try FfiConverterTypeTransactionBuilderHeaderStep.lift(pointer)
}

public func FfiConverterTypeTransactionBuilderHeaderStep_lower(_ value: TransactionBuilderHeaderStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionBuilderHeaderStep.lower(value)
}


public protocol TransactionBuilderIntentSignaturesStepProtocol {
    func `notarizeWithPrivateKey`(`privateKey`: PrivateKey)  throws -> NotarizedTransaction
    func `notarizeWithSigner`(`signer`: Signer)  throws -> NotarizedTransaction
    func `signWithPrivateKey`(`privateKey`: PrivateKey)   -> TransactionBuilderIntentSignaturesStep
    func `signWithSigner`(`signer`: Signer)   -> TransactionBuilderIntentSignaturesStep
    
}

public class TransactionBuilderIntentSignaturesStep: TransactionBuilderIntentSignaturesStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep(pointer, $0) }
    }

    

    
    

    public func `notarizeWithPrivateKey`(`privateKey`: PrivateKey) throws -> NotarizedTransaction {
        return try  FfiConverterTypeNotarizedTransaction.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(`privateKey`),$0
    )
}
        )
    }

    public func `notarizeWithSigner`(`signer`: Signer) throws -> NotarizedTransaction {
        return try  FfiConverterTypeNotarizedTransaction.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(`signer`),$0
    )
}
        )
    }

    public func `signWithPrivateKey`(`privateKey`: PrivateKey)  -> TransactionBuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(`privateKey`),$0
    )
}
        )
    }

    public func `signWithSigner`(`signer`: Signer)  -> TransactionBuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(`signer`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionBuilderIntentSignaturesStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionBuilderIntentSignaturesStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionBuilderIntentSignaturesStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionBuilderIntentSignaturesStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderIntentSignaturesStep {
        return TransactionBuilderIntentSignaturesStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionBuilderIntentSignaturesStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionBuilderIntentSignaturesStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderIntentSignaturesStep {
    return try FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(pointer)
}

public func FfiConverterTypeTransactionBuilderIntentSignaturesStep_lower(_ value: TransactionBuilderIntentSignaturesStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionBuilderIntentSignaturesStep.lower(value)
}


public protocol TransactionBuilderMessageStepProtocol {
    func `message`(`message`: Message)   -> TransactionBuilderIntentSignaturesStep
    func `signWithPrivateKey`(`privateKey`: PrivateKey)   -> TransactionBuilderIntentSignaturesStep
    func `signWithSigner`(`signer`: Signer)   -> TransactionBuilderIntentSignaturesStep
    
}

public class TransactionBuilderMessageStep: TransactionBuilderMessageStepProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep(pointer, $0) }
    }

    

    
    

    public func `message`(`message`: Message)  -> TransactionBuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message(self.pointer, 
        FfiConverterTypeMessage.lower(`message`),$0
    )
}
        )
    }

    public func `signWithPrivateKey`(`privateKey`: PrivateKey)  -> TransactionBuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key(self.pointer, 
        FfiConverterTypePrivateKey.lower(`privateKey`),$0
    )
}
        )
    }

    public func `signWithSigner`(`signer`: Signer)  -> TransactionBuilderIntentSignaturesStep {
        return try!  FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer(self.pointer, 
        FfiConverterCallbackInterfaceSigner.lower(`signer`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionBuilderMessageStep: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionBuilderMessageStep

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionBuilderMessageStep {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionBuilderMessageStep, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderMessageStep {
        return TransactionBuilderMessageStep(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionBuilderMessageStep) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionBuilderMessageStep_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionBuilderMessageStep {
    return try FfiConverterTypeTransactionBuilderMessageStep.lift(pointer)
}

public func FfiConverterTypeTransactionBuilderMessageStep_lower(_ value: TransactionBuilderMessageStep) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionBuilderMessageStep.lower(value)
}


public protocol TransactionHashProtocol {
    func `asHash`()   -> Hash
    func `asStr`()   -> String
    func `bytes`()   -> [UInt8]
    func `networkId`()   -> UInt8
    
}

public class TransactionHash: TransactionHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash(pointer, $0) }
    }

    

    public static func `fromStr`(`string`: String, `networkId`: UInt8) throws -> TransactionHash {
        return TransactionHash(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str(
        FfiConverterString.lower(`string`),
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    
    

    public func `asHash`()  -> Hash {
        return try!  FfiConverterTypeHash.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash(self.pointer, $0
    )
}
        )
    }

    public func `asStr`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str(self.pointer, $0
    )
}
        )
    }

    public func `bytes`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes(self.pointer, $0
    )
}
        )
    }

    public func `networkId`()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransactionHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
        return TransactionHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionHash {
    return try FfiConverterTypeTransactionHash.lift(pointer)
}

public func FfiConverterTypeTransactionHash_lower(_ value: TransactionHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionHash.lower(value)
}


public protocol TransactionManifestProtocol {
    func `accountsDepositedInto`()   -> [Address]
    func `accountsRequiringAuth`()   -> [Address]
    func `accountsWithdrawnFrom`()   -> [Address]
    func `analyzeExecution`(`transactionReceipt`: [UInt8])  throws -> ExecutionAnalysis
    func `blobs`()   -> [[UInt8]]
    func `extractAddresses`()   -> [EntityType: [Address]]
    func `identitiesRequiringAuth`()   -> [Address]
    func `instructions`()   -> Instructions
    func `modify`(`modifications`: TransactionManifestModifications)  throws -> TransactionManifest
    func `staticallyValidate`()  throws
    
}

public class TransactionManifest: TransactionManifestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`instructions`: Instructions, `blobs`: [[UInt8]])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new(
        FfiConverterTypeInstructions.lower(`instructions`),
        FfiConverterSequenceSequenceUInt8.lower(`blobs`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest(pointer, $0) }
    }

    

    
    

    public func `accountsDepositedInto`()  -> [Address] {
        return try!  FfiConverterSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into(self.pointer, $0
    )
}
        )
    }

    public func `accountsRequiringAuth`()  -> [Address] {
        return try!  FfiConverterSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth(self.pointer, $0
    )
}
        )
    }

    public func `accountsWithdrawnFrom`()  -> [Address] {
        return try!  FfiConverterSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from(self.pointer, $0
    )
}
        )
    }

    public func `analyzeExecution`(`transactionReceipt`: [UInt8]) throws -> ExecutionAnalysis {
        return try  FfiConverterTypeExecutionAnalysis.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution(self.pointer, 
        FfiConverterSequenceUInt8.lower(`transactionReceipt`),$0
    )
}
        )
    }

    public func `blobs`()  -> [[UInt8]] {
        return try!  FfiConverterSequenceSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs(self.pointer, $0
    )
}
        )
    }

    public func `extractAddresses`()  -> [EntityType: [Address]] {
        return try!  FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses(self.pointer, $0
    )
}
        )
    }

    public func `identitiesRequiringAuth`()  -> [Address] {
        return try!  FfiConverterSequenceTypeAddress.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth(self.pointer, $0
    )
}
        )
    }

    public func `instructions`()  -> Instructions {
        return try!  FfiConverterTypeInstructions.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions(self.pointer, $0
    )
}
        )
    }

    public func `modify`(`modifications`: TransactionManifestModifications) throws -> TransactionManifest {
        return try  FfiConverterTypeTransactionManifest.lift(
            try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify(self.pointer, 
        FfiConverterTypeTransactionManifestModifications.lower(`modifications`),$0
    )
}
        )
    }

    public func `staticallyValidate`() throws {
        try 
    rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate(self.pointer, $0
    )
}
    }
}

public struct FfiConverterTypeTransactionManifest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionManifest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifest {
        return TransactionManifest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionManifest) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransactionManifest_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(pointer)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionManifest.lower(value)
}


public protocol ValidationConfigProtocol {
    func `maxEpochRange`()   -> UInt64
    func `maxNotarizedPayloadSize`()   -> UInt64
    func `maxTipPercentage`()   -> UInt16
    func `messageValidation`()   -> MessageValidationConfig
    func `minTipPercentage`()   -> UInt16
    func `networkId`()   -> UInt8
    
}

public class ValidationConfig: ValidationConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`networkId`: UInt8, `maxNotarizedPayloadSize`: UInt64, `minTipPercentage`: UInt16, `maxTipPercentage`: UInt16, `maxEpochRange`: UInt64, `messageValidation`: MessageValidationConfig)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new(
        FfiConverterUInt8.lower(`networkId`),
        FfiConverterUInt64.lower(`maxNotarizedPayloadSize`),
        FfiConverterUInt16.lower(`minTipPercentage`),
        FfiConverterUInt16.lower(`maxTipPercentage`),
        FfiConverterUInt64.lower(`maxEpochRange`),
        FfiConverterTypeMessageValidationConfig.lower(`messageValidation`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig(pointer, $0) }
    }

    

    public static func `default`(`networkId`: UInt8)  -> ValidationConfig {
        return ValidationConfig(unsafeFromRawPointer: try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default(
        FfiConverterUInt8.lower(`networkId`),$0)
})
    }

    

    
    

    public func `maxEpochRange`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range(self.pointer, $0
    )
}
        )
    }

    public func `maxNotarizedPayloadSize`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size(self.pointer, $0
    )
}
        )
    }

    public func `maxTipPercentage`()  -> UInt16 {
        return try!  FfiConverterUInt16.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage(self.pointer, $0
    )
}
        )
    }

    public func `messageValidation`()  -> MessageValidationConfig {
        return try!  FfiConverterTypeMessageValidationConfig.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation(self.pointer, $0
    )
}
        )
    }

    public func `minTipPercentage`()  -> UInt16 {
        return try!  FfiConverterUInt16.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage(self.pointer, $0
    )
}
        )
    }

    public func `networkId`()  -> UInt8 {
        return try!  FfiConverterUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeValidationConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ValidationConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ValidationConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ValidationConfig {
        return ValidationConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ValidationConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeValidationConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> ValidationConfig {
    return try FfiConverterTypeValidationConfig.lift(pointer)
}

public func FfiConverterTypeValidationConfig_lower(_ value: ValidationConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeValidationConfig.lower(value)
}


public struct AccountAddAuthorizedDepositorEvent {
    public var `authorizedDepositorBadge`: ResourceOrNonFungible

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`authorizedDepositorBadge`: ResourceOrNonFungible) {
        self.`authorizedDepositorBadge` = `authorizedDepositorBadge`
    }
}



public struct FfiConverterTypeAccountAddAuthorizedDepositorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddAuthorizedDepositorEvent {
        return try AccountAddAuthorizedDepositorEvent(
            `authorizedDepositorBadge`: FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: AccountAddAuthorizedDepositorEvent, into buf: inout [UInt8]) {
        FfiConverterTypeResourceOrNonFungible.write(value.`authorizedDepositorBadge`, into: &buf)
    }
}


public func FfiConverterTypeAccountAddAuthorizedDepositorEvent_lift(_ buf: RustBuffer) throws -> AccountAddAuthorizedDepositorEvent {
    return try FfiConverterTypeAccountAddAuthorizedDepositorEvent.lift(buf)
}

public func FfiConverterTypeAccountAddAuthorizedDepositorEvent_lower(_ value: AccountAddAuthorizedDepositorEvent) -> RustBuffer {
    return FfiConverterTypeAccountAddAuthorizedDepositorEvent.lower(value)
}


public struct AccountRemoveAuthorizedDepositorEvent {
    public var `authorizedDepositorBadge`: ResourceOrNonFungible

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`authorizedDepositorBadge`: ResourceOrNonFungible) {
        self.`authorizedDepositorBadge` = `authorizedDepositorBadge`
    }
}



public struct FfiConverterTypeAccountRemoveAuthorizedDepositorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRemoveAuthorizedDepositorEvent {
        return try AccountRemoveAuthorizedDepositorEvent(
            `authorizedDepositorBadge`: FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: AccountRemoveAuthorizedDepositorEvent, into buf: inout [UInt8]) {
        FfiConverterTypeResourceOrNonFungible.write(value.`authorizedDepositorBadge`, into: &buf)
    }
}


public func FfiConverterTypeAccountRemoveAuthorizedDepositorEvent_lift(_ buf: RustBuffer) throws -> AccountRemoveAuthorizedDepositorEvent {
    return try FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.lift(buf)
}

public func FfiConverterTypeAccountRemoveAuthorizedDepositorEvent_lower(_ value: AccountRemoveAuthorizedDepositorEvent) -> RustBuffer {
    return FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.lower(value)
}


public struct AccountRemoveResourcePreferenceEvent {
    public var `resourceAddress`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address) {
        self.`resourceAddress` = `resourceAddress`
    }
}



public struct FfiConverterTypeAccountRemoveResourcePreferenceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRemoveResourcePreferenceEvent {
        return try AccountRemoveResourcePreferenceEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: AccountRemoveResourcePreferenceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
    }
}


public func FfiConverterTypeAccountRemoveResourcePreferenceEvent_lift(_ buf: RustBuffer) throws -> AccountRemoveResourcePreferenceEvent {
    return try FfiConverterTypeAccountRemoveResourcePreferenceEvent.lift(buf)
}

public func FfiConverterTypeAccountRemoveResourcePreferenceEvent_lower(_ value: AccountRemoveResourcePreferenceEvent) -> RustBuffer {
    return FfiConverterTypeAccountRemoveResourcePreferenceEvent.lower(value)
}


public struct AccountSetDefaultDepositRuleEvent {
    public var `defaultDepositRule`: AccountDefaultDepositRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`defaultDepositRule`: AccountDefaultDepositRule) {
        self.`defaultDepositRule` = `defaultDepositRule`
    }
}


extension AccountSetDefaultDepositRuleEvent: Equatable, Hashable {
    public static func ==(lhs: AccountSetDefaultDepositRuleEvent, rhs: AccountSetDefaultDepositRuleEvent) -> Bool {
        if lhs.`defaultDepositRule` != rhs.`defaultDepositRule` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`defaultDepositRule`)
    }
}


public struct FfiConverterTypeAccountSetDefaultDepositRuleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountSetDefaultDepositRuleEvent {
        return try AccountSetDefaultDepositRuleEvent(
            `defaultDepositRule`: FfiConverterTypeAccountDefaultDepositRule.read(from: &buf)
        )
    }

    public static func write(_ value: AccountSetDefaultDepositRuleEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAccountDefaultDepositRule.write(value.`defaultDepositRule`, into: &buf)
    }
}


public func FfiConverterTypeAccountSetDefaultDepositRuleEvent_lift(_ buf: RustBuffer) throws -> AccountSetDefaultDepositRuleEvent {
    return try FfiConverterTypeAccountSetDefaultDepositRuleEvent.lift(buf)
}

public func FfiConverterTypeAccountSetDefaultDepositRuleEvent_lower(_ value: AccountSetDefaultDepositRuleEvent) -> RustBuffer {
    return FfiConverterTypeAccountSetDefaultDepositRuleEvent.lower(value)
}


public struct AccountSetResourcePreferenceEvent {
    public var `resourceAddress`: Address
    public var `preference`: ResourcePreference

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address, `preference`: ResourcePreference) {
        self.`resourceAddress` = `resourceAddress`
        self.`preference` = `preference`
    }
}



public struct FfiConverterTypeAccountSetResourcePreferenceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountSetResourcePreferenceEvent {
        return try AccountSetResourcePreferenceEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `preference`: FfiConverterTypeResourcePreference.read(from: &buf)
        )
    }

    public static func write(_ value: AccountSetResourcePreferenceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
        FfiConverterTypeResourcePreference.write(value.`preference`, into: &buf)
    }
}


public func FfiConverterTypeAccountSetResourcePreferenceEvent_lift(_ buf: RustBuffer) throws -> AccountSetResourcePreferenceEvent {
    return try FfiConverterTypeAccountSetResourcePreferenceEvent.lift(buf)
}

public func FfiConverterTypeAccountSetResourcePreferenceEvent_lower(_ value: AccountSetResourcePreferenceEvent) -> RustBuffer {
    return FfiConverterTypeAccountSetResourcePreferenceEvent.lower(value)
}


public struct AuthorizedDepositorsChanges {
    public var `added`: [ResourceOrNonFungible]
    public var `removed`: [ResourceOrNonFungible]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`added`: [ResourceOrNonFungible], `removed`: [ResourceOrNonFungible]) {
        self.`added` = `added`
        self.`removed` = `removed`
    }
}



public struct FfiConverterTypeAuthorizedDepositorsChanges: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDepositorsChanges {
        return try AuthorizedDepositorsChanges(
            `added`: FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf), 
            `removed`: FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedDepositorsChanges, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeResourceOrNonFungible.write(value.`added`, into: &buf)
        FfiConverterSequenceTypeResourceOrNonFungible.write(value.`removed`, into: &buf)
    }
}


public func FfiConverterTypeAuthorizedDepositorsChanges_lift(_ buf: RustBuffer) throws -> AuthorizedDepositorsChanges {
    return try FfiConverterTypeAuthorizedDepositorsChanges.lift(buf)
}

public func FfiConverterTypeAuthorizedDepositorsChanges_lower(_ value: AuthorizedDepositorsChanges) -> RustBuffer {
    return FfiConverterTypeAuthorizedDepositorsChanges.lower(value)
}


public struct BadgeWithdrawEvent {
    public var `proposer`: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer) {
        self.`proposer` = `proposer`
    }
}


extension BadgeWithdrawEvent: Equatable, Hashable {
    public static func ==(lhs: BadgeWithdrawEvent, rhs: BadgeWithdrawEvent) -> Bool {
        if lhs.`proposer` != rhs.`proposer` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`proposer`)
    }
}


public struct FfiConverterTypeBadgeWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BadgeWithdrawEvent {
        return try BadgeWithdrawEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: BadgeWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
    }
}


public func FfiConverterTypeBadgeWithdrawEvent_lift(_ buf: RustBuffer) throws -> BadgeWithdrawEvent {
    return try FfiConverterTypeBadgeWithdrawEvent.lift(buf)
}

public func FfiConverterTypeBadgeWithdrawEvent_lower(_ value: BadgeWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeBadgeWithdrawEvent.lower(value)
}


public struct BuildInformation {
    public var `version`: String
    public var `scryptoDependency`: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`version`: String, `scryptoDependency`: DependencyInformation) {
        self.`version` = `version`
        self.`scryptoDependency` = `scryptoDependency`
    }
}


extension BuildInformation: Equatable, Hashable {
    public static func ==(lhs: BuildInformation, rhs: BuildInformation) -> Bool {
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`scryptoDependency` != rhs.`scryptoDependency` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`version`)
        hasher.combine(`scryptoDependency`)
    }
}


public struct FfiConverterTypeBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildInformation {
        return try BuildInformation(
            `version`: FfiConverterString.read(from: &buf), 
            `scryptoDependency`: FfiConverterTypeDependencyInformation.read(from: &buf)
        )
    }

    public static func write(_ value: BuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`version`, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.`scryptoDependency`, into: &buf)
    }
}


public func FfiConverterTypeBuildInformation_lift(_ buf: RustBuffer) throws -> BuildInformation {
    return try FfiConverterTypeBuildInformation.lift(buf)
}

public func FfiConverterTypeBuildInformation_lower(_ value: BuildInformation) -> RustBuffer {
    return FfiConverterTypeBuildInformation.lower(value)
}


public struct BurnFungibleResourceEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeBurnFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnFungibleResourceEvent {
        return try BurnFungibleResourceEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: BurnFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeBurnFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> BurnFungibleResourceEvent {
    return try FfiConverterTypeBurnFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeBurnFungibleResourceEvent_lower(_ value: BurnFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeBurnFungibleResourceEvent.lower(value)
}


public struct BurnNonFungibleResourceEvent {
    public var `ids`: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ids`: [NonFungibleLocalId]) {
        self.`ids` = `ids`
    }
}


extension BurnNonFungibleResourceEvent: Equatable, Hashable {
    public static func ==(lhs: BurnNonFungibleResourceEvent, rhs: BurnNonFungibleResourceEvent) -> Bool {
        if lhs.`ids` != rhs.`ids` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ids`)
    }
}


public struct FfiConverterTypeBurnNonFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnNonFungibleResourceEvent {
        return try BurnNonFungibleResourceEvent(
            `ids`: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: BurnNonFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, into: &buf)
    }
}


public func FfiConverterTypeBurnNonFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> BurnNonFungibleResourceEvent {
    return try FfiConverterTypeBurnNonFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeBurnNonFungibleResourceEvent_lower(_ value: BurnNonFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeBurnNonFungibleResourceEvent.lower(value)
}


public struct CancelBadgeWithdrawAttemptEvent {
    public var `proposer`: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer) {
        self.`proposer` = `proposer`
    }
}


extension CancelBadgeWithdrawAttemptEvent: Equatable, Hashable {
    public static func ==(lhs: CancelBadgeWithdrawAttemptEvent, rhs: CancelBadgeWithdrawAttemptEvent) -> Bool {
        if lhs.`proposer` != rhs.`proposer` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`proposer`)
    }
}


public struct FfiConverterTypeCancelBadgeWithdrawAttemptEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelBadgeWithdrawAttemptEvent {
        return try CancelBadgeWithdrawAttemptEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: CancelBadgeWithdrawAttemptEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
    }
}


public func FfiConverterTypeCancelBadgeWithdrawAttemptEvent_lift(_ buf: RustBuffer) throws -> CancelBadgeWithdrawAttemptEvent {
    return try FfiConverterTypeCancelBadgeWithdrawAttemptEvent.lift(buf)
}

public func FfiConverterTypeCancelBadgeWithdrawAttemptEvent_lower(_ value: CancelBadgeWithdrawAttemptEvent) -> RustBuffer {
    return FfiConverterTypeCancelBadgeWithdrawAttemptEvent.lower(value)
}


public struct CancelRecoveryProposalEvent {
    public var `proposer`: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer) {
        self.`proposer` = `proposer`
    }
}


extension CancelRecoveryProposalEvent: Equatable, Hashable {
    public static func ==(lhs: CancelRecoveryProposalEvent, rhs: CancelRecoveryProposalEvent) -> Bool {
        if lhs.`proposer` != rhs.`proposer` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`proposer`)
    }
}


public struct FfiConverterTypeCancelRecoveryProposalEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelRecoveryProposalEvent {
        return try CancelRecoveryProposalEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: CancelRecoveryProposalEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
    }
}


public func FfiConverterTypeCancelRecoveryProposalEvent_lift(_ buf: RustBuffer) throws -> CancelRecoveryProposalEvent {
    return try FfiConverterTypeCancelRecoveryProposalEvent.lift(buf)
}

public func FfiConverterTypeCancelRecoveryProposalEvent_lower(_ value: CancelRecoveryProposalEvent) -> RustBuffer {
    return FfiConverterTypeCancelRecoveryProposalEvent.lower(value)
}


public struct ClaimXrdEvent {
    public var `claimedXrd`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`claimedXrd`: Decimal) {
        self.`claimedXrd` = `claimedXrd`
    }
}



public struct FfiConverterTypeClaimXrdEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimXrdEvent {
        return try ClaimXrdEvent(
            `claimedXrd`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimXrdEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`claimedXrd`, into: &buf)
    }
}


public func FfiConverterTypeClaimXrdEvent_lift(_ buf: RustBuffer) throws -> ClaimXrdEvent {
    return try FfiConverterTypeClaimXrdEvent.lift(buf)
}

public func FfiConverterTypeClaimXrdEvent_lower(_ value: ClaimXrdEvent) -> RustBuffer {
    return FfiConverterTypeClaimXrdEvent.lower(value)
}


public struct ComponentAddresses {
    public var `consensusManager`: Address
    public var `genesisHelper`: Address
    public var `faucet`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`consensusManager`: Address, `genesisHelper`: Address, `faucet`: Address) {
        self.`consensusManager` = `consensusManager`
        self.`genesisHelper` = `genesisHelper`
        self.`faucet` = `faucet`
    }
}



public struct FfiConverterTypeComponentAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddresses {
        return try ComponentAddresses(
            `consensusManager`: FfiConverterTypeAddress.read(from: &buf), 
            `genesisHelper`: FfiConverterTypeAddress.read(from: &buf), 
            `faucet`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ComponentAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`consensusManager`, into: &buf)
        FfiConverterTypeAddress.write(value.`genesisHelper`, into: &buf)
        FfiConverterTypeAddress.write(value.`faucet`, into: &buf)
    }
}


public func FfiConverterTypeComponentAddresses_lift(_ buf: RustBuffer) throws -> ComponentAddresses {
    return try FfiConverterTypeComponentAddresses.lift(buf)
}

public func FfiConverterTypeComponentAddresses_lower(_ value: ComponentAddresses) -> RustBuffer {
    return FfiConverterTypeComponentAddresses.lower(value)
}


public struct Ed25519PublicKey {
    public var `value`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: [UInt8]) {
        self.`value` = `value`
    }
}


extension Ed25519PublicKey: Equatable, Hashable {
    public static func ==(lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return try Ed25519PublicKey(
            `value`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}


public struct EncryptedMessage {
    public var `encrypted`: [UInt8]
    public var `decryptorsByCurve`: [CurveType: DecryptorsByCurve]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`encrypted`: [UInt8], `decryptorsByCurve`: [CurveType: DecryptorsByCurve]) {
        self.`encrypted` = `encrypted`
        self.`decryptorsByCurve` = `decryptorsByCurve`
    }
}


extension EncryptedMessage: Equatable, Hashable {
    public static func ==(lhs: EncryptedMessage, rhs: EncryptedMessage) -> Bool {
        if lhs.`encrypted` != rhs.`encrypted` {
            return false
        }
        if lhs.`decryptorsByCurve` != rhs.`decryptorsByCurve` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`encrypted`)
        hasher.combine(`decryptorsByCurve`)
    }
}


public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        return try EncryptedMessage(
            `encrypted`: FfiConverterSequenceUInt8.read(from: &buf), 
            `decryptorsByCurve`: FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`encrypted`, into: &buf)
        FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve.write(value.`decryptorsByCurve`, into: &buf)
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


public struct EpochChangeEvent {
    public var `epoch`: UInt64
    public var `validatorSet`: [String: ValidatorInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`epoch`: UInt64, `validatorSet`: [String: ValidatorInfo]) {
        self.`epoch` = `epoch`
        self.`validatorSet` = `validatorSet`
    }
}



public struct FfiConverterTypeEpochChangeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EpochChangeEvent {
        return try EpochChangeEvent(
            `epoch`: FfiConverterUInt64.read(from: &buf), 
            `validatorSet`: FfiConverterDictionaryStringTypeValidatorInfo.read(from: &buf)
        )
    }

    public static func write(_ value: EpochChangeEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`epoch`, into: &buf)
        FfiConverterDictionaryStringTypeValidatorInfo.write(value.`validatorSet`, into: &buf)
    }
}


public func FfiConverterTypeEpochChangeEvent_lift(_ buf: RustBuffer) throws -> EpochChangeEvent {
    return try FfiConverterTypeEpochChangeEvent.lift(buf)
}

public func FfiConverterTypeEpochChangeEvent_lower(_ value: EpochChangeEvent) -> RustBuffer {
    return FfiConverterTypeEpochChangeEvent.lower(value)
}


public struct EventTypeIdentifier {
    public var `emitter`: Emitter
    public var `eventName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`emitter`: Emitter, `eventName`: String) {
        self.`emitter` = `emitter`
        self.`eventName` = `eventName`
    }
}



public struct FfiConverterTypeEventTypeIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTypeIdentifier {
        return try EventTypeIdentifier(
            `emitter`: FfiConverterTypeEmitter.read(from: &buf), 
            `eventName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTypeIdentifier, into buf: inout [UInt8]) {
        FfiConverterTypeEmitter.write(value.`emitter`, into: &buf)
        FfiConverterString.write(value.`eventName`, into: &buf)
    }
}


public func FfiConverterTypeEventTypeIdentifier_lift(_ buf: RustBuffer) throws -> EventTypeIdentifier {
    return try FfiConverterTypeEventTypeIdentifier.lift(buf)
}

public func FfiConverterTypeEventTypeIdentifier_lower(_ value: EventTypeIdentifier) -> RustBuffer {
    return FfiConverterTypeEventTypeIdentifier.lower(value)
}


public struct ExecutionAnalysis {
    public var `feeLocks`: FeeLocks
    public var `feeSummary`: FeeSummary
    public var `transactionTypes`: [TransactionType]
    public var `reservedInstructions`: [ReservedInstruction]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`feeLocks`: FeeLocks, `feeSummary`: FeeSummary, `transactionTypes`: [TransactionType], `reservedInstructions`: [ReservedInstruction]) {
        self.`feeLocks` = `feeLocks`
        self.`feeSummary` = `feeSummary`
        self.`transactionTypes` = `transactionTypes`
        self.`reservedInstructions` = `reservedInstructions`
    }
}



public struct FfiConverterTypeExecutionAnalysis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionAnalysis {
        return try ExecutionAnalysis(
            `feeLocks`: FfiConverterTypeFeeLocks.read(from: &buf), 
            `feeSummary`: FfiConverterTypeFeeSummary.read(from: &buf), 
            `transactionTypes`: FfiConverterSequenceTypeTransactionType.read(from: &buf), 
            `reservedInstructions`: FfiConverterSequenceTypeReservedInstruction.read(from: &buf)
        )
    }

    public static func write(_ value: ExecutionAnalysis, into buf: inout [UInt8]) {
        FfiConverterTypeFeeLocks.write(value.`feeLocks`, into: &buf)
        FfiConverterTypeFeeSummary.write(value.`feeSummary`, into: &buf)
        FfiConverterSequenceTypeTransactionType.write(value.`transactionTypes`, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.`reservedInstructions`, into: &buf)
    }
}


public func FfiConverterTypeExecutionAnalysis_lift(_ buf: RustBuffer) throws -> ExecutionAnalysis {
    return try FfiConverterTypeExecutionAnalysis.lift(buf)
}

public func FfiConverterTypeExecutionAnalysis_lower(_ value: ExecutionAnalysis) -> RustBuffer {
    return FfiConverterTypeExecutionAnalysis.lower(value)
}


public struct FeeLocks {
    public var `lock`: Decimal
    public var `contingentLock`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lock`: Decimal, `contingentLock`: Decimal) {
        self.`lock` = `lock`
        self.`contingentLock` = `contingentLock`
    }
}



public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return try FeeLocks(
            `lock`: FfiConverterTypeDecimal.read(from: &buf), 
            `contingentLock`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`lock`, into: &buf)
        FfiConverterTypeDecimal.write(value.`contingentLock`, into: &buf)
    }
}


public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}


public struct FeeSummary {
    public var `executionCost`: Decimal
    public var `finalizationCost`: Decimal
    public var `storageExpansionCost`: Decimal
    public var `royaltyCost`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`executionCost`: Decimal, `finalizationCost`: Decimal, `storageExpansionCost`: Decimal, `royaltyCost`: Decimal) {
        self.`executionCost` = `executionCost`
        self.`finalizationCost` = `finalizationCost`
        self.`storageExpansionCost` = `storageExpansionCost`
        self.`royaltyCost` = `royaltyCost`
    }
}



public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return try FeeSummary(
            `executionCost`: FfiConverterTypeDecimal.read(from: &buf), 
            `finalizationCost`: FfiConverterTypeDecimal.read(from: &buf), 
            `storageExpansionCost`: FfiConverterTypeDecimal.read(from: &buf), 
            `royaltyCost`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`executionCost`, into: &buf)
        FfiConverterTypeDecimal.write(value.`finalizationCost`, into: &buf)
        FfiConverterTypeDecimal.write(value.`storageExpansionCost`, into: &buf)
        FfiConverterTypeDecimal.write(value.`royaltyCost`, into: &buf)
    }
}


public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}


public struct FungibleResourceRoles {
    public var `mintRoles`: ResourceManagerRole?
    public var `burnRoles`: ResourceManagerRole?
    public var `freezeRoles`: ResourceManagerRole?
    public var `recallRoles`: ResourceManagerRole?
    public var `withdrawRoles`: ResourceManagerRole?
    public var `depositRoles`: ResourceManagerRole?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mintRoles`: ResourceManagerRole?, `burnRoles`: ResourceManagerRole?, `freezeRoles`: ResourceManagerRole?, `recallRoles`: ResourceManagerRole?, `withdrawRoles`: ResourceManagerRole?, `depositRoles`: ResourceManagerRole?) {
        self.`mintRoles` = `mintRoles`
        self.`burnRoles` = `burnRoles`
        self.`freezeRoles` = `freezeRoles`
        self.`recallRoles` = `recallRoles`
        self.`withdrawRoles` = `withdrawRoles`
        self.`depositRoles` = `depositRoles`
    }
}



public struct FfiConverterTypeFungibleResourceRoles: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceRoles {
        return try FungibleResourceRoles(
            `mintRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            `burnRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            `freezeRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            `recallRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            `withdrawRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf), 
            `depositRoles`: FfiConverterOptionTypeResourceManagerRole.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleResourceRoles, into buf: inout [UInt8]) {
        FfiConverterOptionTypeResourceManagerRole.write(value.`mintRoles`, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.`burnRoles`, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.`freezeRoles`, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.`recallRoles`, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.`withdrawRoles`, into: &buf)
        FfiConverterOptionTypeResourceManagerRole.write(value.`depositRoles`, into: &buf)
    }
}


public func FfiConverterTypeFungibleResourceRoles_lift(_ buf: RustBuffer) throws -> FungibleResourceRoles {
    return try FfiConverterTypeFungibleResourceRoles.lift(buf)
}

public func FfiConverterTypeFungibleResourceRoles_lower(_ value: FungibleResourceRoles) -> RustBuffer {
    return FfiConverterTypeFungibleResourceRoles.lower(value)
}


public struct FungibleVaultDepositEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeFungibleVaultDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultDepositEvent {
        return try FungibleVaultDepositEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultDepositEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultDepositEvent {
    return try FfiConverterTypeFungibleVaultDepositEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultDepositEvent_lower(_ value: FungibleVaultDepositEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultDepositEvent.lower(value)
}


public struct FungibleVaultLockFeeEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeFungibleVaultLockFeeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultLockFeeEvent {
        return try FungibleVaultLockFeeEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultLockFeeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultLockFeeEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultLockFeeEvent {
    return try FfiConverterTypeFungibleVaultLockFeeEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultLockFeeEvent_lower(_ value: FungibleVaultLockFeeEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultLockFeeEvent.lower(value)
}


public struct FungibleVaultPayFeeEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeFungibleVaultPayFeeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultPayFeeEvent {
        return try FungibleVaultPayFeeEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultPayFeeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultPayFeeEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultPayFeeEvent {
    return try FfiConverterTypeFungibleVaultPayFeeEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultPayFeeEvent_lower(_ value: FungibleVaultPayFeeEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultPayFeeEvent.lower(value)
}


public struct FungibleVaultRecallEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeFungibleVaultRecallEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultRecallEvent {
        return try FungibleVaultRecallEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultRecallEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultRecallEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultRecallEvent {
    return try FfiConverterTypeFungibleVaultRecallEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultRecallEvent_lower(_ value: FungibleVaultRecallEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultRecallEvent.lower(value)
}


public struct FungibleVaultWithdrawEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeFungibleVaultWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleVaultWithdrawEvent {
        return try FungibleVaultWithdrawEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: FungibleVaultWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeFungibleVaultWithdrawEvent_lift(_ buf: RustBuffer) throws -> FungibleVaultWithdrawEvent {
    return try FfiConverterTypeFungibleVaultWithdrawEvent.lift(buf)
}

public func FfiConverterTypeFungibleVaultWithdrawEvent_lower(_ value: FungibleVaultWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeFungibleVaultWithdrawEvent.lower(value)
}


public struct IndexedAssertion {
    public var `index`: UInt64
    public var `assertion`: Assertion

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt64, `assertion`: Assertion) {
        self.`index` = `index`
        self.`assertion` = `assertion`
    }
}



public struct FfiConverterTypeIndexedAssertion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IndexedAssertion {
        return try IndexedAssertion(
            `index`: FfiConverterUInt64.read(from: &buf), 
            `assertion`: FfiConverterTypeAssertion.read(from: &buf)
        )
    }

    public static func write(_ value: IndexedAssertion, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`index`, into: &buf)
        FfiConverterTypeAssertion.write(value.`assertion`, into: &buf)
    }
}


public func FfiConverterTypeIndexedAssertion_lift(_ buf: RustBuffer) throws -> IndexedAssertion {
    return try FfiConverterTypeIndexedAssertion.lift(buf)
}

public func FfiConverterTypeIndexedAssertion_lower(_ value: IndexedAssertion) -> RustBuffer {
    return FfiConverterTypeIndexedAssertion.lower(value)
}


public struct InitiateBadgeWithdrawAttemptEvent {
    public var `proposer`: Proposer

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer) {
        self.`proposer` = `proposer`
    }
}


extension InitiateBadgeWithdrawAttemptEvent: Equatable, Hashable {
    public static func ==(lhs: InitiateBadgeWithdrawAttemptEvent, rhs: InitiateBadgeWithdrawAttemptEvent) -> Bool {
        if lhs.`proposer` != rhs.`proposer` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`proposer`)
    }
}


public struct FfiConverterTypeInitiateBadgeWithdrawAttemptEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitiateBadgeWithdrawAttemptEvent {
        return try InitiateBadgeWithdrawAttemptEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf)
        )
    }

    public static func write(_ value: InitiateBadgeWithdrawAttemptEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
    }
}


public func FfiConverterTypeInitiateBadgeWithdrawAttemptEvent_lift(_ buf: RustBuffer) throws -> InitiateBadgeWithdrawAttemptEvent {
    return try FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.lift(buf)
}

public func FfiConverterTypeInitiateBadgeWithdrawAttemptEvent_lower(_ value: InitiateBadgeWithdrawAttemptEvent) -> RustBuffer {
    return FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.lower(value)
}


public struct InitiateRecoveryEvent {
    public var `proposer`: Proposer
    public var `proposal`: RecoveryProposal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer, `proposal`: RecoveryProposal) {
        self.`proposer` = `proposer`
        self.`proposal` = `proposal`
    }
}



public struct FfiConverterTypeInitiateRecoveryEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitiateRecoveryEvent {
        return try InitiateRecoveryEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf), 
            `proposal`: FfiConverterTypeRecoveryProposal.read(from: &buf)
        )
    }

    public static func write(_ value: InitiateRecoveryEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
        FfiConverterTypeRecoveryProposal.write(value.`proposal`, into: &buf)
    }
}


public func FfiConverterTypeInitiateRecoveryEvent_lift(_ buf: RustBuffer) throws -> InitiateRecoveryEvent {
    return try FfiConverterTypeInitiateRecoveryEvent.lift(buf)
}

public func FfiConverterTypeInitiateRecoveryEvent_lower(_ value: InitiateRecoveryEvent) -> RustBuffer {
    return FfiConverterTypeInitiateRecoveryEvent.lower(value)
}


public struct KnownAddresses {
    public var `resourceAddresses`: ResourceAddresses
    public var `packageAddresses`: PackageAddresses
    public var `componentAddresses`: ComponentAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddresses`: ResourceAddresses, `packageAddresses`: PackageAddresses, `componentAddresses`: ComponentAddresses) {
        self.`resourceAddresses` = `resourceAddresses`
        self.`packageAddresses` = `packageAddresses`
        self.`componentAddresses` = `componentAddresses`
    }
}



public struct FfiConverterTypeKnownAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnownAddresses {
        return try KnownAddresses(
            `resourceAddresses`: FfiConverterTypeResourceAddresses.read(from: &buf), 
            `packageAddresses`: FfiConverterTypePackageAddresses.read(from: &buf), 
            `componentAddresses`: FfiConverterTypeComponentAddresses.read(from: &buf)
        )
    }

    public static func write(_ value: KnownAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddresses.write(value.`resourceAddresses`, into: &buf)
        FfiConverterTypePackageAddresses.write(value.`packageAddresses`, into: &buf)
        FfiConverterTypeComponentAddresses.write(value.`componentAddresses`, into: &buf)
    }
}


public func FfiConverterTypeKnownAddresses_lift(_ buf: RustBuffer) throws -> KnownAddresses {
    return try FfiConverterTypeKnownAddresses.lift(buf)
}

public func FfiConverterTypeKnownAddresses_lower(_ value: KnownAddresses) -> RustBuffer {
    return FfiConverterTypeKnownAddresses.lower(value)
}


public struct LockFeeEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeLockFeeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockFeeEvent {
        return try LockFeeEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: LockFeeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeLockFeeEvent_lift(_ buf: RustBuffer) throws -> LockFeeEvent {
    return try FfiConverterTypeLockFeeEvent.lift(buf)
}

public func FfiConverterTypeLockFeeEvent_lower(_ value: LockFeeEvent) -> RustBuffer {
    return FfiConverterTypeLockFeeEvent.lower(value)
}


public struct LockFeeModification {
    public var `accountAddress`: Address
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`accountAddress`: Address, `amount`: Decimal) {
        self.`accountAddress` = `accountAddress`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeLockFeeModification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockFeeModification {
        return try LockFeeModification(
            `accountAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: LockFeeModification, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`accountAddress`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeLockFeeModification_lift(_ buf: RustBuffer) throws -> LockFeeModification {
    return try FfiConverterTypeLockFeeModification.lift(buf)
}

public func FfiConverterTypeLockFeeModification_lower(_ value: LockFeeModification) -> RustBuffer {
    return FfiConverterTypeLockFeeModification.lower(value)
}


public struct LockOwnerRoleEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension LockOwnerRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockOwnerRoleEvent, rhs: LockOwnerRoleEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeLockOwnerRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockOwnerRoleEvent {
        return try LockOwnerRoleEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LockOwnerRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeLockOwnerRoleEvent_lift(_ buf: RustBuffer) throws -> LockOwnerRoleEvent {
    return try FfiConverterTypeLockOwnerRoleEvent.lift(buf)
}

public func FfiConverterTypeLockOwnerRoleEvent_lower(_ value: LockOwnerRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockOwnerRoleEvent.lower(value)
}


public struct LockPrimaryRoleEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension LockPrimaryRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockPrimaryRoleEvent, rhs: LockPrimaryRoleEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeLockPrimaryRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockPrimaryRoleEvent {
        return try LockPrimaryRoleEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LockPrimaryRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeLockPrimaryRoleEvent_lift(_ buf: RustBuffer) throws -> LockPrimaryRoleEvent {
    return try FfiConverterTypeLockPrimaryRoleEvent.lift(buf)
}

public func FfiConverterTypeLockPrimaryRoleEvent_lower(_ value: LockPrimaryRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockPrimaryRoleEvent.lower(value)
}


public struct LockRoleEvent {
    public var `roleKey`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`roleKey`: String) {
        self.`roleKey` = `roleKey`
    }
}


extension LockRoleEvent: Equatable, Hashable {
    public static func ==(lhs: LockRoleEvent, rhs: LockRoleEvent) -> Bool {
        if lhs.`roleKey` != rhs.`roleKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`roleKey`)
    }
}


public struct FfiConverterTypeLockRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockRoleEvent {
        return try LockRoleEvent(
            `roleKey`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LockRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`roleKey`, into: &buf)
    }
}


public func FfiConverterTypeLockRoleEvent_lift(_ buf: RustBuffer) throws -> LockRoleEvent {
    return try FfiConverterTypeLockRoleEvent.lift(buf)
}

public func FfiConverterTypeLockRoleEvent_lower(_ value: LockRoleEvent) -> RustBuffer {
    return FfiConverterTypeLockRoleEvent.lower(value)
}


public struct ManifestAddressReservation {
    public var `value`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: UInt32) {
        self.`value` = `value`
    }
}


extension ManifestAddressReservation: Equatable, Hashable {
    public static func ==(lhs: ManifestAddressReservation, rhs: ManifestAddressReservation) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeManifestAddressReservation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddressReservation {
        return try ManifestAddressReservation(
            `value`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestAddressReservation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeManifestAddressReservation_lift(_ buf: RustBuffer) throws -> ManifestAddressReservation {
    return try FfiConverterTypeManifestAddressReservation.lift(buf)
}

public func FfiConverterTypeManifestAddressReservation_lower(_ value: ManifestAddressReservation) -> RustBuffer {
    return FfiConverterTypeManifestAddressReservation.lower(value)
}


public struct ManifestBlobRef {
    public var `value`: Hash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: Hash) {
        self.`value` = `value`
    }
}



public struct FfiConverterTypeManifestBlobRef: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBlobRef {
        return try ManifestBlobRef(
            `value`: FfiConverterTypeHash.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBlobRef, into buf: inout [UInt8]) {
        FfiConverterTypeHash.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeManifestBlobRef_lift(_ buf: RustBuffer) throws -> ManifestBlobRef {
    return try FfiConverterTypeManifestBlobRef.lift(buf)
}

public func FfiConverterTypeManifestBlobRef_lower(_ value: ManifestBlobRef) -> RustBuffer {
    return FfiConverterTypeManifestBlobRef.lower(value)
}


public struct ManifestBucket {
    public var `value`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: UInt32) {
        self.`value` = `value`
    }
}


extension ManifestBucket: Equatable, Hashable {
    public static func ==(lhs: ManifestBucket, rhs: ManifestBucket) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeManifestBucket: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBucket {
        return try ManifestBucket(
            `value`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBucket, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeManifestBucket_lift(_ buf: RustBuffer) throws -> ManifestBucket {
    return try FfiConverterTypeManifestBucket.lift(buf)
}

public func FfiConverterTypeManifestBucket_lower(_ value: ManifestBucket) -> RustBuffer {
    return FfiConverterTypeManifestBucket.lower(value)
}


public struct ManifestBuilderAddressReservation {
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String) {
        self.`name` = `name`
    }
}


extension ManifestBuilderAddressReservation: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderAddressReservation, rhs: ManifestBuilderAddressReservation) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeManifestBuilderAddressReservation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderAddressReservation {
        return try ManifestBuilderAddressReservation(
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderAddressReservation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderAddressReservation_lift(_ buf: RustBuffer) throws -> ManifestBuilderAddressReservation {
    return try FfiConverterTypeManifestBuilderAddressReservation.lift(buf)
}

public func FfiConverterTypeManifestBuilderAddressReservation_lower(_ value: ManifestBuilderAddressReservation) -> RustBuffer {
    return FfiConverterTypeManifestBuilderAddressReservation.lower(value)
}


public struct ManifestBuilderBucket {
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String) {
        self.`name` = `name`
    }
}


extension ManifestBuilderBucket: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderBucket, rhs: ManifestBuilderBucket) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeManifestBuilderBucket: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderBucket {
        return try ManifestBuilderBucket(
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderBucket, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderBucket_lift(_ buf: RustBuffer) throws -> ManifestBuilderBucket {
    return try FfiConverterTypeManifestBuilderBucket.lift(buf)
}

public func FfiConverterTypeManifestBuilderBucket_lower(_ value: ManifestBuilderBucket) -> RustBuffer {
    return FfiConverterTypeManifestBuilderBucket.lower(value)
}


public struct ManifestBuilderMapEntry {
    public var `key`: ManifestBuilderValue
    public var `value`: ManifestBuilderValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: ManifestBuilderValue, `value`: ManifestBuilderValue) {
        self.`key` = `key`
        self.`value` = `value`
    }
}



public struct FfiConverterTypeManifestBuilderMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderMapEntry {
        return try ManifestBuilderMapEntry(
            `key`: FfiConverterTypeManifestBuilderValue.read(from: &buf), 
            `value`: FfiConverterTypeManifestBuilderValue.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderMapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeManifestBuilderValue.write(value.`key`, into: &buf)
        FfiConverterTypeManifestBuilderValue.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderMapEntry_lift(_ buf: RustBuffer) throws -> ManifestBuilderMapEntry {
    return try FfiConverterTypeManifestBuilderMapEntry.lift(buf)
}

public func FfiConverterTypeManifestBuilderMapEntry_lower(_ value: ManifestBuilderMapEntry) -> RustBuffer {
    return FfiConverterTypeManifestBuilderMapEntry.lower(value)
}


public struct ManifestBuilderNamedAddress {
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String) {
        self.`name` = `name`
    }
}


extension ManifestBuilderNamedAddress: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderNamedAddress, rhs: ManifestBuilderNamedAddress) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeManifestBuilderNamedAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderNamedAddress {
        return try ManifestBuilderNamedAddress(
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderNamedAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderNamedAddress_lift(_ buf: RustBuffer) throws -> ManifestBuilderNamedAddress {
    return try FfiConverterTypeManifestBuilderNamedAddress.lift(buf)
}

public func FfiConverterTypeManifestBuilderNamedAddress_lower(_ value: ManifestBuilderNamedAddress) -> RustBuffer {
    return FfiConverterTypeManifestBuilderNamedAddress.lower(value)
}


public struct ManifestBuilderProof {
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String) {
        self.`name` = `name`
    }
}


extension ManifestBuilderProof: Equatable, Hashable {
    public static func ==(lhs: ManifestBuilderProof, rhs: ManifestBuilderProof) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeManifestBuilderProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderProof {
        return try ManifestBuilderProof(
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestBuilderProof, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeManifestBuilderProof_lift(_ buf: RustBuffer) throws -> ManifestBuilderProof {
    return try FfiConverterTypeManifestBuilderProof.lift(buf)
}

public func FfiConverterTypeManifestBuilderProof_lower(_ value: ManifestBuilderProof) -> RustBuffer {
    return FfiConverterTypeManifestBuilderProof.lower(value)
}


public struct ManifestProof {
    public var `value`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: UInt32) {
        self.`value` = `value`
    }
}


extension ManifestProof: Equatable, Hashable {
    public static func ==(lhs: ManifestProof, rhs: ManifestProof) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeManifestProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestProof {
        return try ManifestProof(
            `value`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestProof, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeManifestProof_lift(_ buf: RustBuffer) throws -> ManifestProof {
    return try FfiConverterTypeManifestProof.lift(buf)
}

public func FfiConverterTypeManifestProof_lower(_ value: ManifestProof) -> RustBuffer {
    return FfiConverterTypeManifestProof.lower(value)
}


public struct MapEntry {
    public var `key`: ManifestValue
    public var `value`: ManifestValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: ManifestValue, `value`: ManifestValue) {
        self.`key` = `key`
        self.`value` = `value`
    }
}



public struct FfiConverterTypeMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MapEntry {
        return try MapEntry(
            `key`: FfiConverterTypeManifestValue.read(from: &buf), 
            `value`: FfiConverterTypeManifestValue.read(from: &buf)
        )
    }

    public static func write(_ value: MapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeManifestValue.write(value.`key`, into: &buf)
        FfiConverterTypeManifestValue.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeMapEntry_lift(_ buf: RustBuffer) throws -> MapEntry {
    return try FfiConverterTypeMapEntry.lift(buf)
}

public func FfiConverterTypeMapEntry_lower(_ value: MapEntry) -> RustBuffer {
    return FfiConverterTypeMapEntry.lower(value)
}


public struct MetadataInitEntry {
    public var `value`: MetadataValue?
    public var `lock`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: MetadataValue?, `lock`: Bool) {
        self.`value` = `value`
        self.`lock` = `lock`
    }
}



public struct FfiConverterTypeMetadataInitEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataInitEntry {
        return try MetadataInitEntry(
            `value`: FfiConverterOptionTypeMetadataValue.read(from: &buf), 
            `lock`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataInitEntry, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMetadataValue.write(value.`value`, into: &buf)
        FfiConverterBool.write(value.`lock`, into: &buf)
    }
}


public func FfiConverterTypeMetadataInitEntry_lift(_ buf: RustBuffer) throws -> MetadataInitEntry {
    return try FfiConverterTypeMetadataInitEntry.lift(buf)
}

public func FfiConverterTypeMetadataInitEntry_lower(_ value: MetadataInitEntry) -> RustBuffer {
    return FfiConverterTypeMetadataInitEntry.lower(value)
}


public struct MetadataModuleConfig {
    public var `init`: [String: MetadataInitEntry]
    public var `roles`: [String: AccessRule?]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`init`: [String: MetadataInitEntry], `roles`: [String: AccessRule?]) {
        self.`init` = `init`
        self.`roles` = `roles`
    }
}



public struct FfiConverterTypeMetadataModuleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataModuleConfig {
        return try MetadataModuleConfig(
            `init`: FfiConverterDictionaryStringTypeMetadataInitEntry.read(from: &buf), 
            `roles`: FfiConverterDictionaryStringOptionTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataModuleConfig, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeMetadataInitEntry.write(value.`init`, into: &buf)
        FfiConverterDictionaryStringOptionTypeAccessRule.write(value.`roles`, into: &buf)
    }
}


public func FfiConverterTypeMetadataModuleConfig_lift(_ buf: RustBuffer) throws -> MetadataModuleConfig {
    return try FfiConverterTypeMetadataModuleConfig.lift(buf)
}

public func FfiConverterTypeMetadataModuleConfig_lower(_ value: MetadataModuleConfig) -> RustBuffer {
    return FfiConverterTypeMetadataModuleConfig.lower(value)
}


public struct MintFungibleResourceEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeMintFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintFungibleResourceEvent {
        return try MintFungibleResourceEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MintFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeMintFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> MintFungibleResourceEvent {
    return try FfiConverterTypeMintFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeMintFungibleResourceEvent_lower(_ value: MintFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeMintFungibleResourceEvent.lower(value)
}


public struct MintNonFungibleResourceEvent {
    public var `ids`: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ids`: [NonFungibleLocalId]) {
        self.`ids` = `ids`
    }
}


extension MintNonFungibleResourceEvent: Equatable, Hashable {
    public static func ==(lhs: MintNonFungibleResourceEvent, rhs: MintNonFungibleResourceEvent) -> Bool {
        if lhs.`ids` != rhs.`ids` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ids`)
    }
}


public struct FfiConverterTypeMintNonFungibleResourceEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintNonFungibleResourceEvent {
        return try MintNonFungibleResourceEvent(
            `ids`: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: MintNonFungibleResourceEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, into: &buf)
    }
}


public func FfiConverterTypeMintNonFungibleResourceEvent_lift(_ buf: RustBuffer) throws -> MintNonFungibleResourceEvent {
    return try FfiConverterTypeMintNonFungibleResourceEvent.lift(buf)
}

public func FfiConverterTypeMintNonFungibleResourceEvent_lower(_ value: MintNonFungibleResourceEvent) -> RustBuffer {
    return FfiConverterTypeMintNonFungibleResourceEvent.lower(value)
}


public struct MultiResourcePoolContributionEvent {
    public var `contributedResources`: [String: Decimal]
    public var `poolUnitsMinted`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`contributedResources`: [String: Decimal], `poolUnitsMinted`: Decimal) {
        self.`contributedResources` = `contributedResources`
        self.`poolUnitsMinted` = `poolUnitsMinted`
    }
}



public struct FfiConverterTypeMultiResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolContributionEvent {
        return try MultiResourcePoolContributionEvent(
            `contributedResources`: FfiConverterDictionaryStringTypeDecimal.read(from: &buf), 
            `poolUnitsMinted`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeDecimal.write(value.`contributedResources`, into: &buf)
        FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolContributionEvent {
    return try FfiConverterTypeMultiResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolContributionEvent_lower(_ value: MultiResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolContributionEvent.lower(value)
}


public struct MultiResourcePoolDepositEvent {
    public var `resourceAddress`: Address
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address, `amount`: Decimal) {
        self.`resourceAddress` = `resourceAddress`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeMultiResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolDepositEvent {
        return try MultiResourcePoolDepositEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolDepositEvent {
    return try FfiConverterTypeMultiResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolDepositEvent_lower(_ value: MultiResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolDepositEvent.lower(value)
}


public struct MultiResourcePoolRedemptionEvent {
    public var `poolUnitTokensRedeemed`: Decimal
    public var `redeemedResources`: [String: Decimal]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`poolUnitTokensRedeemed`: Decimal, `redeemedResources`: [String: Decimal]) {
        self.`poolUnitTokensRedeemed` = `poolUnitTokensRedeemed`
        self.`redeemedResources` = `redeemedResources`
    }
}



public struct FfiConverterTypeMultiResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolRedemptionEvent {
        return try MultiResourcePoolRedemptionEvent(
            `poolUnitTokensRedeemed`: FfiConverterTypeDecimal.read(from: &buf), 
            `redeemedResources`: FfiConverterDictionaryStringTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.`redeemedResources`, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolRedemptionEvent {
    return try FfiConverterTypeMultiResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolRedemptionEvent_lower(_ value: MultiResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolRedemptionEvent.lower(value)
}


public struct MultiResourcePoolWithdrawEvent {
    public var `resourceAddress`: Address
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address, `amount`: Decimal) {
        self.`resourceAddress` = `resourceAddress`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeMultiResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiResourcePoolWithdrawEvent {
        return try MultiResourcePoolWithdrawEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: MultiResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeMultiResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> MultiResourcePoolWithdrawEvent {
    return try FfiConverterTypeMultiResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeMultiResourcePoolWithdrawEvent_lower(_ value: MultiResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeMultiResourcePoolWithdrawEvent.lower(value)
}


public struct NonFungibleVaultDepositEvent {
    public var `ids`: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ids`: [NonFungibleLocalId]) {
        self.`ids` = `ids`
    }
}


extension NonFungibleVaultDepositEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultDepositEvent, rhs: NonFungibleVaultDepositEvent) -> Bool {
        if lhs.`ids` != rhs.`ids` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ids`)
    }
}


public struct FfiConverterTypeNonFungibleVaultDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultDepositEvent {
        return try NonFungibleVaultDepositEvent(
            `ids`: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultDepositEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultDepositEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultDepositEvent {
    return try FfiConverterTypeNonFungibleVaultDepositEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultDepositEvent_lower(_ value: NonFungibleVaultDepositEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultDepositEvent.lower(value)
}


public struct NonFungibleVaultRecallEvent {
    public var `ids`: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ids`: [NonFungibleLocalId]) {
        self.`ids` = `ids`
    }
}


extension NonFungibleVaultRecallEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultRecallEvent, rhs: NonFungibleVaultRecallEvent) -> Bool {
        if lhs.`ids` != rhs.`ids` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ids`)
    }
}


public struct FfiConverterTypeNonFungibleVaultRecallEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultRecallEvent {
        return try NonFungibleVaultRecallEvent(
            `ids`: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultRecallEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultRecallEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultRecallEvent {
    return try FfiConverterTypeNonFungibleVaultRecallEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultRecallEvent_lower(_ value: NonFungibleVaultRecallEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultRecallEvent.lower(value)
}


public struct NonFungibleVaultWithdrawEvent {
    public var `ids`: [NonFungibleLocalId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ids`: [NonFungibleLocalId]) {
        self.`ids` = `ids`
    }
}


extension NonFungibleVaultWithdrawEvent: Equatable, Hashable {
    public static func ==(lhs: NonFungibleVaultWithdrawEvent, rhs: NonFungibleVaultWithdrawEvent) -> Bool {
        if lhs.`ids` != rhs.`ids` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ids`)
    }
}


public struct FfiConverterTypeNonFungibleVaultWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleVaultWithdrawEvent {
        return try NonFungibleVaultWithdrawEvent(
            `ids`: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleVaultWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, into: &buf)
    }
}


public func FfiConverterTypeNonFungibleVaultWithdrawEvent_lift(_ buf: RustBuffer) throws -> NonFungibleVaultWithdrawEvent {
    return try FfiConverterTypeNonFungibleVaultWithdrawEvent.lift(buf)
}

public func FfiConverterTypeNonFungibleVaultWithdrawEvent_lower(_ value: NonFungibleVaultWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeNonFungibleVaultWithdrawEvent.lower(value)
}


public struct OneResourcePoolContributionEvent {
    public var `amountOfResourcesContributed`: Decimal
    public var `poolUnitsMinted`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amountOfResourcesContributed`: Decimal, `poolUnitsMinted`: Decimal) {
        self.`amountOfResourcesContributed` = `amountOfResourcesContributed`
        self.`poolUnitsMinted` = `poolUnitsMinted`
    }
}



public struct FfiConverterTypeOneResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolContributionEvent {
        return try OneResourcePoolContributionEvent(
            `amountOfResourcesContributed`: FfiConverterTypeDecimal.read(from: &buf), 
            `poolUnitsMinted`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amountOfResourcesContributed`, into: &buf)
        FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolContributionEvent {
    return try FfiConverterTypeOneResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolContributionEvent_lower(_ value: OneResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolContributionEvent.lower(value)
}


public struct OneResourcePoolDepositEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeOneResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolDepositEvent {
        return try OneResourcePoolDepositEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolDepositEvent {
    return try FfiConverterTypeOneResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolDepositEvent_lower(_ value: OneResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolDepositEvent.lower(value)
}


public struct OneResourcePoolRedemptionEvent {
    public var `poolUnitTokensRedeemed`: Decimal
    public var `redeemedAmount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`poolUnitTokensRedeemed`: Decimal, `redeemedAmount`: Decimal) {
        self.`poolUnitTokensRedeemed` = `poolUnitTokensRedeemed`
        self.`redeemedAmount` = `redeemedAmount`
    }
}



public struct FfiConverterTypeOneResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolRedemptionEvent {
        return try OneResourcePoolRedemptionEvent(
            `poolUnitTokensRedeemed`: FfiConverterTypeDecimal.read(from: &buf), 
            `redeemedAmount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, into: &buf)
        FfiConverterTypeDecimal.write(value.`redeemedAmount`, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolRedemptionEvent {
    return try FfiConverterTypeOneResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolRedemptionEvent_lower(_ value: OneResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolRedemptionEvent.lower(value)
}


public struct OneResourcePoolWithdrawEvent {
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: Decimal) {
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeOneResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OneResourcePoolWithdrawEvent {
        return try OneResourcePoolWithdrawEvent(
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: OneResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeOneResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> OneResourcePoolWithdrawEvent {
    return try FfiConverterTypeOneResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeOneResourcePoolWithdrawEvent_lower(_ value: OneResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeOneResourcePoolWithdrawEvent.lower(value)
}


public struct PackageAddresses {
    public var `packagePackage`: Address
    public var `resourcePackage`: Address
    public var `accountPackage`: Address
    public var `identityPackage`: Address
    public var `consensusManagerPackage`: Address
    public var `accessControllerPackage`: Address
    public var `poolPackage`: Address
    public var `transactionProcessorPackage`: Address
    public var `metadataModulePackage`: Address
    public var `royaltyModulePackage`: Address
    public var `roleAssignmentModulePackage`: Address
    public var `genesisHelperPackage`: Address
    public var `faucetPackage`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`packagePackage`: Address, `resourcePackage`: Address, `accountPackage`: Address, `identityPackage`: Address, `consensusManagerPackage`: Address, `accessControllerPackage`: Address, `poolPackage`: Address, `transactionProcessorPackage`: Address, `metadataModulePackage`: Address, `royaltyModulePackage`: Address, `roleAssignmentModulePackage`: Address, `genesisHelperPackage`: Address, `faucetPackage`: Address) {
        self.`packagePackage` = `packagePackage`
        self.`resourcePackage` = `resourcePackage`
        self.`accountPackage` = `accountPackage`
        self.`identityPackage` = `identityPackage`
        self.`consensusManagerPackage` = `consensusManagerPackage`
        self.`accessControllerPackage` = `accessControllerPackage`
        self.`poolPackage` = `poolPackage`
        self.`transactionProcessorPackage` = `transactionProcessorPackage`
        self.`metadataModulePackage` = `metadataModulePackage`
        self.`royaltyModulePackage` = `royaltyModulePackage`
        self.`roleAssignmentModulePackage` = `roleAssignmentModulePackage`
        self.`genesisHelperPackage` = `genesisHelperPackage`
        self.`faucetPackage` = `faucetPackage`
    }
}



public struct FfiConverterTypePackageAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddresses {
        return try PackageAddresses(
            `packagePackage`: FfiConverterTypeAddress.read(from: &buf), 
            `resourcePackage`: FfiConverterTypeAddress.read(from: &buf), 
            `accountPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `identityPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `consensusManagerPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `accessControllerPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `poolPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `transactionProcessorPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `metadataModulePackage`: FfiConverterTypeAddress.read(from: &buf), 
            `royaltyModulePackage`: FfiConverterTypeAddress.read(from: &buf), 
            `roleAssignmentModulePackage`: FfiConverterTypeAddress.read(from: &buf), 
            `genesisHelperPackage`: FfiConverterTypeAddress.read(from: &buf), 
            `faucetPackage`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PackageAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`packagePackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`resourcePackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`accountPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`identityPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`consensusManagerPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`accessControllerPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`poolPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`transactionProcessorPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`metadataModulePackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`royaltyModulePackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`roleAssignmentModulePackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`genesisHelperPackage`, into: &buf)
        FfiConverterTypeAddress.write(value.`faucetPackage`, into: &buf)
    }
}


public func FfiConverterTypePackageAddresses_lift(_ buf: RustBuffer) throws -> PackageAddresses {
    return try FfiConverterTypePackageAddresses.lift(buf)
}

public func FfiConverterTypePackageAddresses_lower(_ value: PackageAddresses) -> RustBuffer {
    return FfiConverterTypePackageAddresses.lower(value)
}


public struct PlainTextMessage {
    public var `mimeType`: String
    public var `message`: MessageContent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mimeType`: String, `message`: MessageContent) {
        self.`mimeType` = `mimeType`
        self.`message` = `message`
    }
}


extension PlainTextMessage: Equatable, Hashable {
    public static func ==(lhs: PlainTextMessage, rhs: PlainTextMessage) -> Bool {
        if lhs.`mimeType` != rhs.`mimeType` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`mimeType`)
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypePlainTextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlainTextMessage {
        return try PlainTextMessage(
            `mimeType`: FfiConverterString.read(from: &buf), 
            `message`: FfiConverterTypeMessageContent.read(from: &buf)
        )
    }

    public static func write(_ value: PlainTextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`mimeType`, into: &buf)
        FfiConverterTypeMessageContent.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypePlainTextMessage_lift(_ buf: RustBuffer) throws -> PlainTextMessage {
    return try FfiConverterTypePlainTextMessage.lift(buf)
}

public func FfiConverterTypePlainTextMessage_lower(_ value: PlainTextMessage) -> RustBuffer {
    return FfiConverterTypePlainTextMessage.lower(value)
}


public struct ProtocolUpdateReadinessSignalEvent {
    public var `protocolVersionName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`protocolVersionName`: String) {
        self.`protocolVersionName` = `protocolVersionName`
    }
}


extension ProtocolUpdateReadinessSignalEvent: Equatable, Hashable {
    public static func ==(lhs: ProtocolUpdateReadinessSignalEvent, rhs: ProtocolUpdateReadinessSignalEvent) -> Bool {
        if lhs.`protocolVersionName` != rhs.`protocolVersionName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`protocolVersionName`)
    }
}


public struct FfiConverterTypeProtocolUpdateReadinessSignalEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtocolUpdateReadinessSignalEvent {
        return try ProtocolUpdateReadinessSignalEvent(
            `protocolVersionName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ProtocolUpdateReadinessSignalEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`protocolVersionName`, into: &buf)
    }
}


public func FfiConverterTypeProtocolUpdateReadinessSignalEvent_lift(_ buf: RustBuffer) throws -> ProtocolUpdateReadinessSignalEvent {
    return try FfiConverterTypeProtocolUpdateReadinessSignalEvent.lift(buf)
}

public func FfiConverterTypeProtocolUpdateReadinessSignalEvent_lower(_ value: ProtocolUpdateReadinessSignalEvent) -> RustBuffer {
    return FfiConverterTypeProtocolUpdateReadinessSignalEvent.lower(value)
}


public struct RecoveryProposal {
    public var `ruleSet`: RuleSet
    public var `timedRecoveryDelayInMinutes`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ruleSet`: RuleSet, `timedRecoveryDelayInMinutes`: UInt32?) {
        self.`ruleSet` = `ruleSet`
        self.`timedRecoveryDelayInMinutes` = `timedRecoveryDelayInMinutes`
    }
}



public struct FfiConverterTypeRecoveryProposal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryProposal {
        return try RecoveryProposal(
            `ruleSet`: FfiConverterTypeRuleSet.read(from: &buf), 
            `timedRecoveryDelayInMinutes`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RecoveryProposal, into buf: inout [UInt8]) {
        FfiConverterTypeRuleSet.write(value.`ruleSet`, into: &buf)
        FfiConverterOptionUInt32.write(value.`timedRecoveryDelayInMinutes`, into: &buf)
    }
}


public func FfiConverterTypeRecoveryProposal_lift(_ buf: RustBuffer) throws -> RecoveryProposal {
    return try FfiConverterTypeRecoveryProposal.lift(buf)
}

public func FfiConverterTypeRecoveryProposal_lower(_ value: RecoveryProposal) -> RustBuffer {
    return FfiConverterTypeRecoveryProposal.lower(value)
}


public struct RegisterValidatorEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension RegisterValidatorEvent: Equatable, Hashable {
    public static func ==(lhs: RegisterValidatorEvent, rhs: RegisterValidatorEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeRegisterValidatorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterValidatorEvent {
        return try RegisterValidatorEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterValidatorEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeRegisterValidatorEvent_lift(_ buf: RustBuffer) throws -> RegisterValidatorEvent {
    return try FfiConverterTypeRegisterValidatorEvent.lift(buf)
}

public func FfiConverterTypeRegisterValidatorEvent_lower(_ value: RegisterValidatorEvent) -> RustBuffer {
    return FfiConverterTypeRegisterValidatorEvent.lower(value)
}


public struct RemoveMetadataEvent {
    public var `key`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String) {
        self.`key` = `key`
    }
}


extension RemoveMetadataEvent: Equatable, Hashable {
    public static func ==(lhs: RemoveMetadataEvent, rhs: RemoveMetadataEvent) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
    }
}


public struct FfiConverterTypeRemoveMetadataEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RemoveMetadataEvent {
        return try RemoveMetadataEvent(
            `key`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RemoveMetadataEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
    }
}


public func FfiConverterTypeRemoveMetadataEvent_lift(_ buf: RustBuffer) throws -> RemoveMetadataEvent {
    return try FfiConverterTypeRemoveMetadataEvent.lift(buf)
}

public func FfiConverterTypeRemoveMetadataEvent_lower(_ value: RemoveMetadataEvent) -> RustBuffer {
    return FfiConverterTypeRemoveMetadataEvent.lower(value)
}


public struct ResourceAddresses {
    public var `xrd`: Address
    public var `secp256k1SignatureVirtualBadge`: Address
    public var `ed25519SignatureVirtualBadge`: Address
    public var `packageOfDirectCallerVirtualBadge`: Address
    public var `globalCallerVirtualBadge`: Address
    public var `systemTransactionBadge`: Address
    public var `packageOwnerBadge`: Address
    public var `validatorOwnerBadge`: Address
    public var `accountOwnerBadge`: Address
    public var `identityOwnerBadge`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`xrd`: Address, `secp256k1SignatureVirtualBadge`: Address, `ed25519SignatureVirtualBadge`: Address, `packageOfDirectCallerVirtualBadge`: Address, `globalCallerVirtualBadge`: Address, `systemTransactionBadge`: Address, `packageOwnerBadge`: Address, `validatorOwnerBadge`: Address, `accountOwnerBadge`: Address, `identityOwnerBadge`: Address) {
        self.`xrd` = `xrd`
        self.`secp256k1SignatureVirtualBadge` = `secp256k1SignatureVirtualBadge`
        self.`ed25519SignatureVirtualBadge` = `ed25519SignatureVirtualBadge`
        self.`packageOfDirectCallerVirtualBadge` = `packageOfDirectCallerVirtualBadge`
        self.`globalCallerVirtualBadge` = `globalCallerVirtualBadge`
        self.`systemTransactionBadge` = `systemTransactionBadge`
        self.`packageOwnerBadge` = `packageOwnerBadge`
        self.`validatorOwnerBadge` = `validatorOwnerBadge`
        self.`accountOwnerBadge` = `accountOwnerBadge`
        self.`identityOwnerBadge` = `identityOwnerBadge`
    }
}



public struct FfiConverterTypeResourceAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddresses {
        return try ResourceAddresses(
            `xrd`: FfiConverterTypeAddress.read(from: &buf), 
            `secp256k1SignatureVirtualBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `ed25519SignatureVirtualBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `packageOfDirectCallerVirtualBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `globalCallerVirtualBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `systemTransactionBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `packageOwnerBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `validatorOwnerBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `accountOwnerBadge`: FfiConverterTypeAddress.read(from: &buf), 
            `identityOwnerBadge`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`xrd`, into: &buf)
        FfiConverterTypeAddress.write(value.`secp256k1SignatureVirtualBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`ed25519SignatureVirtualBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`packageOfDirectCallerVirtualBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`globalCallerVirtualBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`systemTransactionBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`packageOwnerBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`validatorOwnerBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`accountOwnerBadge`, into: &buf)
        FfiConverterTypeAddress.write(value.`identityOwnerBadge`, into: &buf)
    }
}


public func FfiConverterTypeResourceAddresses_lift(_ buf: RustBuffer) throws -> ResourceAddresses {
    return try FfiConverterTypeResourceAddresses.lift(buf)
}

public func FfiConverterTypeResourceAddresses_lower(_ value: ResourceAddresses) -> RustBuffer {
    return FfiConverterTypeResourceAddresses.lower(value)
}


public struct ResourceManagerRole {
    public var `role`: AccessRule?
    public var `roleUpdater`: AccessRule?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`role`: AccessRule?, `roleUpdater`: AccessRule?) {
        self.`role` = `role`
        self.`roleUpdater` = `roleUpdater`
    }
}



public struct FfiConverterTypeResourceManagerRole: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceManagerRole {
        return try ResourceManagerRole(
            `role`: FfiConverterOptionTypeAccessRule.read(from: &buf), 
            `roleUpdater`: FfiConverterOptionTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceManagerRole, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAccessRule.write(value.`role`, into: &buf)
        FfiConverterOptionTypeAccessRule.write(value.`roleUpdater`, into: &buf)
    }
}


public func FfiConverterTypeResourceManagerRole_lift(_ buf: RustBuffer) throws -> ResourceManagerRole {
    return try FfiConverterTypeResourceManagerRole.lift(buf)
}

public func FfiConverterTypeResourceManagerRole_lower(_ value: ResourceManagerRole) -> RustBuffer {
    return FfiConverterTypeResourceManagerRole.lower(value)
}


public struct RoundChangeEvent {
    public var `round`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`round`: UInt64) {
        self.`round` = `round`
    }
}


extension RoundChangeEvent: Equatable, Hashable {
    public static func ==(lhs: RoundChangeEvent, rhs: RoundChangeEvent) -> Bool {
        if lhs.`round` != rhs.`round` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`round`)
    }
}


public struct FfiConverterTypeRoundChangeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundChangeEvent {
        return try RoundChangeEvent(
            `round`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoundChangeEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`round`, into: &buf)
    }
}


public func FfiConverterTypeRoundChangeEvent_lift(_ buf: RustBuffer) throws -> RoundChangeEvent {
    return try FfiConverterTypeRoundChangeEvent.lift(buf)
}

public func FfiConverterTypeRoundChangeEvent_lower(_ value: RoundChangeEvent) -> RustBuffer {
    return FfiConverterTypeRoundChangeEvent.lower(value)
}


public struct RuleSet {
    public var `primaryRole`: AccessRule
    public var `recoveryRole`: AccessRule
    public var `confirmationRole`: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`primaryRole`: AccessRule, `recoveryRole`: AccessRule, `confirmationRole`: AccessRule) {
        self.`primaryRole` = `primaryRole`
        self.`recoveryRole` = `recoveryRole`
        self.`confirmationRole` = `confirmationRole`
    }
}



public struct FfiConverterTypeRuleSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuleSet {
        return try RuleSet(
            `primaryRole`: FfiConverterTypeAccessRule.read(from: &buf), 
            `recoveryRole`: FfiConverterTypeAccessRule.read(from: &buf), 
            `confirmationRole`: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: RuleSet, into buf: inout [UInt8]) {
        FfiConverterTypeAccessRule.write(value.`primaryRole`, into: &buf)
        FfiConverterTypeAccessRule.write(value.`recoveryRole`, into: &buf)
        FfiConverterTypeAccessRule.write(value.`confirmationRole`, into: &buf)
    }
}


public func FfiConverterTypeRuleSet_lift(_ buf: RustBuffer) throws -> RuleSet {
    return try FfiConverterTypeRuleSet.lift(buf)
}

public func FfiConverterTypeRuleSet_lower(_ value: RuleSet) -> RustBuffer {
    return FfiConverterTypeRuleSet.lower(value)
}


public struct RuleSetUpdateEvent {
    public var `proposer`: Proposer
    public var `proposal`: RecoveryProposal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`proposer`: Proposer, `proposal`: RecoveryProposal) {
        self.`proposer` = `proposer`
        self.`proposal` = `proposal`
    }
}



public struct FfiConverterTypeRuleSetUpdateEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuleSetUpdateEvent {
        return try RuleSetUpdateEvent(
            `proposer`: FfiConverterTypeProposer.read(from: &buf), 
            `proposal`: FfiConverterTypeRecoveryProposal.read(from: &buf)
        )
    }

    public static func write(_ value: RuleSetUpdateEvent, into buf: inout [UInt8]) {
        FfiConverterTypeProposer.write(value.`proposer`, into: &buf)
        FfiConverterTypeRecoveryProposal.write(value.`proposal`, into: &buf)
    }
}


public func FfiConverterTypeRuleSetUpdateEvent_lift(_ buf: RustBuffer) throws -> RuleSetUpdateEvent {
    return try FfiConverterTypeRuleSetUpdateEvent.lift(buf)
}

public func FfiConverterTypeRuleSetUpdateEvent_lower(_ value: RuleSetUpdateEvent) -> RustBuffer {
    return FfiConverterTypeRuleSetUpdateEvent.lower(value)
}


public struct Schema {
    public var `localTypeId`: LocalTypeId
    public var `schema`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`localTypeId`: LocalTypeId, `schema`: [UInt8]) {
        self.`localTypeId` = `localTypeId`
        self.`schema` = `schema`
    }
}


extension Schema: Equatable, Hashable {
    public static func ==(lhs: Schema, rhs: Schema) -> Bool {
        if lhs.`localTypeId` != rhs.`localTypeId` {
            return false
        }
        if lhs.`schema` != rhs.`schema` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`localTypeId`)
        hasher.combine(`schema`)
    }
}


public struct FfiConverterTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Schema {
        return try Schema(
            `localTypeId`: FfiConverterTypeLocalTypeId.read(from: &buf), 
            `schema`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Schema, into buf: inout [UInt8]) {
        FfiConverterTypeLocalTypeId.write(value.`localTypeId`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`schema`, into: &buf)
    }
}


public func FfiConverterTypeSchema_lift(_ buf: RustBuffer) throws -> Schema {
    return try FfiConverterTypeSchema.lift(buf)
}

public func FfiConverterTypeSchema_lower(_ value: Schema) -> RustBuffer {
    return FfiConverterTypeSchema.lower(value)
}


public struct Secp256k1PublicKey {
    public var `value`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: [UInt8]) {
        self.`value` = `value`
    }
}


extension Secp256k1PublicKey: Equatable, Hashable {
    public static func ==(lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return try Secp256k1PublicKey(
            `value`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}


public struct SecurityStructureRole {
    public var `superAdminFactors`: [PublicKey]
    public var `thresholdFactors`: [PublicKey]
    public var `threshold`: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`superAdminFactors`: [PublicKey], `thresholdFactors`: [PublicKey], `threshold`: UInt8) {
        self.`superAdminFactors` = `superAdminFactors`
        self.`thresholdFactors` = `thresholdFactors`
        self.`threshold` = `threshold`
    }
}


extension SecurityStructureRole: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureRole, rhs: SecurityStructureRole) -> Bool {
        if lhs.`superAdminFactors` != rhs.`superAdminFactors` {
            return false
        }
        if lhs.`thresholdFactors` != rhs.`thresholdFactors` {
            return false
        }
        if lhs.`threshold` != rhs.`threshold` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`superAdminFactors`)
        hasher.combine(`thresholdFactors`)
        hasher.combine(`threshold`)
    }
}


public struct FfiConverterTypeSecurityStructureRole: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureRole {
        return try SecurityStructureRole(
            `superAdminFactors`: FfiConverterSequenceTypePublicKey.read(from: &buf), 
            `thresholdFactors`: FfiConverterSequenceTypePublicKey.read(from: &buf), 
            `threshold`: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureRole, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.`superAdminFactors`, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.`thresholdFactors`, into: &buf)
        FfiConverterUInt8.write(value.`threshold`, into: &buf)
    }
}


public func FfiConverterTypeSecurityStructureRole_lift(_ buf: RustBuffer) throws -> SecurityStructureRole {
    return try FfiConverterTypeSecurityStructureRole.lift(buf)
}

public func FfiConverterTypeSecurityStructureRole_lower(_ value: SecurityStructureRole) -> RustBuffer {
    return FfiConverterTypeSecurityStructureRole.lower(value)
}


public struct SetAndLockRoleEvent {
    public var `roleKey`: String
    public var `rule`: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`roleKey`: String, `rule`: AccessRule) {
        self.`roleKey` = `roleKey`
        self.`rule` = `rule`
    }
}



public struct FfiConverterTypeSetAndLockRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetAndLockRoleEvent {
        return try SetAndLockRoleEvent(
            `roleKey`: FfiConverterString.read(from: &buf), 
            `rule`: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetAndLockRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`roleKey`, into: &buf)
        FfiConverterTypeAccessRule.write(value.`rule`, into: &buf)
    }
}


public func FfiConverterTypeSetAndLockRoleEvent_lift(_ buf: RustBuffer) throws -> SetAndLockRoleEvent {
    return try FfiConverterTypeSetAndLockRoleEvent.lift(buf)
}

public func FfiConverterTypeSetAndLockRoleEvent_lower(_ value: SetAndLockRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetAndLockRoleEvent.lower(value)
}


public struct SetMetadataEvent {
    public var `key`: String
    public var `value`: MetadataValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: MetadataValue) {
        self.`key` = `key`
        self.`value` = `value`
    }
}



public struct FfiConverterTypeSetMetadataEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetMetadataEvent {
        return try SetMetadataEvent(
            `key`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterTypeMetadataValue.read(from: &buf)
        )
    }

    public static func write(_ value: SetMetadataEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterTypeMetadataValue.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeSetMetadataEvent_lift(_ buf: RustBuffer) throws -> SetMetadataEvent {
    return try FfiConverterTypeSetMetadataEvent.lift(buf)
}

public func FfiConverterTypeSetMetadataEvent_lower(_ value: SetMetadataEvent) -> RustBuffer {
    return FfiConverterTypeSetMetadataEvent.lower(value)
}


public struct SetOwnerRoleEvent {
    public var `rule`: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`rule`: AccessRule) {
        self.`rule` = `rule`
    }
}



public struct FfiConverterTypeSetOwnerRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetOwnerRoleEvent {
        return try SetOwnerRoleEvent(
            `rule`: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetOwnerRoleEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAccessRule.write(value.`rule`, into: &buf)
    }
}


public func FfiConverterTypeSetOwnerRoleEvent_lift(_ buf: RustBuffer) throws -> SetOwnerRoleEvent {
    return try FfiConverterTypeSetOwnerRoleEvent.lift(buf)
}

public func FfiConverterTypeSetOwnerRoleEvent_lower(_ value: SetOwnerRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetOwnerRoleEvent.lower(value)
}


public struct SetRoleEvent {
    public var `roleKey`: String
    public var `rule`: AccessRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`roleKey`: String, `rule`: AccessRule) {
        self.`roleKey` = `roleKey`
        self.`rule` = `rule`
    }
}



public struct FfiConverterTypeSetRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetRoleEvent {
        return try SetRoleEvent(
            `roleKey`: FfiConverterString.read(from: &buf), 
            `rule`: FfiConverterTypeAccessRule.read(from: &buf)
        )
    }

    public static func write(_ value: SetRoleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`roleKey`, into: &buf)
        FfiConverterTypeAccessRule.write(value.`rule`, into: &buf)
    }
}


public func FfiConverterTypeSetRoleEvent_lift(_ buf: RustBuffer) throws -> SetRoleEvent {
    return try FfiConverterTypeSetRoleEvent.lift(buf)
}

public func FfiConverterTypeSetRoleEvent_lower(_ value: SetRoleEvent) -> RustBuffer {
    return FfiConverterTypeSetRoleEvent.lower(value)
}


public struct StakeEvent {
    public var `xrdStaked`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`xrdStaked`: Decimal) {
        self.`xrdStaked` = `xrdStaked`
    }
}



public struct FfiConverterTypeStakeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeEvent {
        return try StakeEvent(
            `xrdStaked`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: StakeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`xrdStaked`, into: &buf)
    }
}


public func FfiConverterTypeStakeEvent_lift(_ buf: RustBuffer) throws -> StakeEvent {
    return try FfiConverterTypeStakeEvent.lift(buf)
}

public func FfiConverterTypeStakeEvent_lower(_ value: StakeEvent) -> RustBuffer {
    return FfiConverterTypeStakeEvent.lower(value)
}


public struct StopTimedRecoveryEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension StopTimedRecoveryEvent: Equatable, Hashable {
    public static func ==(lhs: StopTimedRecoveryEvent, rhs: StopTimedRecoveryEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeStopTimedRecoveryEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StopTimedRecoveryEvent {
        return try StopTimedRecoveryEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: StopTimedRecoveryEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeStopTimedRecoveryEvent_lift(_ buf: RustBuffer) throws -> StopTimedRecoveryEvent {
    return try FfiConverterTypeStopTimedRecoveryEvent.lift(buf)
}

public func FfiConverterTypeStopTimedRecoveryEvent_lower(_ value: StopTimedRecoveryEvent) -> RustBuffer {
    return FfiConverterTypeStopTimedRecoveryEvent.lower(value)
}


public struct TransactionHeader {
    public var `networkId`: UInt8
    public var `startEpochInclusive`: UInt64
    public var `endEpochExclusive`: UInt64
    public var `nonce`: UInt32
    public var `notaryPublicKey`: PublicKey
    public var `notaryIsSignatory`: Bool
    public var `tipPercentage`: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networkId`: UInt8, `startEpochInclusive`: UInt64, `endEpochExclusive`: UInt64, `nonce`: UInt32, `notaryPublicKey`: PublicKey, `notaryIsSignatory`: Bool, `tipPercentage`: UInt16) {
        self.`networkId` = `networkId`
        self.`startEpochInclusive` = `startEpochInclusive`
        self.`endEpochExclusive` = `endEpochExclusive`
        self.`nonce` = `nonce`
        self.`notaryPublicKey` = `notaryPublicKey`
        self.`notaryIsSignatory` = `notaryIsSignatory`
        self.`tipPercentage` = `tipPercentage`
    }
}


extension TransactionHeader: Equatable, Hashable {
    public static func ==(lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.`networkId` != rhs.`networkId` {
            return false
        }
        if lhs.`startEpochInclusive` != rhs.`startEpochInclusive` {
            return false
        }
        if lhs.`endEpochExclusive` != rhs.`endEpochExclusive` {
            return false
        }
        if lhs.`nonce` != rhs.`nonce` {
            return false
        }
        if lhs.`notaryPublicKey` != rhs.`notaryPublicKey` {
            return false
        }
        if lhs.`notaryIsSignatory` != rhs.`notaryIsSignatory` {
            return false
        }
        if lhs.`tipPercentage` != rhs.`tipPercentage` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networkId`)
        hasher.combine(`startEpochInclusive`)
        hasher.combine(`endEpochExclusive`)
        hasher.combine(`nonce`)
        hasher.combine(`notaryPublicKey`)
        hasher.combine(`notaryIsSignatory`)
        hasher.combine(`tipPercentage`)
    }
}


public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return try TransactionHeader(
            `networkId`: FfiConverterUInt8.read(from: &buf), 
            `startEpochInclusive`: FfiConverterUInt64.read(from: &buf), 
            `endEpochExclusive`: FfiConverterUInt64.read(from: &buf), 
            `nonce`: FfiConverterUInt32.read(from: &buf), 
            `notaryPublicKey`: FfiConverterTypePublicKey.read(from: &buf), 
            `notaryIsSignatory`: FfiConverterBool.read(from: &buf), 
            `tipPercentage`: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.`networkId`, into: &buf)
        FfiConverterUInt64.write(value.`startEpochInclusive`, into: &buf)
        FfiConverterUInt64.write(value.`endEpochExclusive`, into: &buf)
        FfiConverterUInt32.write(value.`nonce`, into: &buf)
        FfiConverterTypePublicKey.write(value.`notaryPublicKey`, into: &buf)
        FfiConverterBool.write(value.`notaryIsSignatory`, into: &buf)
        FfiConverterUInt16.write(value.`tipPercentage`, into: &buf)
    }
}


public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}


public struct TransactionManifestModifications {
    public var `addAccessControllerProofs`: [Address]
    public var `addLockFee`: LockFeeModification?
    public var `addAssertions`: [IndexedAssertion]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`addAccessControllerProofs`: [Address], `addLockFee`: LockFeeModification?, `addAssertions`: [IndexedAssertion]) {
        self.`addAccessControllerProofs` = `addAccessControllerProofs`
        self.`addLockFee` = `addLockFee`
        self.`addAssertions` = `addAssertions`
    }
}



public struct FfiConverterTypeTransactionManifestModifications: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestModifications {
        return try TransactionManifestModifications(
            `addAccessControllerProofs`: FfiConverterSequenceTypeAddress.read(from: &buf), 
            `addLockFee`: FfiConverterOptionTypeLockFeeModification.read(from: &buf), 
            `addAssertions`: FfiConverterSequenceTypeIndexedAssertion.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionManifestModifications, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAddress.write(value.`addAccessControllerProofs`, into: &buf)
        FfiConverterOptionTypeLockFeeModification.write(value.`addLockFee`, into: &buf)
        FfiConverterSequenceTypeIndexedAssertion.write(value.`addAssertions`, into: &buf)
    }
}


public func FfiConverterTypeTransactionManifestModifications_lift(_ buf: RustBuffer) throws -> TransactionManifestModifications {
    return try FfiConverterTypeTransactionManifestModifications.lift(buf)
}

public func FfiConverterTypeTransactionManifestModifications_lower(_ value: TransactionManifestModifications) -> RustBuffer {
    return FfiConverterTypeTransactionManifestModifications.lower(value)
}


public struct TwoResourcePoolContributionEvent {
    public var `contributedResources`: [String: Decimal]
    public var `poolUnitsMinted`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`contributedResources`: [String: Decimal], `poolUnitsMinted`: Decimal) {
        self.`contributedResources` = `contributedResources`
        self.`poolUnitsMinted` = `poolUnitsMinted`
    }
}



public struct FfiConverterTypeTwoResourcePoolContributionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolContributionEvent {
        return try TwoResourcePoolContributionEvent(
            `contributedResources`: FfiConverterDictionaryStringTypeDecimal.read(from: &buf), 
            `poolUnitsMinted`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolContributionEvent, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeDecimal.write(value.`contributedResources`, into: &buf)
        FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolContributionEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolContributionEvent {
    return try FfiConverterTypeTwoResourcePoolContributionEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolContributionEvent_lower(_ value: TwoResourcePoolContributionEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolContributionEvent.lower(value)
}


public struct TwoResourcePoolDepositEvent {
    public var `resourceAddress`: Address
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address, `amount`: Decimal) {
        self.`resourceAddress` = `resourceAddress`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeTwoResourcePoolDepositEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolDepositEvent {
        return try TwoResourcePoolDepositEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolDepositEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolDepositEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolDepositEvent {
    return try FfiConverterTypeTwoResourcePoolDepositEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolDepositEvent_lower(_ value: TwoResourcePoolDepositEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolDepositEvent.lower(value)
}


public struct TwoResourcePoolRedemptionEvent {
    public var `poolUnitTokensRedeemed`: Decimal
    public var `redeemedResources`: [String: Decimal]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`poolUnitTokensRedeemed`: Decimal, `redeemedResources`: [String: Decimal]) {
        self.`poolUnitTokensRedeemed` = `poolUnitTokensRedeemed`
        self.`redeemedResources` = `redeemedResources`
    }
}



public struct FfiConverterTypeTwoResourcePoolRedemptionEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolRedemptionEvent {
        return try TwoResourcePoolRedemptionEvent(
            `poolUnitTokensRedeemed`: FfiConverterTypeDecimal.read(from: &buf), 
            `redeemedResources`: FfiConverterDictionaryStringTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolRedemptionEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, into: &buf)
        FfiConverterDictionaryStringTypeDecimal.write(value.`redeemedResources`, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolRedemptionEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolRedemptionEvent {
    return try FfiConverterTypeTwoResourcePoolRedemptionEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolRedemptionEvent_lower(_ value: TwoResourcePoolRedemptionEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolRedemptionEvent.lower(value)
}


public struct TwoResourcePoolWithdrawEvent {
    public var `resourceAddress`: Address
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`resourceAddress`: Address, `amount`: Decimal) {
        self.`resourceAddress` = `resourceAddress`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeTwoResourcePoolWithdrawEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TwoResourcePoolWithdrawEvent {
        return try TwoResourcePoolWithdrawEvent(
            `resourceAddress`: FfiConverterTypeAddress.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: TwoResourcePoolWithdrawEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`resourceAddress`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeTwoResourcePoolWithdrawEvent_lift(_ buf: RustBuffer) throws -> TwoResourcePoolWithdrawEvent {
    return try FfiConverterTypeTwoResourcePoolWithdrawEvent.lift(buf)
}

public func FfiConverterTypeTwoResourcePoolWithdrawEvent_lower(_ value: TwoResourcePoolWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeTwoResourcePoolWithdrawEvent.lower(value)
}


public struct UnlockPrimaryRoleEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension UnlockPrimaryRoleEvent: Equatable, Hashable {
    public static func ==(lhs: UnlockPrimaryRoleEvent, rhs: UnlockPrimaryRoleEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeUnlockPrimaryRoleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnlockPrimaryRoleEvent {
        return try UnlockPrimaryRoleEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UnlockPrimaryRoleEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeUnlockPrimaryRoleEvent_lift(_ buf: RustBuffer) throws -> UnlockPrimaryRoleEvent {
    return try FfiConverterTypeUnlockPrimaryRoleEvent.lift(buf)
}

public func FfiConverterTypeUnlockPrimaryRoleEvent_lower(_ value: UnlockPrimaryRoleEvent) -> RustBuffer {
    return FfiConverterTypeUnlockPrimaryRoleEvent.lower(value)
}


public struct UnregisterValidatorEvent {
    public var `placeholderField`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`placeholderField`: Bool) {
        self.`placeholderField` = `placeholderField`
    }
}


extension UnregisterValidatorEvent: Equatable, Hashable {
    public static func ==(lhs: UnregisterValidatorEvent, rhs: UnregisterValidatorEvent) -> Bool {
        if lhs.`placeholderField` != rhs.`placeholderField` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`placeholderField`)
    }
}


public struct FfiConverterTypeUnregisterValidatorEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnregisterValidatorEvent {
        return try UnregisterValidatorEvent(
            `placeholderField`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UnregisterValidatorEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`placeholderField`, into: &buf)
    }
}


public func FfiConverterTypeUnregisterValidatorEvent_lift(_ buf: RustBuffer) throws -> UnregisterValidatorEvent {
    return try FfiConverterTypeUnregisterValidatorEvent.lift(buf)
}

public func FfiConverterTypeUnregisterValidatorEvent_lower(_ value: UnregisterValidatorEvent) -> RustBuffer {
    return FfiConverterTypeUnregisterValidatorEvent.lower(value)
}


public struct UnstakeEvent {
    public var `stakeUnits`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`stakeUnits`: Decimal) {
        self.`stakeUnits` = `stakeUnits`
    }
}



public struct FfiConverterTypeUnstakeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeEvent {
        return try UnstakeEvent(
            `stakeUnits`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: UnstakeEvent, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal.write(value.`stakeUnits`, into: &buf)
    }
}


public func FfiConverterTypeUnstakeEvent_lift(_ buf: RustBuffer) throws -> UnstakeEvent {
    return try FfiConverterTypeUnstakeEvent.lift(buf)
}

public func FfiConverterTypeUnstakeEvent_lower(_ value: UnstakeEvent) -> RustBuffer {
    return FfiConverterTypeUnstakeEvent.lower(value)
}


public struct UpdateAcceptingStakeDelegationStateEvent {
    public var `acceptsDelegation`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`acceptsDelegation`: Bool) {
        self.`acceptsDelegation` = `acceptsDelegation`
    }
}


extension UpdateAcceptingStakeDelegationStateEvent: Equatable, Hashable {
    public static func ==(lhs: UpdateAcceptingStakeDelegationStateEvent, rhs: UpdateAcceptingStakeDelegationStateEvent) -> Bool {
        if lhs.`acceptsDelegation` != rhs.`acceptsDelegation` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`acceptsDelegation`)
    }
}


public struct FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateAcceptingStakeDelegationStateEvent {
        return try UpdateAcceptingStakeDelegationStateEvent(
            `acceptsDelegation`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateAcceptingStakeDelegationStateEvent, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`acceptsDelegation`, into: &buf)
    }
}


public func FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent_lift(_ buf: RustBuffer) throws -> UpdateAcceptingStakeDelegationStateEvent {
    return try FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.lift(buf)
}

public func FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent_lower(_ value: UpdateAcceptingStakeDelegationStateEvent) -> RustBuffer {
    return FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.lower(value)
}


public struct ValidatorEmissionAppliedEvent {
    public var `epoch`: UInt64
    public var `startingStakePoolXrd`: Decimal
    public var `stakePoolAddedXrd`: Decimal
    public var `totalStakeUnitSupply`: Decimal
    public var `validatorFeeXrd`: Decimal
    public var `proposalsMade`: UInt64
    public var `proposalsMissed`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`epoch`: UInt64, `startingStakePoolXrd`: Decimal, `stakePoolAddedXrd`: Decimal, `totalStakeUnitSupply`: Decimal, `validatorFeeXrd`: Decimal, `proposalsMade`: UInt64, `proposalsMissed`: UInt64) {
        self.`epoch` = `epoch`
        self.`startingStakePoolXrd` = `startingStakePoolXrd`
        self.`stakePoolAddedXrd` = `stakePoolAddedXrd`
        self.`totalStakeUnitSupply` = `totalStakeUnitSupply`
        self.`validatorFeeXrd` = `validatorFeeXrd`
        self.`proposalsMade` = `proposalsMade`
        self.`proposalsMissed` = `proposalsMissed`
    }
}



public struct FfiConverterTypeValidatorEmissionAppliedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorEmissionAppliedEvent {
        return try ValidatorEmissionAppliedEvent(
            `epoch`: FfiConverterUInt64.read(from: &buf), 
            `startingStakePoolXrd`: FfiConverterTypeDecimal.read(from: &buf), 
            `stakePoolAddedXrd`: FfiConverterTypeDecimal.read(from: &buf), 
            `totalStakeUnitSupply`: FfiConverterTypeDecimal.read(from: &buf), 
            `validatorFeeXrd`: FfiConverterTypeDecimal.read(from: &buf), 
            `proposalsMade`: FfiConverterUInt64.read(from: &buf), 
            `proposalsMissed`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorEmissionAppliedEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`epoch`, into: &buf)
        FfiConverterTypeDecimal.write(value.`startingStakePoolXrd`, into: &buf)
        FfiConverterTypeDecimal.write(value.`stakePoolAddedXrd`, into: &buf)
        FfiConverterTypeDecimal.write(value.`totalStakeUnitSupply`, into: &buf)
        FfiConverterTypeDecimal.write(value.`validatorFeeXrd`, into: &buf)
        FfiConverterUInt64.write(value.`proposalsMade`, into: &buf)
        FfiConverterUInt64.write(value.`proposalsMissed`, into: &buf)
    }
}


public func FfiConverterTypeValidatorEmissionAppliedEvent_lift(_ buf: RustBuffer) throws -> ValidatorEmissionAppliedEvent {
    return try FfiConverterTypeValidatorEmissionAppliedEvent.lift(buf)
}

public func FfiConverterTypeValidatorEmissionAppliedEvent_lower(_ value: ValidatorEmissionAppliedEvent) -> RustBuffer {
    return FfiConverterTypeValidatorEmissionAppliedEvent.lower(value)
}


public struct ValidatorInfo {
    public var `key`: Secp256k1PublicKey
    public var `stake`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: Secp256k1PublicKey, `stake`: Decimal) {
        self.`key` = `key`
        self.`stake` = `stake`
    }
}



public struct FfiConverterTypeValidatorInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorInfo {
        return try ValidatorInfo(
            `key`: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), 
            `stake`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorInfo, into buf: inout [UInt8]) {
        FfiConverterTypeSecp256k1PublicKey.write(value.`key`, into: &buf)
        FfiConverterTypeDecimal.write(value.`stake`, into: &buf)
    }
}


public func FfiConverterTypeValidatorInfo_lift(_ buf: RustBuffer) throws -> ValidatorInfo {
    return try FfiConverterTypeValidatorInfo.lift(buf)
}

public func FfiConverterTypeValidatorInfo_lower(_ value: ValidatorInfo) -> RustBuffer {
    return FfiConverterTypeValidatorInfo.lower(value)
}


public struct ValidatorRewardAppliedEvent {
    public var `epoch`: UInt64
    public var `amount`: Decimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`epoch`: UInt64, `amount`: Decimal) {
        self.`epoch` = `epoch`
        self.`amount` = `amount`
    }
}



public struct FfiConverterTypeValidatorRewardAppliedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorRewardAppliedEvent {
        return try ValidatorRewardAppliedEvent(
            `epoch`: FfiConverterUInt64.read(from: &buf), 
            `amount`: FfiConverterTypeDecimal.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorRewardAppliedEvent, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`epoch`, into: &buf)
        FfiConverterTypeDecimal.write(value.`amount`, into: &buf)
    }
}


public func FfiConverterTypeValidatorRewardAppliedEvent_lift(_ buf: RustBuffer) throws -> ValidatorRewardAppliedEvent {
    return try FfiConverterTypeValidatorRewardAppliedEvent.lift(buf)
}

public func FfiConverterTypeValidatorRewardAppliedEvent_lower(_ value: ValidatorRewardAppliedEvent) -> RustBuffer {
    return FfiConverterTypeValidatorRewardAppliedEvent.lower(value)
}


public struct VaultCreationEvent {
    public var `vaultId`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`vaultId`: Address) {
        self.`vaultId` = `vaultId`
    }
}



public struct FfiConverterTypeVaultCreationEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultCreationEvent {
        return try VaultCreationEvent(
            `vaultId`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: VaultCreationEvent, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`vaultId`, into: &buf)
    }
}


public func FfiConverterTypeVaultCreationEvent_lift(_ buf: RustBuffer) throws -> VaultCreationEvent {
    return try FfiConverterTypeVaultCreationEvent.lift(buf)
}

public func FfiConverterTypeVaultCreationEvent_lower(_ value: VaultCreationEvent) -> RustBuffer {
    return FfiConverterTypeVaultCreationEvent.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountDefaultDepositRule {
    
    case `accept`
    case `reject`
    case `allowExisting`
}

public struct FfiConverterTypeAccountDefaultDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = AccountDefaultDepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDefaultDepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`accept`
        
        case 2: return .`reject`
        
        case 3: return .`allowExisting`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDefaultDepositRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`accept`:
            writeInt(&buf, Int32(1))
        
        
        case .`reject`:
            writeInt(&buf, Int32(2))
        
        
        case .`allowExisting`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAccountDefaultDepositRule_lift(_ buf: RustBuffer) throws -> AccountDefaultDepositRule {
    return try FfiConverterTypeAccountDefaultDepositRule.lift(buf)
}

public func FfiConverterTypeAccountDefaultDepositRule_lower(_ value: AccountDefaultDepositRule) -> RustBuffer {
    return FfiConverterTypeAccountDefaultDepositRule.lower(value)
}


extension AccountDefaultDepositRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountDepositEvent {
    
    case `fungible`(`resourceAddress`: Address, `amount`: Decimal)
    case `nonFungible`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountDepositEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountDepositEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDepositEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`nonFungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDepositEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungible`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`nonFungible`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountDepositEvent_lift(_ buf: RustBuffer) throws -> AccountDepositEvent {
    return try FfiConverterTypeAccountDepositEvent.lift(buf)
}

public func FfiConverterTypeAccountDepositEvent_lower(_ value: AccountDepositEvent) -> RustBuffer {
    return FfiConverterTypeAccountDepositEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountRejectedDepositEvent {
    
    case `fungible`(`resourceAddress`: Address, `amount`: Decimal)
    case `nonFungible`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountRejectedDepositEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountRejectedDepositEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRejectedDepositEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`nonFungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountRejectedDepositEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungible`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`nonFungible`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountRejectedDepositEvent_lift(_ buf: RustBuffer) throws -> AccountRejectedDepositEvent {
    return try FfiConverterTypeAccountRejectedDepositEvent.lift(buf)
}

public func FfiConverterTypeAccountRejectedDepositEvent_lower(_ value: AccountRejectedDepositEvent) -> RustBuffer {
    return FfiConverterTypeAccountRejectedDepositEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AccountWithdrawEvent {
    
    case `fungible`(`resourceAddress`: Address, `amount`: Decimal)
    case `nonFungible`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountWithdrawEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountWithdrawEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdrawEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`nonFungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountWithdrawEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungible`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`nonFungible`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAccountWithdrawEvent_lift(_ buf: RustBuffer) throws -> AccountWithdrawEvent {
    return try FfiConverterTypeAccountWithdrawEvent.lift(buf)
}

public func FfiConverterTypeAccountWithdrawEvent_lower(_ value: AccountWithdrawEvent) -> RustBuffer {
    return FfiConverterTypeAccountWithdrawEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Assertion {
    
    case `amount`(`resourceAddress`: Address, `amount`: Decimal)
    case `ids`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeAssertion: FfiConverterRustBuffer {
    typealias SwiftType = Assertion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Assertion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Assertion, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`ids`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAssertion_lift(_ buf: RustBuffer) throws -> Assertion {
    return try FfiConverterTypeAssertion.lift(buf)
}

public func FfiConverterTypeAssertion_lower(_ value: Assertion) -> RustBuffer {
    return FfiConverterTypeAssertion.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Curve {
    
    case `secp256k1`
    case `ed25519`
}

public struct FfiConverterTypeCurve: FfiConverterRustBuffer {
    typealias SwiftType = Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`secp256k1`
        
        case 2: return .`ed25519`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Curve, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`secp256k1`:
            writeInt(&buf, Int32(1))
        
        
        case .`ed25519`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCurve_lift(_ buf: RustBuffer) throws -> Curve {
    return try FfiConverterTypeCurve.lift(buf)
}

public func FfiConverterTypeCurve_lower(_ value: Curve) -> RustBuffer {
    return FfiConverterTypeCurve.lower(value)
}


extension Curve: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CurveType {
    
    case `ed25519`
    case `secp256k1`
}

public struct FfiConverterTypeCurveType: FfiConverterRustBuffer {
    typealias SwiftType = CurveType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurveType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ed25519`
        
        case 2: return .`secp256k1`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CurveType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ed25519`:
            writeInt(&buf, Int32(1))
        
        
        case .`secp256k1`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCurveType_lift(_ buf: RustBuffer) throws -> CurveType {
    return try FfiConverterTypeCurveType.lift(buf)
}

public func FfiConverterTypeCurveType_lower(_ value: CurveType) -> RustBuffer {
    return FfiConverterTypeCurveType.lower(value)
}


extension CurveType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecimalSource {
    
    case `guaranteed`(`value`: Decimal)
    case `predicted`(`instructionIndex`: UInt64, `value`: Decimal)
}

public struct FfiConverterTypeDecimalSource: FfiConverterRustBuffer {
    typealias SwiftType = DecimalSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecimalSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`guaranteed`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`predicted`(
            `instructionIndex`: try FfiConverterUInt64.read(from: &buf), 
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecimalSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`guaranteed`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`predicted`(`instructionIndex`,`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`instructionIndex`, into: &buf)
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDecimalSource_lift(_ buf: RustBuffer) throws -> DecimalSource {
    return try FfiConverterTypeDecimalSource.lift(buf)
}

public func FfiConverterTypeDecimalSource_lower(_ value: DecimalSource) -> RustBuffer {
    return FfiConverterTypeDecimalSource.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecryptorsByCurve {
    
    case `ed25519`(`dhEphemeralPublicKey`: Ed25519PublicKey, `decryptors`: [[UInt8]: [UInt8]])
    case `secp256k1`(`dhEphemeralPublicKey`: Secp256k1PublicKey, `decryptors`: [[UInt8]: [UInt8]])
}

public struct FfiConverterTypeDecryptorsByCurve: FfiConverterRustBuffer {
    typealias SwiftType = DecryptorsByCurve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptorsByCurve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ed25519`(
            `dhEphemeralPublicKey`: try FfiConverterTypeEd25519PublicKey.read(from: &buf), 
            `decryptors`: try FfiConverterDictionarySequenceUInt8SequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`secp256k1`(
            `dhEphemeralPublicKey`: try FfiConverterTypeSecp256k1PublicKey.read(from: &buf), 
            `decryptors`: try FfiConverterDictionarySequenceUInt8SequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptorsByCurve, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`ed25519`(`dhEphemeralPublicKey`,`decryptors`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(`dhEphemeralPublicKey`, into: &buf)
            FfiConverterDictionarySequenceUInt8SequenceUInt8.write(`decryptors`, into: &buf)
            
        
        case let .`secp256k1`(`dhEphemeralPublicKey`,`decryptors`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(`dhEphemeralPublicKey`, into: &buf)
            FfiConverterDictionarySequenceUInt8SequenceUInt8.write(`decryptors`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDecryptorsByCurve_lift(_ buf: RustBuffer) throws -> DecryptorsByCurve {
    return try FfiConverterTypeDecryptorsByCurve.lift(buf)
}

public func FfiConverterTypeDecryptorsByCurve_lower(_ value: DecryptorsByCurve) -> RustBuffer {
    return FfiConverterTypeDecryptorsByCurve.lower(value)
}


extension DecryptorsByCurve: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DependencyInformation {
    
    case `version`(`value`: String)
    case `tag`(`value`: String)
    case `branch`(`value`: String)
    case `rev`(`value`: String)
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`version`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`tag`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`branch`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`rev`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`version`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`tag`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`branch`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`rev`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}


extension DependencyInformation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DepositResourceEvent {
    
    case `amount`(`value`: Decimal)
    case `ids`(`value`: [NonFungibleLocalId])
}

public struct FfiConverterTypeDepositResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = DepositResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`ids`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDepositResourceEvent_lift(_ buf: RustBuffer) throws -> DepositResourceEvent {
    return try FfiConverterTypeDepositResourceEvent.lift(buf)
}

public func FfiConverterTypeDepositResourceEvent_lower(_ value: DepositResourceEvent) -> RustBuffer {
    return FfiConverterTypeDepositResourceEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Emitter {
    
    case `function`(`address`: Address, `blueprintName`: String)
    case `method`(`address`: Address, `objectModuleId`: ObjectModuleId)
}

public struct FfiConverterTypeEmitter: FfiConverterRustBuffer {
    typealias SwiftType = Emitter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emitter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`function`(
            `address`: try FfiConverterTypeAddress.read(from: &buf), 
            `blueprintName`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`method`(
            `address`: try FfiConverterTypeAddress.read(from: &buf), 
            `objectModuleId`: try FfiConverterTypeObjectModuleId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Emitter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`function`(`address`,`blueprintName`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`address`, into: &buf)
            FfiConverterString.write(`blueprintName`, into: &buf)
            
        
        case let .`method`(`address`,`objectModuleId`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`address`, into: &buf)
            FfiConverterTypeObjectModuleId.write(`objectModuleId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEmitter_lift(_ buf: RustBuffer) throws -> Emitter {
    return try FfiConverterTypeEmitter.lift(buf)
}

public func FfiConverterTypeEmitter_lower(_ value: Emitter) -> RustBuffer {
    return FfiConverterTypeEmitter.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EntityType {
    
    case `globalPackage`
    case `globalFungibleResourceManager`
    case `globalNonFungibleResourceManager`
    case `globalConsensusManager`
    case `globalValidator`
    case `globalAccessController`
    case `globalAccount`
    case `globalIdentity`
    case `globalGenericComponent`
    case `globalVirtualSecp256k1Account`
    case `globalVirtualEd25519Account`
    case `globalVirtualSecp256k1Identity`
    case `globalVirtualEd25519Identity`
    case `globalOneResourcePool`
    case `globalTwoResourcePool`
    case `globalMultiResourcePool`
    case `globalTransactionTracker`
    case `internalFungibleVault`
    case `internalNonFungibleVault`
    case `internalGenericComponent`
    case `internalKeyValueStore`
}

public struct FfiConverterTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = EntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`globalPackage`
        
        case 2: return .`globalFungibleResourceManager`
        
        case 3: return .`globalNonFungibleResourceManager`
        
        case 4: return .`globalConsensusManager`
        
        case 5: return .`globalValidator`
        
        case 6: return .`globalAccessController`
        
        case 7: return .`globalAccount`
        
        case 8: return .`globalIdentity`
        
        case 9: return .`globalGenericComponent`
        
        case 10: return .`globalVirtualSecp256k1Account`
        
        case 11: return .`globalVirtualEd25519Account`
        
        case 12: return .`globalVirtualSecp256k1Identity`
        
        case 13: return .`globalVirtualEd25519Identity`
        
        case 14: return .`globalOneResourcePool`
        
        case 15: return .`globalTwoResourcePool`
        
        case 16: return .`globalMultiResourcePool`
        
        case 17: return .`globalTransactionTracker`
        
        case 18: return .`internalFungibleVault`
        
        case 19: return .`internalNonFungibleVault`
        
        case 20: return .`internalGenericComponent`
        
        case 21: return .`internalKeyValueStore`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`globalPackage`:
            writeInt(&buf, Int32(1))
        
        
        case .`globalFungibleResourceManager`:
            writeInt(&buf, Int32(2))
        
        
        case .`globalNonFungibleResourceManager`:
            writeInt(&buf, Int32(3))
        
        
        case .`globalConsensusManager`:
            writeInt(&buf, Int32(4))
        
        
        case .`globalValidator`:
            writeInt(&buf, Int32(5))
        
        
        case .`globalAccessController`:
            writeInt(&buf, Int32(6))
        
        
        case .`globalAccount`:
            writeInt(&buf, Int32(7))
        
        
        case .`globalIdentity`:
            writeInt(&buf, Int32(8))
        
        
        case .`globalGenericComponent`:
            writeInt(&buf, Int32(9))
        
        
        case .`globalVirtualSecp256k1Account`:
            writeInt(&buf, Int32(10))
        
        
        case .`globalVirtualEd25519Account`:
            writeInt(&buf, Int32(11))
        
        
        case .`globalVirtualSecp256k1Identity`:
            writeInt(&buf, Int32(12))
        
        
        case .`globalVirtualEd25519Identity`:
            writeInt(&buf, Int32(13))
        
        
        case .`globalOneResourcePool`:
            writeInt(&buf, Int32(14))
        
        
        case .`globalTwoResourcePool`:
            writeInt(&buf, Int32(15))
        
        
        case .`globalMultiResourcePool`:
            writeInt(&buf, Int32(16))
        
        
        case .`globalTransactionTracker`:
            writeInt(&buf, Int32(17))
        
        
        case .`internalFungibleVault`:
            writeInt(&buf, Int32(18))
        
        
        case .`internalNonFungibleVault`:
            writeInt(&buf, Int32(19))
        
        
        case .`internalGenericComponent`:
            writeInt(&buf, Int32(20))
        
        
        case .`internalKeyValueStore`:
            writeInt(&buf, Int32(21))
        
        }
    }
}


public func FfiConverterTypeEntityType_lift(_ buf: RustBuffer) throws -> EntityType {
    return try FfiConverterTypeEntityType.lift(buf)
}

public func FfiConverterTypeEntityType_lower(_ value: EntityType) -> RustBuffer {
    return FfiConverterTypeEntityType.lower(value)
}


extension EntityType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Instruction {
    
    case `takeAllFromWorktop`(`resourceAddress`: Address)
    case `takeFromWorktop`(`resourceAddress`: Address, `amount`: Decimal)
    case `takeNonFungiblesFromWorktop`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
    case `returnToWorktop`(`bucketId`: ManifestBucket)
    case `assertWorktopContains`(`resourceAddress`: Address, `amount`: Decimal)
    case `assertWorktopContainsAny`(`resourceAddress`: Address)
    case `assertWorktopContainsNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
    case `popFromAuthZone`
    case `pushToAuthZone`(`proofId`: ManifestProof)
    case `createProofFromAuthZoneOfAmount`(`resourceAddress`: Address, `amount`: Decimal)
    case `createProofFromAuthZoneOfNonFungibles`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
    case `createProofFromAuthZoneOfAll`(`resourceAddress`: Address)
    case `dropAllProofs`
    case `dropNamedProofs`
    case `dropAuthZoneProofs`
    case `dropAuthZoneRegularProofs`
    case `dropAuthZoneSignatureProofs`
    case `createProofFromBucketOfAmount`(`bucketId`: ManifestBucket, `amount`: Decimal)
    case `createProofFromBucketOfNonFungibles`(`bucketId`: ManifestBucket, `ids`: [NonFungibleLocalId])
    case `createProofFromBucketOfAll`(`bucketId`: ManifestBucket)
    case `burnResource`(`bucketId`: ManifestBucket)
    case `cloneProof`(`proofId`: ManifestProof)
    case `dropProof`(`proofId`: ManifestProof)
    case `callFunction`(`packageAddress`: ManifestAddress, `blueprintName`: String, `functionName`: String, `args`: ManifestValue)
    case `callMethod`(`address`: ManifestAddress, `methodName`: String, `args`: ManifestValue)
    case `callRoyaltyMethod`(`address`: ManifestAddress, `methodName`: String, `args`: ManifestValue)
    case `callMetadataMethod`(`address`: ManifestAddress, `methodName`: String, `args`: ManifestValue)
    case `callRoleAssignmentMethod`(`address`: ManifestAddress, `methodName`: String, `args`: ManifestValue)
    case `callDirectVaultMethod`(`address`: Address, `methodName`: String, `args`: ManifestValue)
    case `allocateGlobalAddress`(`packageAddress`: Address, `blueprintName`: String)
}

public struct FfiConverterTypeInstruction: FfiConverterRustBuffer {
    typealias SwiftType = Instruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`takeAllFromWorktop`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 2: return .`takeFromWorktop`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 3: return .`takeNonFungiblesFromWorktop`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 4: return .`returnToWorktop`(
            `bucketId`: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 5: return .`assertWorktopContains`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 6: return .`assertWorktopContainsAny`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 7: return .`assertWorktopContainsNonFungibles`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 8: return .`popFromAuthZone`
        
        case 9: return .`pushToAuthZone`(
            `proofId`: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 10: return .`createProofFromAuthZoneOfAmount`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 11: return .`createProofFromAuthZoneOfNonFungibles`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 12: return .`createProofFromAuthZoneOfAll`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 13: return .`dropAllProofs`
        
        case 14: return .`dropNamedProofs`
        
        case 15: return .`dropAuthZoneProofs`
        
        case 16: return .`dropAuthZoneRegularProofs`
        
        case 17: return .`dropAuthZoneSignatureProofs`
        
        case 18: return .`createProofFromBucketOfAmount`(
            `bucketId`: try FfiConverterTypeManifestBucket.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 19: return .`createProofFromBucketOfNonFungibles`(
            `bucketId`: try FfiConverterTypeManifestBucket.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 20: return .`createProofFromBucketOfAll`(
            `bucketId`: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 21: return .`burnResource`(
            `bucketId`: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 22: return .`cloneProof`(
            `proofId`: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 23: return .`dropProof`(
            `proofId`: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 24: return .`callFunction`(
            `packageAddress`: try FfiConverterTypeManifestAddress.read(from: &buf), 
            `blueprintName`: try FfiConverterString.read(from: &buf), 
            `functionName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 25: return .`callMethod`(
            `address`: try FfiConverterTypeManifestAddress.read(from: &buf), 
            `methodName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 26: return .`callRoyaltyMethod`(
            `address`: try FfiConverterTypeManifestAddress.read(from: &buf), 
            `methodName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 27: return .`callMetadataMethod`(
            `address`: try FfiConverterTypeManifestAddress.read(from: &buf), 
            `methodName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 28: return .`callRoleAssignmentMethod`(
            `address`: try FfiConverterTypeManifestAddress.read(from: &buf), 
            `methodName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 29: return .`callDirectVaultMethod`(
            `address`: try FfiConverterTypeAddress.read(from: &buf), 
            `methodName`: try FfiConverterString.read(from: &buf), 
            `args`: try FfiConverterTypeManifestValue.read(from: &buf)
        )
        
        case 30: return .`allocateGlobalAddress`(
            `packageAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `blueprintName`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Instruction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`takeAllFromWorktop`(`resourceAddress`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            
        
        case let .`takeFromWorktop`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`takeNonFungiblesFromWorktop`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        
        case let .`returnToWorktop`(`bucketId`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeManifestBucket.write(`bucketId`, into: &buf)
            
        
        case let .`assertWorktopContains`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`assertWorktopContainsAny`(`resourceAddress`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            
        
        case let .`assertWorktopContainsNonFungibles`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        
        case .`popFromAuthZone`:
            writeInt(&buf, Int32(8))
        
        
        case let .`pushToAuthZone`(`proofId`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeManifestProof.write(`proofId`, into: &buf)
            
        
        case let .`createProofFromAuthZoneOfAmount`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(10))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`createProofFromAuthZoneOfNonFungibles`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(11))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        
        case let .`createProofFromAuthZoneOfAll`(`resourceAddress`):
            writeInt(&buf, Int32(12))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            
        
        case .`dropAllProofs`:
            writeInt(&buf, Int32(13))
        
        
        case .`dropNamedProofs`:
            writeInt(&buf, Int32(14))
        
        
        case .`dropAuthZoneProofs`:
            writeInt(&buf, Int32(15))
        
        
        case .`dropAuthZoneRegularProofs`:
            writeInt(&buf, Int32(16))
        
        
        case .`dropAuthZoneSignatureProofs`:
            writeInt(&buf, Int32(17))
        
        
        case let .`createProofFromBucketOfAmount`(`bucketId`,`amount`):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(`bucketId`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`createProofFromBucketOfNonFungibles`(`bucketId`,`ids`):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestBucket.write(`bucketId`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        
        case let .`createProofFromBucketOfAll`(`bucketId`):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestBucket.write(`bucketId`, into: &buf)
            
        
        case let .`burnResource`(`bucketId`):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBucket.write(`bucketId`, into: &buf)
            
        
        case let .`cloneProof`(`proofId`):
            writeInt(&buf, Int32(22))
            FfiConverterTypeManifestProof.write(`proofId`, into: &buf)
            
        
        case let .`dropProof`(`proofId`):
            writeInt(&buf, Int32(23))
            FfiConverterTypeManifestProof.write(`proofId`, into: &buf)
            
        
        case let .`callFunction`(`packageAddress`,`blueprintName`,`functionName`,`args`):
            writeInt(&buf, Int32(24))
            FfiConverterTypeManifestAddress.write(`packageAddress`, into: &buf)
            FfiConverterString.write(`blueprintName`, into: &buf)
            FfiConverterString.write(`functionName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`callMethod`(`address`,`methodName`,`args`):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddress.write(`address`, into: &buf)
            FfiConverterString.write(`methodName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`callRoyaltyMethod`(`address`,`methodName`,`args`):
            writeInt(&buf, Int32(26))
            FfiConverterTypeManifestAddress.write(`address`, into: &buf)
            FfiConverterString.write(`methodName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`callMetadataMethod`(`address`,`methodName`,`args`):
            writeInt(&buf, Int32(27))
            FfiConverterTypeManifestAddress.write(`address`, into: &buf)
            FfiConverterString.write(`methodName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`callRoleAssignmentMethod`(`address`,`methodName`,`args`):
            writeInt(&buf, Int32(28))
            FfiConverterTypeManifestAddress.write(`address`, into: &buf)
            FfiConverterString.write(`methodName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`callDirectVaultMethod`(`address`,`methodName`,`args`):
            writeInt(&buf, Int32(29))
            FfiConverterTypeAddress.write(`address`, into: &buf)
            FfiConverterString.write(`methodName`, into: &buf)
            FfiConverterTypeManifestValue.write(`args`, into: &buf)
            
        
        case let .`allocateGlobalAddress`(`packageAddress`,`blueprintName`):
            writeInt(&buf, Int32(30))
            FfiConverterTypeAddress.write(`packageAddress`, into: &buf)
            FfiConverterString.write(`blueprintName`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInstruction_lift(_ buf: RustBuffer) throws -> Instruction {
    return try FfiConverterTypeInstruction.lift(buf)
}

public func FfiConverterTypeInstruction_lower(_ value: Instruction) -> RustBuffer {
    return FfiConverterTypeInstruction.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTypeId {
    
    case `wellKnown`(`value`: UInt8)
    case `schemaLocalIndex`(`value`: UInt64)
}

public struct FfiConverterTypeLocalTypeId: FfiConverterRustBuffer {
    typealias SwiftType = LocalTypeId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalTypeId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`wellKnown`(
            `value`: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 2: return .`schemaLocalIndex`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LocalTypeId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`wellKnown`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt8.write(`value`, into: &buf)
            
        
        case let .`schemaLocalIndex`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLocalTypeId_lift(_ buf: RustBuffer) throws -> LocalTypeId {
    return try FfiConverterTypeLocalTypeId.lift(buf)
}

public func FfiConverterTypeLocalTypeId_lower(_ value: LocalTypeId) -> RustBuffer {
    return FfiConverterTypeLocalTypeId.lower(value)
}


extension LocalTypeId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestAddress {
    
    case `named`(`value`: UInt32)
    case `static`(`value`: Address)
}

public struct FfiConverterTypeManifestAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`named`(
            `value`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .`static`(
            `value`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestAddress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`named`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(`value`, into: &buf)
            
        
        case let .`static`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestAddress_lift(_ buf: RustBuffer) throws -> ManifestAddress {
    return try FfiConverterTypeManifestAddress.lift(buf)
}

public func FfiConverterTypeManifestAddress_lower(_ value: ManifestAddress) -> RustBuffer {
    return FfiConverterTypeManifestAddress.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderAddress {
    
    case `named`(`value`: ManifestBuilderNamedAddress)
    case `static`(`value`: Address)
}

public struct FfiConverterTypeManifestBuilderAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`named`(
            `value`: try FfiConverterTypeManifestBuilderNamedAddress.read(from: &buf)
        )
        
        case 2: return .`static`(
            `value`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderAddress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`named`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeManifestBuilderNamedAddress.write(`value`, into: &buf)
            
        
        case let .`static`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestBuilderAddress_lift(_ buf: RustBuffer) throws -> ManifestBuilderAddress {
    return try FfiConverterTypeManifestBuilderAddress.lift(buf)
}

public func FfiConverterTypeManifestBuilderAddress_lower(_ value: ManifestBuilderAddress) -> RustBuffer {
    return FfiConverterTypeManifestBuilderAddress.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderValue {
    
    case `boolValue`(`value`: Bool)
    case `i8Value`(`value`: Int8)
    case `i16Value`(`value`: Int16)
    case `i32Value`(`value`: Int32)
    case `i64Value`(`value`: Int64)
    case `i128Value`(`value`: String)
    case `u8Value`(`value`: UInt8)
    case `u16Value`(`value`: UInt16)
    case `u32Value`(`value`: UInt32)
    case `u64Value`(`value`: UInt64)
    case `u128Value`(`value`: String)
    case `stringValue`(`value`: String)
    case `enumValue`(`discriminator`: UInt8, `fields`: [ManifestBuilderValue])
    case `arrayValue`(`elementValueKind`: ManifestBuilderValueKind, `elements`: [ManifestBuilderValue])
    case `tupleValue`(`fields`: [ManifestBuilderValue])
    case `mapValue`(`keyValueKind`: ManifestBuilderValueKind, `valueValueKind`: ManifestBuilderValueKind, `entries`: [ManifestBuilderMapEntry])
    case `addressValue`(`value`: ManifestBuilderAddress)
    case `bucketValue`(`value`: ManifestBuilderBucket)
    case `proofValue`(`value`: ManifestBuilderProof)
    case `expressionValue`(`value`: ManifestExpression)
    case `blobValue`(`value`: ManifestBlobRef)
    case `decimalValue`(`value`: Decimal)
    case `preciseDecimalValue`(`value`: PreciseDecimal)
    case `nonFungibleLocalIdValue`(`value`: NonFungibleLocalId)
    case `addressReservationValue`(`value`: ManifestBuilderAddressReservation)
}

public struct FfiConverterTypeManifestBuilderValue: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`boolValue`(
            `value`: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .`i8Value`(
            `value`: try FfiConverterInt8.read(from: &buf)
        )
        
        case 3: return .`i16Value`(
            `value`: try FfiConverterInt16.read(from: &buf)
        )
        
        case 4: return .`i32Value`(
            `value`: try FfiConverterInt32.read(from: &buf)
        )
        
        case 5: return .`i64Value`(
            `value`: try FfiConverterInt64.read(from: &buf)
        )
        
        case 6: return .`i128Value`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .`u8Value`(
            `value`: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 8: return .`u16Value`(
            `value`: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 9: return .`u32Value`(
            `value`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .`u64Value`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 11: return .`u128Value`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .`stringValue`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .`enumValue`(
            `discriminator`: try FfiConverterUInt8.read(from: &buf), 
            `fields`: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 14: return .`arrayValue`(
            `elementValueKind`: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            `elements`: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 15: return .`tupleValue`(
            `fields`: try FfiConverterSequenceTypeManifestBuilderValue.read(from: &buf)
        )
        
        case 16: return .`mapValue`(
            `keyValueKind`: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            `valueValueKind`: try FfiConverterTypeManifestBuilderValueKind.read(from: &buf), 
            `entries`: try FfiConverterSequenceTypeManifestBuilderMapEntry.read(from: &buf)
        )
        
        case 17: return .`addressValue`(
            `value`: try FfiConverterTypeManifestBuilderAddress.read(from: &buf)
        )
        
        case 18: return .`bucketValue`(
            `value`: try FfiConverterTypeManifestBuilderBucket.read(from: &buf)
        )
        
        case 19: return .`proofValue`(
            `value`: try FfiConverterTypeManifestBuilderProof.read(from: &buf)
        )
        
        case 20: return .`expressionValue`(
            `value`: try FfiConverterTypeManifestExpression.read(from: &buf)
        )
        
        case 21: return .`blobValue`(
            `value`: try FfiConverterTypeManifestBlobRef.read(from: &buf)
        )
        
        case 22: return .`decimalValue`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 23: return .`preciseDecimalValue`(
            `value`: try FfiConverterTypePreciseDecimal.read(from: &buf)
        )
        
        case 24: return .`nonFungibleLocalIdValue`(
            `value`: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 25: return .`addressReservationValue`(
            `value`: try FfiConverterTypeManifestBuilderAddressReservation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`boolValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(`value`, into: &buf)
            
        
        case let .`i8Value`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(`value`, into: &buf)
            
        
        case let .`i16Value`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(`value`, into: &buf)
            
        
        case let .`i32Value`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(`value`, into: &buf)
            
        
        case let .`i64Value`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(`value`, into: &buf)
            
        
        case let .`i128Value`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`u8Value`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(`value`, into: &buf)
            
        
        case let .`u16Value`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(`value`, into: &buf)
            
        
        case let .`u32Value`(`value`):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(`value`, into: &buf)
            
        
        case let .`u64Value`(`value`):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        
        case let .`u128Value`(`value`):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`stringValue`(`value`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`enumValue`(`discriminator`,`fields`):
            writeInt(&buf, Int32(13))
            FfiConverterUInt8.write(`discriminator`, into: &buf)
            FfiConverterSequenceTypeManifestBuilderValue.write(`fields`, into: &buf)
            
        
        case let .`arrayValue`(`elementValueKind`,`elements`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeManifestBuilderValueKind.write(`elementValueKind`, into: &buf)
            FfiConverterSequenceTypeManifestBuilderValue.write(`elements`, into: &buf)
            
        
        case let .`tupleValue`(`fields`):
            writeInt(&buf, Int32(15))
            FfiConverterSequenceTypeManifestBuilderValue.write(`fields`, into: &buf)
            
        
        case let .`mapValue`(`keyValueKind`,`valueValueKind`,`entries`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestBuilderValueKind.write(`keyValueKind`, into: &buf)
            FfiConverterTypeManifestBuilderValueKind.write(`valueValueKind`, into: &buf)
            FfiConverterSequenceTypeManifestBuilderMapEntry.write(`entries`, into: &buf)
            
        
        case let .`addressValue`(`value`):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestBuilderAddress.write(`value`, into: &buf)
            
        
        case let .`bucketValue`(`value`):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBuilderBucket.write(`value`, into: &buf)
            
        
        case let .`proofValue`(`value`):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestBuilderProof.write(`value`, into: &buf)
            
        
        case let .`expressionValue`(`value`):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestExpression.write(`value`, into: &buf)
            
        
        case let .`blobValue`(`value`):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBlobRef.write(`value`, into: &buf)
            
        
        case let .`decimalValue`(`value`):
            writeInt(&buf, Int32(22))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`preciseDecimalValue`(`value`):
            writeInt(&buf, Int32(23))
            FfiConverterTypePreciseDecimal.write(`value`, into: &buf)
            
        
        case let .`nonFungibleLocalIdValue`(`value`):
            writeInt(&buf, Int32(24))
            FfiConverterTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        
        case let .`addressReservationValue`(`value`):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestBuilderAddressReservation.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestBuilderValue_lift(_ buf: RustBuffer) throws -> ManifestBuilderValue {
    return try FfiConverterTypeManifestBuilderValue.lift(buf)
}

public func FfiConverterTypeManifestBuilderValue_lower(_ value: ManifestBuilderValue) -> RustBuffer {
    return FfiConverterTypeManifestBuilderValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestBuilderValueKind {
    
    case `boolValue`
    case `i8Value`
    case `i16Value`
    case `i32Value`
    case `i64Value`
    case `i128Value`
    case `u8Value`
    case `u16Value`
    case `u32Value`
    case `u64Value`
    case `u128Value`
    case `stringValue`
    case `enumValue`
    case `arrayValue`
    case `tupleValue`
    case `mapValue`
    case `addressValue`
    case `bucketValue`
    case `proofValue`
    case `expressionValue`
    case `blobValue`
    case `decimalValue`
    case `preciseDecimalValue`
    case `nonFungibleLocalIdValue`
    case `addressReservationValue`
}

public struct FfiConverterTypeManifestBuilderValueKind: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderValueKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestBuilderValueKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`boolValue`
        
        case 2: return .`i8Value`
        
        case 3: return .`i16Value`
        
        case 4: return .`i32Value`
        
        case 5: return .`i64Value`
        
        case 6: return .`i128Value`
        
        case 7: return .`u8Value`
        
        case 8: return .`u16Value`
        
        case 9: return .`u32Value`
        
        case 10: return .`u64Value`
        
        case 11: return .`u128Value`
        
        case 12: return .`stringValue`
        
        case 13: return .`enumValue`
        
        case 14: return .`arrayValue`
        
        case 15: return .`tupleValue`
        
        case 16: return .`mapValue`
        
        case 17: return .`addressValue`
        
        case 18: return .`bucketValue`
        
        case 19: return .`proofValue`
        
        case 20: return .`expressionValue`
        
        case 21: return .`blobValue`
        
        case 22: return .`decimalValue`
        
        case 23: return .`preciseDecimalValue`
        
        case 24: return .`nonFungibleLocalIdValue`
        
        case 25: return .`addressReservationValue`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestBuilderValueKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`boolValue`:
            writeInt(&buf, Int32(1))
        
        
        case .`i8Value`:
            writeInt(&buf, Int32(2))
        
        
        case .`i16Value`:
            writeInt(&buf, Int32(3))
        
        
        case .`i32Value`:
            writeInt(&buf, Int32(4))
        
        
        case .`i64Value`:
            writeInt(&buf, Int32(5))
        
        
        case .`i128Value`:
            writeInt(&buf, Int32(6))
        
        
        case .`u8Value`:
            writeInt(&buf, Int32(7))
        
        
        case .`u16Value`:
            writeInt(&buf, Int32(8))
        
        
        case .`u32Value`:
            writeInt(&buf, Int32(9))
        
        
        case .`u64Value`:
            writeInt(&buf, Int32(10))
        
        
        case .`u128Value`:
            writeInt(&buf, Int32(11))
        
        
        case .`stringValue`:
            writeInt(&buf, Int32(12))
        
        
        case .`enumValue`:
            writeInt(&buf, Int32(13))
        
        
        case .`arrayValue`:
            writeInt(&buf, Int32(14))
        
        
        case .`tupleValue`:
            writeInt(&buf, Int32(15))
        
        
        case .`mapValue`:
            writeInt(&buf, Int32(16))
        
        
        case .`addressValue`:
            writeInt(&buf, Int32(17))
        
        
        case .`bucketValue`:
            writeInt(&buf, Int32(18))
        
        
        case .`proofValue`:
            writeInt(&buf, Int32(19))
        
        
        case .`expressionValue`:
            writeInt(&buf, Int32(20))
        
        
        case .`blobValue`:
            writeInt(&buf, Int32(21))
        
        
        case .`decimalValue`:
            writeInt(&buf, Int32(22))
        
        
        case .`preciseDecimalValue`:
            writeInt(&buf, Int32(23))
        
        
        case .`nonFungibleLocalIdValue`:
            writeInt(&buf, Int32(24))
        
        
        case .`addressReservationValue`:
            writeInt(&buf, Int32(25))
        
        }
    }
}


public func FfiConverterTypeManifestBuilderValueKind_lift(_ buf: RustBuffer) throws -> ManifestBuilderValueKind {
    return try FfiConverterTypeManifestBuilderValueKind.lift(buf)
}

public func FfiConverterTypeManifestBuilderValueKind_lower(_ value: ManifestBuilderValueKind) -> RustBuffer {
    return FfiConverterTypeManifestBuilderValueKind.lower(value)
}


extension ManifestBuilderValueKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestExpression {
    
    case `entireWorktop`
    case `entireAuthZone`
}

public struct FfiConverterTypeManifestExpression: FfiConverterRustBuffer {
    typealias SwiftType = ManifestExpression

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestExpression {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`entireWorktop`
        
        case 2: return .`entireAuthZone`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestExpression, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`entireWorktop`:
            writeInt(&buf, Int32(1))
        
        
        case .`entireAuthZone`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeManifestExpression_lift(_ buf: RustBuffer) throws -> ManifestExpression {
    return try FfiConverterTypeManifestExpression.lift(buf)
}

public func FfiConverterTypeManifestExpression_lower(_ value: ManifestExpression) -> RustBuffer {
    return FfiConverterTypeManifestExpression.lower(value)
}


extension ManifestExpression: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestSborStringRepresentation {
    
    case `manifestString`
    case `json`(`value`: SerializationMode)
}

public struct FfiConverterTypeManifestSborStringRepresentation: FfiConverterRustBuffer {
    typealias SwiftType = ManifestSborStringRepresentation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSborStringRepresentation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`manifestString`
        
        case 2: return .`json`(
            `value`: try FfiConverterTypeSerializationMode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestSborStringRepresentation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`manifestString`:
            writeInt(&buf, Int32(1))
        
        
        case let .`json`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSerializationMode.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestSborStringRepresentation_lift(_ buf: RustBuffer) throws -> ManifestSborStringRepresentation {
    return try FfiConverterTypeManifestSborStringRepresentation.lift(buf)
}

public func FfiConverterTypeManifestSborStringRepresentation_lower(_ value: ManifestSborStringRepresentation) -> RustBuffer {
    return FfiConverterTypeManifestSborStringRepresentation.lower(value)
}


extension ManifestSborStringRepresentation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValue {
    
    case `boolValue`(`value`: Bool)
    case `i8Value`(`value`: Int8)
    case `i16Value`(`value`: Int16)
    case `i32Value`(`value`: Int32)
    case `i64Value`(`value`: Int64)
    case `i128Value`(`value`: String)
    case `u8Value`(`value`: UInt8)
    case `u16Value`(`value`: UInt16)
    case `u32Value`(`value`: UInt32)
    case `u64Value`(`value`: UInt64)
    case `u128Value`(`value`: String)
    case `stringValue`(`value`: String)
    case `enumValue`(`discriminator`: UInt8, `fields`: [ManifestValue])
    case `arrayValue`(`elementValueKind`: ManifestValueKind, `elements`: [ManifestValue])
    case `tupleValue`(`fields`: [ManifestValue])
    case `mapValue`(`keyValueKind`: ManifestValueKind, `valueValueKind`: ManifestValueKind, `entries`: [MapEntry])
    case `addressValue`(`value`: ManifestAddress)
    case `bucketValue`(`value`: ManifestBucket)
    case `proofValue`(`value`: ManifestProof)
    case `expressionValue`(`value`: ManifestExpression)
    case `blobValue`(`value`: ManifestBlobRef)
    case `decimalValue`(`value`: Decimal)
    case `preciseDecimalValue`(`value`: PreciseDecimal)
    case `nonFungibleLocalIdValue`(`value`: NonFungibleLocalId)
    case `addressReservationValue`(`value`: ManifestAddressReservation)
}

public struct FfiConverterTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`boolValue`(
            `value`: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .`i8Value`(
            `value`: try FfiConverterInt8.read(from: &buf)
        )
        
        case 3: return .`i16Value`(
            `value`: try FfiConverterInt16.read(from: &buf)
        )
        
        case 4: return .`i32Value`(
            `value`: try FfiConverterInt32.read(from: &buf)
        )
        
        case 5: return .`i64Value`(
            `value`: try FfiConverterInt64.read(from: &buf)
        )
        
        case 6: return .`i128Value`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .`u8Value`(
            `value`: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 8: return .`u16Value`(
            `value`: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 9: return .`u32Value`(
            `value`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .`u64Value`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 11: return .`u128Value`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .`stringValue`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .`enumValue`(
            `discriminator`: try FfiConverterUInt8.read(from: &buf), 
            `fields`: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 14: return .`arrayValue`(
            `elementValueKind`: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            `elements`: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 15: return .`tupleValue`(
            `fields`: try FfiConverterSequenceTypeManifestValue.read(from: &buf)
        )
        
        case 16: return .`mapValue`(
            `keyValueKind`: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            `valueValueKind`: try FfiConverterTypeManifestValueKind.read(from: &buf), 
            `entries`: try FfiConverterSequenceTypeMapEntry.read(from: &buf)
        )
        
        case 17: return .`addressValue`(
            `value`: try FfiConverterTypeManifestAddress.read(from: &buf)
        )
        
        case 18: return .`bucketValue`(
            `value`: try FfiConverterTypeManifestBucket.read(from: &buf)
        )
        
        case 19: return .`proofValue`(
            `value`: try FfiConverterTypeManifestProof.read(from: &buf)
        )
        
        case 20: return .`expressionValue`(
            `value`: try FfiConverterTypeManifestExpression.read(from: &buf)
        )
        
        case 21: return .`blobValue`(
            `value`: try FfiConverterTypeManifestBlobRef.read(from: &buf)
        )
        
        case 22: return .`decimalValue`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 23: return .`preciseDecimalValue`(
            `value`: try FfiConverterTypePreciseDecimal.read(from: &buf)
        )
        
        case 24: return .`nonFungibleLocalIdValue`(
            `value`: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 25: return .`addressReservationValue`(
            `value`: try FfiConverterTypeManifestAddressReservation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`boolValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(`value`, into: &buf)
            
        
        case let .`i8Value`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(`value`, into: &buf)
            
        
        case let .`i16Value`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(`value`, into: &buf)
            
        
        case let .`i32Value`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(`value`, into: &buf)
            
        
        case let .`i64Value`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(`value`, into: &buf)
            
        
        case let .`i128Value`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`u8Value`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(`value`, into: &buf)
            
        
        case let .`u16Value`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(`value`, into: &buf)
            
        
        case let .`u32Value`(`value`):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(`value`, into: &buf)
            
        
        case let .`u64Value`(`value`):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        
        case let .`u128Value`(`value`):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`stringValue`(`value`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`enumValue`(`discriminator`,`fields`):
            writeInt(&buf, Int32(13))
            FfiConverterUInt8.write(`discriminator`, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(`fields`, into: &buf)
            
        
        case let .`arrayValue`(`elementValueKind`,`elements`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeManifestValueKind.write(`elementValueKind`, into: &buf)
            FfiConverterSequenceTypeManifestValue.write(`elements`, into: &buf)
            
        
        case let .`tupleValue`(`fields`):
            writeInt(&buf, Int32(15))
            FfiConverterSequenceTypeManifestValue.write(`fields`, into: &buf)
            
        
        case let .`mapValue`(`keyValueKind`,`valueValueKind`,`entries`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeManifestValueKind.write(`keyValueKind`, into: &buf)
            FfiConverterTypeManifestValueKind.write(`valueValueKind`, into: &buf)
            FfiConverterSequenceTypeMapEntry.write(`entries`, into: &buf)
            
        
        case let .`addressValue`(`value`):
            writeInt(&buf, Int32(17))
            FfiConverterTypeManifestAddress.write(`value`, into: &buf)
            
        
        case let .`bucketValue`(`value`):
            writeInt(&buf, Int32(18))
            FfiConverterTypeManifestBucket.write(`value`, into: &buf)
            
        
        case let .`proofValue`(`value`):
            writeInt(&buf, Int32(19))
            FfiConverterTypeManifestProof.write(`value`, into: &buf)
            
        
        case let .`expressionValue`(`value`):
            writeInt(&buf, Int32(20))
            FfiConverterTypeManifestExpression.write(`value`, into: &buf)
            
        
        case let .`blobValue`(`value`):
            writeInt(&buf, Int32(21))
            FfiConverterTypeManifestBlobRef.write(`value`, into: &buf)
            
        
        case let .`decimalValue`(`value`):
            writeInt(&buf, Int32(22))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`preciseDecimalValue`(`value`):
            writeInt(&buf, Int32(23))
            FfiConverterTypePreciseDecimal.write(`value`, into: &buf)
            
        
        case let .`nonFungibleLocalIdValue`(`value`):
            writeInt(&buf, Int32(24))
            FfiConverterTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        
        case let .`addressReservationValue`(`value`):
            writeInt(&buf, Int32(25))
            FfiConverterTypeManifestAddressReservation.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeManifestValue_lift(_ buf: RustBuffer) throws -> ManifestValue {
    return try FfiConverterTypeManifestValue.lift(buf)
}

public func FfiConverterTypeManifestValue_lower(_ value: ManifestValue) -> RustBuffer {
    return FfiConverterTypeManifestValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ManifestValueKind {
    
    case `boolValue`
    case `i8Value`
    case `i16Value`
    case `i32Value`
    case `i64Value`
    case `i128Value`
    case `u8Value`
    case `u16Value`
    case `u32Value`
    case `u64Value`
    case `u128Value`
    case `stringValue`
    case `enumValue`
    case `arrayValue`
    case `tupleValue`
    case `mapValue`
    case `addressValue`
    case `bucketValue`
    case `proofValue`
    case `expressionValue`
    case `blobValue`
    case `decimalValue`
    case `preciseDecimalValue`
    case `nonFungibleLocalIdValue`
    case `addressReservationValue`
}

public struct FfiConverterTypeManifestValueKind: FfiConverterRustBuffer {
    typealias SwiftType = ManifestValueKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestValueKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`boolValue`
        
        case 2: return .`i8Value`
        
        case 3: return .`i16Value`
        
        case 4: return .`i32Value`
        
        case 5: return .`i64Value`
        
        case 6: return .`i128Value`
        
        case 7: return .`u8Value`
        
        case 8: return .`u16Value`
        
        case 9: return .`u32Value`
        
        case 10: return .`u64Value`
        
        case 11: return .`u128Value`
        
        case 12: return .`stringValue`
        
        case 13: return .`enumValue`
        
        case 14: return .`arrayValue`
        
        case 15: return .`tupleValue`
        
        case 16: return .`mapValue`
        
        case 17: return .`addressValue`
        
        case 18: return .`bucketValue`
        
        case 19: return .`proofValue`
        
        case 20: return .`expressionValue`
        
        case 21: return .`blobValue`
        
        case 22: return .`decimalValue`
        
        case 23: return .`preciseDecimalValue`
        
        case 24: return .`nonFungibleLocalIdValue`
        
        case 25: return .`addressReservationValue`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestValueKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`boolValue`:
            writeInt(&buf, Int32(1))
        
        
        case .`i8Value`:
            writeInt(&buf, Int32(2))
        
        
        case .`i16Value`:
            writeInt(&buf, Int32(3))
        
        
        case .`i32Value`:
            writeInt(&buf, Int32(4))
        
        
        case .`i64Value`:
            writeInt(&buf, Int32(5))
        
        
        case .`i128Value`:
            writeInt(&buf, Int32(6))
        
        
        case .`u8Value`:
            writeInt(&buf, Int32(7))
        
        
        case .`u16Value`:
            writeInt(&buf, Int32(8))
        
        
        case .`u32Value`:
            writeInt(&buf, Int32(9))
        
        
        case .`u64Value`:
            writeInt(&buf, Int32(10))
        
        
        case .`u128Value`:
            writeInt(&buf, Int32(11))
        
        
        case .`stringValue`:
            writeInt(&buf, Int32(12))
        
        
        case .`enumValue`:
            writeInt(&buf, Int32(13))
        
        
        case .`arrayValue`:
            writeInt(&buf, Int32(14))
        
        
        case .`tupleValue`:
            writeInt(&buf, Int32(15))
        
        
        case .`mapValue`:
            writeInt(&buf, Int32(16))
        
        
        case .`addressValue`:
            writeInt(&buf, Int32(17))
        
        
        case .`bucketValue`:
            writeInt(&buf, Int32(18))
        
        
        case .`proofValue`:
            writeInt(&buf, Int32(19))
        
        
        case .`expressionValue`:
            writeInt(&buf, Int32(20))
        
        
        case .`blobValue`:
            writeInt(&buf, Int32(21))
        
        
        case .`decimalValue`:
            writeInt(&buf, Int32(22))
        
        
        case .`preciseDecimalValue`:
            writeInt(&buf, Int32(23))
        
        
        case .`nonFungibleLocalIdValue`:
            writeInt(&buf, Int32(24))
        
        
        case .`addressReservationValue`:
            writeInt(&buf, Int32(25))
        
        }
    }
}


public func FfiConverterTypeManifestValueKind_lift(_ buf: RustBuffer) throws -> ManifestValueKind {
    return try FfiConverterTypeManifestValueKind.lift(buf)
}

public func FfiConverterTypeManifestValueKind_lower(_ value: ManifestValueKind) -> RustBuffer {
    return FfiConverterTypeManifestValueKind.lower(value)
}


extension ManifestValueKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Message {
    
    case `none`
    case `plainText`(`value`: PlainTextMessage)
    case `encrypted`(`value`: EncryptedMessage)
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`plainText`(
            `value`: try FfiConverterTypePlainTextMessage.read(from: &buf)
        )
        
        case 3: return .`encrypted`(
            `value`: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case let .`plainText`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypePlainTextMessage.write(`value`, into: &buf)
            
        
        case let .`encrypted`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEncryptedMessage.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


extension Message: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageContent {
    
    case `str`(`value`: String)
    case `bytes`(`value`: [UInt8])
}

public struct FfiConverterTypeMessageContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`str`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`bytes`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`str`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`bytes`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageContent_lift(_ buf: RustBuffer) throws -> MessageContent {
    return try FfiConverterTypeMessageContent.lift(buf)
}

public func FfiConverterTypeMessageContent_lower(_ value: MessageContent) -> RustBuffer {
    return FfiConverterTypeMessageContent.lower(value)
}


extension MessageContent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MetadataValue {
    
    case `stringValue`(`value`: String)
    case `boolValue`(`value`: Bool)
    case `u8Value`(`value`: UInt8)
    case `u32Value`(`value`: UInt32)
    case `u64Value`(`value`: UInt64)
    case `i32Value`(`value`: Int32)
    case `i64Value`(`value`: Int64)
    case `decimalValue`(`value`: Decimal)
    case `globalAddressValue`(`value`: Address)
    case `publicKeyValue`(`value`: PublicKey)
    case `nonFungibleGlobalIdValue`(`value`: NonFungibleGlobalId)
    case `nonFungibleLocalIdValue`(`value`: NonFungibleLocalId)
    case `instantValue`(`value`: Int64)
    case `urlValue`(`value`: String)
    case `originValue`(`value`: String)
    case `publicKeyHashValue`(`value`: PublicKeyHash)
    case `stringArrayValue`(`value`: [String])
    case `boolArrayValue`(`value`: [Bool])
    case `u8ArrayValue`(`value`: [UInt8])
    case `u32ArrayValue`(`value`: [UInt32])
    case `u64ArrayValue`(`value`: [UInt64])
    case `i32ArrayValue`(`value`: [Int32])
    case `i64ArrayValue`(`value`: [Int64])
    case `decimalArrayValue`(`value`: [Decimal])
    case `globalAddressArrayValue`(`value`: [Address])
    case `publicKeyArrayValue`(`value`: [PublicKey])
    case `nonFungibleGlobalIdArrayValue`(`value`: [NonFungibleGlobalId])
    case `nonFungibleLocalIdArrayValue`(`value`: [NonFungibleLocalId])
    case `instantArrayValue`(`value`: [Int64])
    case `urlArrayValue`(`value`: [String])
    case `originArrayValue`(`value`: [String])
    case `publicKeyHashArrayValue`(`value`: [PublicKeyHash])
}

public struct FfiConverterTypeMetadataValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`stringValue`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`boolValue`(
            `value`: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .`u8Value`(
            `value`: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 4: return .`u32Value`(
            `value`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .`u64Value`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 6: return .`i32Value`(
            `value`: try FfiConverterInt32.read(from: &buf)
        )
        
        case 7: return .`i64Value`(
            `value`: try FfiConverterInt64.read(from: &buf)
        )
        
        case 8: return .`decimalValue`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 9: return .`globalAddressValue`(
            `value`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 10: return .`publicKeyValue`(
            `value`: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 11: return .`nonFungibleGlobalIdValue`(
            `value`: try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 12: return .`nonFungibleLocalIdValue`(
            `value`: try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 13: return .`instantValue`(
            `value`: try FfiConverterInt64.read(from: &buf)
        )
        
        case 14: return .`urlValue`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .`originValue`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .`publicKeyHashValue`(
            `value`: try FfiConverterTypePublicKeyHash.read(from: &buf)
        )
        
        case 17: return .`stringArrayValue`(
            `value`: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 18: return .`boolArrayValue`(
            `value`: try FfiConverterSequenceBool.read(from: &buf)
        )
        
        case 19: return .`u8ArrayValue`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 20: return .`u32ArrayValue`(
            `value`: try FfiConverterSequenceUInt32.read(from: &buf)
        )
        
        case 21: return .`u64ArrayValue`(
            `value`: try FfiConverterSequenceUInt64.read(from: &buf)
        )
        
        case 22: return .`i32ArrayValue`(
            `value`: try FfiConverterSequenceInt32.read(from: &buf)
        )
        
        case 23: return .`i64ArrayValue`(
            `value`: try FfiConverterSequenceInt64.read(from: &buf)
        )
        
        case 24: return .`decimalArrayValue`(
            `value`: try FfiConverterSequenceTypeDecimal.read(from: &buf)
        )
        
        case 25: return .`globalAddressArrayValue`(
            `value`: try FfiConverterSequenceTypeAddress.read(from: &buf)
        )
        
        case 26: return .`publicKeyArrayValue`(
            `value`: try FfiConverterSequenceTypePublicKey.read(from: &buf)
        )
        
        case 27: return .`nonFungibleGlobalIdArrayValue`(
            `value`: try FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 28: return .`nonFungibleLocalIdArrayValue`(
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 29: return .`instantArrayValue`(
            `value`: try FfiConverterSequenceInt64.read(from: &buf)
        )
        
        case 30: return .`urlArrayValue`(
            `value`: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 31: return .`originArrayValue`(
            `value`: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 32: return .`publicKeyHashArrayValue`(
            `value`: try FfiConverterSequenceTypePublicKeyHash.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MetadataValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`stringValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`boolValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(`value`, into: &buf)
            
        
        case let .`u8Value`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterUInt8.write(`value`, into: &buf)
            
        
        case let .`u32Value`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(`value`, into: &buf)
            
        
        case let .`u64Value`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        
        case let .`i32Value`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterInt32.write(`value`, into: &buf)
            
        
        case let .`i64Value`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterInt64.write(`value`, into: &buf)
            
        
        case let .`decimalValue`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`globalAddressValue`(`value`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeAddress.write(`value`, into: &buf)
            
        
        case let .`publicKeyValue`(`value`):
            writeInt(&buf, Int32(10))
            FfiConverterTypePublicKey.write(`value`, into: &buf)
            
        
        case let .`nonFungibleGlobalIdValue`(`value`):
            writeInt(&buf, Int32(11))
            FfiConverterTypeNonFungibleGlobalId.write(`value`, into: &buf)
            
        
        case let .`nonFungibleLocalIdValue`(`value`):
            writeInt(&buf, Int32(12))
            FfiConverterTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        
        case let .`instantValue`(`value`):
            writeInt(&buf, Int32(13))
            FfiConverterInt64.write(`value`, into: &buf)
            
        
        case let .`urlValue`(`value`):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`originValue`(`value`):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`publicKeyHashValue`(`value`):
            writeInt(&buf, Int32(16))
            FfiConverterTypePublicKeyHash.write(`value`, into: &buf)
            
        
        case let .`stringArrayValue`(`value`):
            writeInt(&buf, Int32(17))
            FfiConverterSequenceString.write(`value`, into: &buf)
            
        
        case let .`boolArrayValue`(`value`):
            writeInt(&buf, Int32(18))
            FfiConverterSequenceBool.write(`value`, into: &buf)
            
        
        case let .`u8ArrayValue`(`value`):
            writeInt(&buf, Int32(19))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        
        case let .`u32ArrayValue`(`value`):
            writeInt(&buf, Int32(20))
            FfiConverterSequenceUInt32.write(`value`, into: &buf)
            
        
        case let .`u64ArrayValue`(`value`):
            writeInt(&buf, Int32(21))
            FfiConverterSequenceUInt64.write(`value`, into: &buf)
            
        
        case let .`i32ArrayValue`(`value`):
            writeInt(&buf, Int32(22))
            FfiConverterSequenceInt32.write(`value`, into: &buf)
            
        
        case let .`i64ArrayValue`(`value`):
            writeInt(&buf, Int32(23))
            FfiConverterSequenceInt64.write(`value`, into: &buf)
            
        
        case let .`decimalArrayValue`(`value`):
            writeInt(&buf, Int32(24))
            FfiConverterSequenceTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`globalAddressArrayValue`(`value`):
            writeInt(&buf, Int32(25))
            FfiConverterSequenceTypeAddress.write(`value`, into: &buf)
            
        
        case let .`publicKeyArrayValue`(`value`):
            writeInt(&buf, Int32(26))
            FfiConverterSequenceTypePublicKey.write(`value`, into: &buf)
            
        
        case let .`nonFungibleGlobalIdArrayValue`(`value`):
            writeInt(&buf, Int32(27))
            FfiConverterSequenceTypeNonFungibleGlobalId.write(`value`, into: &buf)
            
        
        case let .`nonFungibleLocalIdArrayValue`(`value`):
            writeInt(&buf, Int32(28))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        
        case let .`instantArrayValue`(`value`):
            writeInt(&buf, Int32(29))
            FfiConverterSequenceInt64.write(`value`, into: &buf)
            
        
        case let .`urlArrayValue`(`value`):
            writeInt(&buf, Int32(30))
            FfiConverterSequenceString.write(`value`, into: &buf)
            
        
        case let .`originArrayValue`(`value`):
            writeInt(&buf, Int32(31))
            FfiConverterSequenceString.write(`value`, into: &buf)
            
        
        case let .`publicKeyHashArrayValue`(`value`):
            writeInt(&buf, Int32(32))
            FfiConverterSequenceTypePublicKeyHash.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMetadataValue_lift(_ buf: RustBuffer) throws -> MetadataValue {
    return try FfiConverterTypeMetadataValue.lift(buf)
}

public func FfiConverterTypeMetadataValue_lower(_ value: MetadataValue) -> RustBuffer {
    return FfiConverterTypeMetadataValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NameRecordError {
    
    case `objectNameIsAlreadyTaken`(`object`: String, `name`: String)
    case `objectDoesNotExist`(`object`: String, `name`: String)
}

public struct FfiConverterTypeNameRecordError: FfiConverterRustBuffer {
    typealias SwiftType = NameRecordError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NameRecordError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`objectNameIsAlreadyTaken`(
            `object`: try FfiConverterString.read(from: &buf), 
            `name`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`objectDoesNotExist`(
            `object`: try FfiConverterString.read(from: &buf), 
            `name`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NameRecordError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`objectNameIsAlreadyTaken`(`object`,`name`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`object`, into: &buf)
            FfiConverterString.write(`name`, into: &buf)
            
        
        case let .`objectDoesNotExist`(`object`,`name`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`object`, into: &buf)
            FfiConverterString.write(`name`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNameRecordError_lift(_ buf: RustBuffer) throws -> NameRecordError {
    return try FfiConverterTypeNameRecordError.lift(buf)
}

public func FfiConverterTypeNameRecordError_lower(_ value: NameRecordError) -> RustBuffer {
    return FfiConverterTypeNameRecordError.lower(value)
}


extension NameRecordError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleLocalId {
    
    case `integer`(`value`: UInt64)
    case `str`(`value`: String)
    case `bytes`(`value`: [UInt8])
    case `ruid`(`value`: [UInt8])
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`integer`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .`str`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`bytes`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 4: return .`ruid`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`integer`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        
        case let .`str`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`value`, into: &buf)
            
        
        case let .`bytes`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        
        case let .`ruid`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}


extension NonFungibleLocalId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleLocalIdVecSource {
    
    case `guaranteed`(`value`: [NonFungibleLocalId])
    case `predicted`(`instructionIndex`: UInt64, `value`: [NonFungibleLocalId])
}

public struct FfiConverterTypeNonFungibleLocalIdVecSource: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalIdVecSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdVecSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`guaranteed`(
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 2: return .`predicted`(
            `instructionIndex`: try FfiConverterUInt64.read(from: &buf), 
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalIdVecSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`guaranteed`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        
        case let .`predicted`(`instructionIndex`,`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`instructionIndex`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNonFungibleLocalIdVecSource_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdVecSource {
    return try FfiConverterTypeNonFungibleLocalIdVecSource.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalIdVecSource_lower(_ value: NonFungibleLocalIdVecSource) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalIdVecSource.lower(value)
}


extension NonFungibleLocalIdVecSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ObjectModuleId {
    
    case `main`
    case `metadata`
    case `royalty`
    case `roleAssignment`
}

public struct FfiConverterTypeObjectModuleId: FfiConverterRustBuffer {
    typealias SwiftType = ObjectModuleId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ObjectModuleId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`main`
        
        case 2: return .`metadata`
        
        case 3: return .`royalty`
        
        case 4: return .`roleAssignment`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ObjectModuleId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`main`:
            writeInt(&buf, Int32(1))
        
        
        case .`metadata`:
            writeInt(&buf, Int32(2))
        
        
        case .`royalty`:
            writeInt(&buf, Int32(3))
        
        
        case .`roleAssignment`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeObjectModuleId_lift(_ buf: RustBuffer) throws -> ObjectModuleId {
    return try FfiConverterTypeObjectModuleId.lift(buf)
}

public func FfiConverterTypeObjectModuleId_lower(_ value: ObjectModuleId) -> RustBuffer {
    return FfiConverterTypeObjectModuleId.lower(value)
}


extension ObjectModuleId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OlympiaNetwork {
    
    case `mainnet`
    case `stokenet`
    case `releasenet`
    case `rcNet`
    case `milestonenet`
    case `devopsnet`
    case `sandpitnet`
    case `localnet`
}

public struct FfiConverterTypeOlympiaNetwork: FfiConverterRustBuffer {
    typealias SwiftType = OlympiaNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlympiaNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`mainnet`
        
        case 2: return .`stokenet`
        
        case 3: return .`releasenet`
        
        case 4: return .`rcNet`
        
        case 5: return .`milestonenet`
        
        case 6: return .`devopsnet`
        
        case 7: return .`sandpitnet`
        
        case 8: return .`localnet`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OlympiaNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`mainnet`:
            writeInt(&buf, Int32(1))
        
        
        case .`stokenet`:
            writeInt(&buf, Int32(2))
        
        
        case .`releasenet`:
            writeInt(&buf, Int32(3))
        
        
        case .`rcNet`:
            writeInt(&buf, Int32(4))
        
        
        case .`milestonenet`:
            writeInt(&buf, Int32(5))
        
        
        case .`devopsnet`:
            writeInt(&buf, Int32(6))
        
        
        case .`sandpitnet`:
            writeInt(&buf, Int32(7))
        
        
        case .`localnet`:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeOlympiaNetwork_lift(_ buf: RustBuffer) throws -> OlympiaNetwork {
    return try FfiConverterTypeOlympiaNetwork.lift(buf)
}

public func FfiConverterTypeOlympiaNetwork_lower(_ value: OlympiaNetwork) -> RustBuffer {
    return FfiConverterTypeOlympiaNetwork.lower(value)
}


extension OlympiaNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OwnerRole {
    
    case `none`
    case `fixed`(`value`: AccessRule)
    case `updatable`(`value`: AccessRule)
}

public struct FfiConverterTypeOwnerRole: FfiConverterRustBuffer {
    typealias SwiftType = OwnerRole

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnerRole {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`fixed`(
            `value`: try FfiConverterTypeAccessRule.read(from: &buf)
        )
        
        case 3: return .`updatable`(
            `value`: try FfiConverterTypeAccessRule.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OwnerRole, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case let .`fixed`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccessRule.write(`value`, into: &buf)
            
        
        case let .`updatable`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccessRule.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOwnerRole_lift(_ buf: RustBuffer) throws -> OwnerRole {
    return try FfiConverterTypeOwnerRole.lift(buf)
}

public func FfiConverterTypeOwnerRole_lower(_ value: OwnerRole) -> RustBuffer {
    return FfiConverterTypeOwnerRole.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Proposer {
    
    case `primary`
    case `recovery`
}

public struct FfiConverterTypeProposer: FfiConverterRustBuffer {
    typealias SwiftType = Proposer

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proposer {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`primary`
        
        case 2: return .`recovery`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Proposer, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`primary`:
            writeInt(&buf, Int32(1))
        
        
        case .`recovery`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeProposer_lift(_ buf: RustBuffer) throws -> Proposer {
    return try FfiConverterTypeProposer.lift(buf)
}

public func FfiConverterTypeProposer_lower(_ value: Proposer) -> RustBuffer {
    return FfiConverterTypeProposer.lower(value)
}


extension Proposer: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKey {
    
    case `secp256k1`(`value`: [UInt8])
    case `ed25519`(`value`: [UInt8])
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`secp256k1`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`ed25519`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`secp256k1`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        
        case let .`ed25519`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}


extension PublicKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PublicKeyHash {
    
    case `secp256k1`(`value`: [UInt8])
    case `ed25519`(`value`: [UInt8])
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`secp256k1`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`ed25519`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`secp256k1`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        
        case let .`ed25519`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}


extension PublicKeyHash: Equatable, Hashable {}



public enum RadixEngineToolkitError {

    
    
    case InvalidLength(`expected`: UInt64, `actual`: UInt64, `data`: [UInt8])
    case FailedToExtractNetwork(`address`: String)
    case Bech32DecodeError(`error`: String)
    case ParseError(`typeName`: String, `error`: String)
    case NonFungibleContentValidationError(`error`: String)
    case EntityTypeMismatchError(`expected`: [EntityType], `actual`: EntityType)
    case DerivationError(`error`: String)
    case InvalidPublicKey
    case CompileError(`error`: String)
    case DecompileError(`error`: String)
    case PrepareError(`error`: String)
    case EncodeError(`error`: String)
    case DecodeError(`error`: String)
    case TransactionValidationFailed(`error`: String)
    case ExecutionModuleError(`error`: String)
    case ManifestSborError(`error`: String)
    case ScryptoSborError(`error`: String)
    case TypedNativeEventError(`error`: String)
    case FailedToDecodeTransactionHash
    case ManifestBuilderNameRecordError(`error`: NameRecordError)
    case ManifestModificationError(`error`: String)
    case InvalidEntityTypeIdError(`error`: String)
    case DecimalError

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRadixEngineToolkitError.lift(error)
    }
}


public struct FfiConverterTypeRadixEngineToolkitError: FfiConverterRustBuffer {
    typealias SwiftType = RadixEngineToolkitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixEngineToolkitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLength(
            `expected`: try FfiConverterUInt64.read(from: &buf), 
            `actual`: try FfiConverterUInt64.read(from: &buf), 
            `data`: try FfiConverterSequenceUInt8.read(from: &buf)
            )
        case 2: return .FailedToExtractNetwork(
            `address`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Bech32DecodeError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParseError(
            `typeName`: try FfiConverterString.read(from: &buf), 
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 5: return .NonFungibleContentValidationError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 6: return .EntityTypeMismatchError(
            `expected`: try FfiConverterSequenceTypeEntityType.read(from: &buf), 
            `actual`: try FfiConverterTypeEntityType.read(from: &buf)
            )
        case 7: return .DerivationError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 8: return .InvalidPublicKey
        case 9: return .CompileError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 10: return .DecompileError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 11: return .PrepareError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 12: return .EncodeError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 13: return .DecodeError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 14: return .TransactionValidationFailed(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 15: return .ExecutionModuleError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 16: return .ManifestSborError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 17: return .ScryptoSborError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 18: return .TypedNativeEventError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 19: return .FailedToDecodeTransactionHash
        case 20: return .ManifestBuilderNameRecordError(
            `error`: try FfiConverterTypeNameRecordError.read(from: &buf)
            )
        case 21: return .ManifestModificationError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 22: return .InvalidEntityTypeIdError(
            `error`: try FfiConverterString.read(from: &buf)
            )
        case 23: return .DecimalError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixEngineToolkitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidLength(`expected`,`actual`,`data`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`expected`, into: &buf)
            FfiConverterUInt64.write(`actual`, into: &buf)
            FfiConverterSequenceUInt8.write(`data`, into: &buf)
            
        
        case let .FailedToExtractNetwork(`address`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`address`, into: &buf)
            
        
        case let .Bech32DecodeError(`error`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .ParseError(`typeName`,`error`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`typeName`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .NonFungibleContentValidationError(`error`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .EntityTypeMismatchError(`expected`,`actual`):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeEntityType.write(`expected`, into: &buf)
            FfiConverterTypeEntityType.write(`actual`, into: &buf)
            
        
        case let .DerivationError(`error`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case .InvalidPublicKey:
            writeInt(&buf, Int32(8))
        
        
        case let .CompileError(`error`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .DecompileError(`error`):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .PrepareError(`error`):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .EncodeError(`error`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .DecodeError(`error`):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .TransactionValidationFailed(`error`):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .ExecutionModuleError(`error`):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .ManifestSborError(`error`):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .ScryptoSborError(`error`):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .TypedNativeEventError(`error`):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case .FailedToDecodeTransactionHash:
            writeInt(&buf, Int32(19))
        
        
        case let .ManifestBuilderNameRecordError(`error`):
            writeInt(&buf, Int32(20))
            FfiConverterTypeNameRecordError.write(`error`, into: &buf)
            
        
        case let .ManifestModificationError(`error`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .InvalidEntityTypeIdError(`error`):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case .DecimalError:
            writeInt(&buf, Int32(23))
        
        }
    }
}


extension RadixEngineToolkitError: Equatable, Hashable {}

extension RadixEngineToolkitError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RecallResourceEvent {
    
    case `amount`(`value`: Decimal)
    case `ids`(`value`: [NonFungibleLocalId])
}

public struct FfiConverterTypeRecallResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = RecallResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecallResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecallResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`ids`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRecallResourceEvent_lift(_ buf: RustBuffer) throws -> RecallResourceEvent {
    return try FfiConverterTypeRecallResourceEvent.lift(buf)
}

public func FfiConverterTypeRecallResourceEvent_lower(_ value: RecallResourceEvent) -> RustBuffer {
    return FfiConverterTypeRecallResourceEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ReservedInstruction {
    
    case `accountLockFee`
    case `accountSecurify`
    case `identitySecurify`
    case `accountUpdateSettings`
    case `accessController`
}

public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`accountLockFee`
        
        case 2: return .`accountSecurify`
        
        case 3: return .`identitySecurify`
        
        case 4: return .`accountUpdateSettings`
        
        case 5: return .`accessController`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`accountLockFee`:
            writeInt(&buf, Int32(1))
        
        
        case .`accountSecurify`:
            writeInt(&buf, Int32(2))
        
        
        case .`identitySecurify`:
            writeInt(&buf, Int32(3))
        
        
        case .`accountUpdateSettings`:
            writeInt(&buf, Int32(4))
        
        
        case .`accessController`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}


extension ReservedInstruction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceOrNonFungible {
    
    case `nonFungible`(`value`: NonFungibleGlobalId)
    case `resource`(`value`: Address)
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`nonFungible`(
            `value`: try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        case 2: return .`resource`(
            `value`: try FfiConverterTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`nonFungible`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNonFungibleGlobalId.write(`value`, into: &buf)
            
        
        case let .`resource`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourcePreference {
    
    case `allowed`
    case `disallowed`
}

public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`allowed`
        
        case 2: return .`disallowed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`allowed`:
            writeInt(&buf, Int32(1))
        
        
        case .`disallowed`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}


extension ResourcePreference: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourcePreferenceAction {
    
    case `set`(`value`: ResourcePreference)
    case `remove`
}

public struct FfiConverterTypeResourcePreferenceAction: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`set`(
            `value`: try FfiConverterTypeResourcePreference.read(from: &buf)
        )
        
        case 2: return .`remove`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`set`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(`value`, into: &buf)
            
        
        case .`remove`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeResourcePreferenceAction_lift(_ buf: RustBuffer) throws -> ResourcePreferenceAction {
    return try FfiConverterTypeResourcePreferenceAction.lift(buf)
}

public func FfiConverterTypeResourcePreferenceAction_lower(_ value: ResourcePreferenceAction) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceAction.lower(value)
}


extension ResourcePreferenceAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceSpecifier {
    
    case `amount`(`resourceAddress`: Address, `amount`: Decimal)
    case `ids`(`resourceAddress`: Address, `ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`ids`(`resourceAddress`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ResourceTracker {
    
    case `fungible`(`resourceAddress`: Address, `amount`: DecimalSource)
    case `nonFungible`(`resourceAddress`: Address, `amount`: DecimalSource, `ids`: NonFungibleLocalIdVecSource)
}

public struct FfiConverterTypeResourceTracker: FfiConverterRustBuffer {
    typealias SwiftType = ResourceTracker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceTracker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimalSource.read(from: &buf)
        )
        
        case 2: return .`nonFungible`(
            `resourceAddress`: try FfiConverterTypeAddress.read(from: &buf), 
            `amount`: try FfiConverterTypeDecimalSource.read(from: &buf), 
            `ids`: try FfiConverterTypeNonFungibleLocalIdVecSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceTracker, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungible`(`resourceAddress`,`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimalSource.write(`amount`, into: &buf)
            
        
        case let .`nonFungible`(`resourceAddress`,`amount`,`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`resourceAddress`, into: &buf)
            FfiConverterTypeDecimalSource.write(`amount`, into: &buf)
            FfiConverterTypeNonFungibleLocalIdVecSource.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResourceTracker_lift(_ buf: RustBuffer) throws -> ResourceTracker {
    return try FfiConverterTypeResourceTracker.lift(buf)
}

public func FfiConverterTypeResourceTracker_lower(_ value: ResourceTracker) -> RustBuffer {
    return FfiConverterTypeResourceTracker.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Resources {
    
    case `amount`(`amount`: Decimal)
    case `ids`(`ids`: [NonFungibleLocalId])
}

public struct FfiConverterTypeResources: FfiConverterRustBuffer {
    typealias SwiftType = Resources

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Resources {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `amount`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `ids`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Resources, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`amount`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(`amount`, into: &buf)
            
        
        case let .`ids`(`ids`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`ids`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResources_lift(_ buf: RustBuffer) throws -> Resources {
    return try FfiConverterTypeResources.lift(buf)
}

public func FfiConverterTypeResources_lower(_ value: Resources) -> RustBuffer {
    return FfiConverterTypeResources.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Role {
    
    case `primary`
    case `recovery`
    case `confirmation`
}

public struct FfiConverterTypeRole: FfiConverterRustBuffer {
    typealias SwiftType = Role

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Role {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`primary`
        
        case 2: return .`recovery`
        
        case 3: return .`confirmation`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Role, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`primary`:
            writeInt(&buf, Int32(1))
        
        
        case .`recovery`:
            writeInt(&buf, Int32(2))
        
        
        case .`confirmation`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRole_lift(_ buf: RustBuffer) throws -> Role {
    return try FfiConverterTypeRole.lift(buf)
}

public func FfiConverterTypeRole_lower(_ value: Role) -> RustBuffer {
    return FfiConverterTypeRole.lower(value)
}


extension Role: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoundingMode {
    
    case `toPositiveInfinity`
    case `toNegativeInfinity`
    case `toZero`
    case `awayFromZero`
    case `toNearestMidpointTowardZero`
    case `toNearestMidpointAwayFromZero`
    case `toNearestMidpointToEven`
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`toPositiveInfinity`
        
        case 2: return .`toNegativeInfinity`
        
        case 3: return .`toZero`
        
        case 4: return .`awayFromZero`
        
        case 5: return .`toNearestMidpointTowardZero`
        
        case 6: return .`toNearestMidpointAwayFromZero`
        
        case 7: return .`toNearestMidpointToEven`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`toPositiveInfinity`:
            writeInt(&buf, Int32(1))
        
        
        case .`toNegativeInfinity`:
            writeInt(&buf, Int32(2))
        
        
        case .`toZero`:
            writeInt(&buf, Int32(3))
        
        
        case .`awayFromZero`:
            writeInt(&buf, Int32(4))
        
        
        case .`toNearestMidpointTowardZero`:
            writeInt(&buf, Int32(5))
        
        
        case .`toNearestMidpointAwayFromZero`:
            writeInt(&buf, Int32(6))
        
        
        case .`toNearestMidpointToEven`:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}


extension RoundingMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ScryptoSborString {
    
    case `programmaticJson`(`value`: String)
}

public struct FfiConverterTypeScryptoSborString: FfiConverterRustBuffer {
    typealias SwiftType = ScryptoSborString

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoSborString {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`programmaticJson`(
            `value`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScryptoSborString, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`programmaticJson`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeScryptoSborString_lift(_ buf: RustBuffer) throws -> ScryptoSborString {
    return try FfiConverterTypeScryptoSborString.lift(buf)
}

public func FfiConverterTypeScryptoSborString_lower(_ value: ScryptoSborString) -> RustBuffer {
    return FfiConverterTypeScryptoSborString.lower(value)
}


extension ScryptoSborString: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SerializationMode {
    
    case `programmatic`
    case `natural`
}

public struct FfiConverterTypeSerializationMode: FfiConverterRustBuffer {
    typealias SwiftType = SerializationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerializationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`programmatic`
        
        case 2: return .`natural`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerializationMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`programmatic`:
            writeInt(&buf, Int32(1))
        
        
        case .`natural`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeSerializationMode_lift(_ buf: RustBuffer) throws -> SerializationMode {
    return try FfiConverterTypeSerializationMode.lift(buf)
}

public func FfiConverterTypeSerializationMode_lower(_ value: SerializationMode) -> RustBuffer {
    return FfiConverterTypeSerializationMode.lower(value)
}


extension SerializationMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Signature {
    
    case `secp256k1`(`value`: [UInt8])
    case `ed25519`(`value`: [UInt8])
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`secp256k1`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`ed25519`(
            `value`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`secp256k1`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        
        case let .`ed25519`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}


extension Signature: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureWithPublicKey {
    
    case `secp256k1`(`signature`: [UInt8])
    case `ed25519`(`signature`: [UInt8], `publicKey`: [UInt8])
}

public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`secp256k1`(
            `signature`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`ed25519`(
            `signature`: try FfiConverterSequenceUInt8.read(from: &buf), 
            `publicKey`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`secp256k1`(`signature`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`signature`, into: &buf)
            
        
        case let .`ed25519`(`signature`,`publicKey`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`signature`, into: &buf)
            FfiConverterSequenceUInt8.write(`publicKey`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}


extension SignatureWithPublicKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransactionType {
    
    case `simpleTransfer`(`from`: Address, `to`: Address, `transferred`: ResourceSpecifier)
    case `transfer`(`from`: Address, `transfers`: [String: [String: Resources]])
    case `accountDepositSettings`(`resourcePreferenceChanges`: [String: [String: ResourcePreferenceAction]], `defaultDepositRuleChanges`: [String: AccountDefaultDepositRule], `authorizedDepositorsChanges`: [String: AuthorizedDepositorsChanges])
    case `generalTransaction`(`accountProofs`: [Address], `accountWithdraws`: [String: [ResourceTracker]], `accountDeposits`: [String: [ResourceTracker]], `addressesInManifest`: [EntityType: [Address]], `metadataOfNewlyCreatedEntities`: [String: [String: MetadataValue?]], `dataOfNewlyMintedNonFungibles`: [String: [NonFungibleLocalId: [UInt8]]], `addressesOfNewlyCreatedEntities`: [Address])
}

public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`simpleTransfer`(
            `from`: try FfiConverterTypeAddress.read(from: &buf), 
            `to`: try FfiConverterTypeAddress.read(from: &buf), 
            `transferred`: try FfiConverterTypeResourceSpecifier.read(from: &buf)
        )
        
        case 2: return .`transfer`(
            `from`: try FfiConverterTypeAddress.read(from: &buf), 
            `transfers`: try FfiConverterDictionaryStringDictionaryStringTypeResources.read(from: &buf)
        )
        
        case 3: return .`accountDepositSettings`(
            `resourcePreferenceChanges`: try FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceAction.read(from: &buf), 
            `defaultDepositRuleChanges`: try FfiConverterDictionaryStringTypeAccountDefaultDepositRule.read(from: &buf), 
            `authorizedDepositorsChanges`: try FfiConverterDictionaryStringTypeAuthorizedDepositorsChanges.read(from: &buf)
        )
        
        case 4: return .`generalTransaction`(
            `accountProofs`: try FfiConverterSequenceTypeAddress.read(from: &buf), 
            `accountWithdraws`: try FfiConverterDictionaryStringSequenceTypeResourceTracker.read(from: &buf), 
            `accountDeposits`: try FfiConverterDictionaryStringSequenceTypeResourceTracker.read(from: &buf), 
            `addressesInManifest`: try FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.read(from: &buf), 
            `metadataOfNewlyCreatedEntities`: try FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue.read(from: &buf), 
            `dataOfNewlyMintedNonFungibles`: try FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8.read(from: &buf), 
            `addressesOfNewlyCreatedEntities`: try FfiConverterSequenceTypeAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`simpleTransfer`(`from`,`to`,`transferred`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddress.write(`from`, into: &buf)
            FfiConverterTypeAddress.write(`to`, into: &buf)
            FfiConverterTypeResourceSpecifier.write(`transferred`, into: &buf)
            
        
        case let .`transfer`(`from`,`transfers`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAddress.write(`from`, into: &buf)
            FfiConverterDictionaryStringDictionaryStringTypeResources.write(`transfers`, into: &buf)
            
        
        case let .`accountDepositSettings`(`resourcePreferenceChanges`,`defaultDepositRuleChanges`,`authorizedDepositorsChanges`):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceAction.write(`resourcePreferenceChanges`, into: &buf)
            FfiConverterDictionaryStringTypeAccountDefaultDepositRule.write(`defaultDepositRuleChanges`, into: &buf)
            FfiConverterDictionaryStringTypeAuthorizedDepositorsChanges.write(`authorizedDepositorsChanges`, into: &buf)
            
        
        case let .`generalTransaction`(`accountProofs`,`accountWithdraws`,`accountDeposits`,`addressesInManifest`,`metadataOfNewlyCreatedEntities`,`dataOfNewlyMintedNonFungibles`,`addressesOfNewlyCreatedEntities`):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeAddress.write(`accountProofs`, into: &buf)
            FfiConverterDictionaryStringSequenceTypeResourceTracker.write(`accountWithdraws`, into: &buf)
            FfiConverterDictionaryStringSequenceTypeResourceTracker.write(`accountDeposits`, into: &buf)
            FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress.write(`addressesInManifest`, into: &buf)
            FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue.write(`metadataOfNewlyCreatedEntities`, into: &buf)
            FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8.write(`dataOfNewlyMintedNonFungibles`, into: &buf)
            FfiConverterSequenceTypeAddress.write(`addressesOfNewlyCreatedEntities`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccessControllerBlueprintEvent {
    
    case `initiateRecoveryEventValue`(`value`: InitiateRecoveryEvent)
    case `initiateBadgeWithdrawAttemptEventValue`(`value`: InitiateBadgeWithdrawAttemptEvent)
    case `ruleSetUpdateEventValue`(`value`: RuleSetUpdateEvent)
    case `badgeWithdrawEventValue`(`value`: BadgeWithdrawEvent)
    case `cancelRecoveryProposalEventValue`(`value`: CancelRecoveryProposalEvent)
    case `cancelBadgeWithdrawAttemptEventValue`(`value`: CancelBadgeWithdrawAttemptEvent)
    case `lockPrimaryRoleEventValue`(`value`: LockPrimaryRoleEvent)
    case `unlockPrimaryRoleEventValue`(`value`: UnlockPrimaryRoleEvent)
    case `stopTimedRecoveryEventValue`(`value`: StopTimedRecoveryEvent)
}

public struct FfiConverterTypeTypedAccessControllerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccessControllerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccessControllerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initiateRecoveryEventValue`(
            `value`: try FfiConverterTypeInitiateRecoveryEvent.read(from: &buf)
        )
        
        case 2: return .`initiateBadgeWithdrawAttemptEventValue`(
            `value`: try FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.read(from: &buf)
        )
        
        case 3: return .`ruleSetUpdateEventValue`(
            `value`: try FfiConverterTypeRuleSetUpdateEvent.read(from: &buf)
        )
        
        case 4: return .`badgeWithdrawEventValue`(
            `value`: try FfiConverterTypeBadgeWithdrawEvent.read(from: &buf)
        )
        
        case 5: return .`cancelRecoveryProposalEventValue`(
            `value`: try FfiConverterTypeCancelRecoveryProposalEvent.read(from: &buf)
        )
        
        case 6: return .`cancelBadgeWithdrawAttemptEventValue`(
            `value`: try FfiConverterTypeCancelBadgeWithdrawAttemptEvent.read(from: &buf)
        )
        
        case 7: return .`lockPrimaryRoleEventValue`(
            `value`: try FfiConverterTypeLockPrimaryRoleEvent.read(from: &buf)
        )
        
        case 8: return .`unlockPrimaryRoleEventValue`(
            `value`: try FfiConverterTypeUnlockPrimaryRoleEvent.read(from: &buf)
        )
        
        case 9: return .`stopTimedRecoveryEventValue`(
            `value`: try FfiConverterTypeStopTimedRecoveryEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccessControllerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`initiateRecoveryEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeInitiateRecoveryEvent.write(`value`, into: &buf)
            
        
        case let .`initiateBadgeWithdrawAttemptEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.write(`value`, into: &buf)
            
        
        case let .`ruleSetUpdateEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRuleSetUpdateEvent.write(`value`, into: &buf)
            
        
        case let .`badgeWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBadgeWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`cancelRecoveryProposalEventValue`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeCancelRecoveryProposalEvent.write(`value`, into: &buf)
            
        
        case let .`cancelBadgeWithdrawAttemptEventValue`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelBadgeWithdrawAttemptEvent.write(`value`, into: &buf)
            
        
        case let .`lockPrimaryRoleEventValue`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLockPrimaryRoleEvent.write(`value`, into: &buf)
            
        
        case let .`unlockPrimaryRoleEventValue`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeUnlockPrimaryRoleEvent.write(`value`, into: &buf)
            
        
        case let .`stopTimedRecoveryEventValue`(`value`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeStopTimedRecoveryEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccessControllerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedAccessControllerBlueprintEvent {
    return try FfiConverterTypeTypedAccessControllerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedAccessControllerBlueprintEvent_lower(_ value: TypedAccessControllerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccessControllerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccessControllerPackageEvent {
    
    case `accessController`(`value`: TypedAccessControllerBlueprintEvent)
}

public struct FfiConverterTypeTypedAccessControllerPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccessControllerPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccessControllerPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`accessController`(
            `value`: try FfiConverterTypeTypedAccessControllerBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccessControllerPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`accessController`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccessControllerBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccessControllerPackageEvent_lift(_ buf: RustBuffer) throws -> TypedAccessControllerPackageEvent {
    return try FfiConverterTypeTypedAccessControllerPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedAccessControllerPackageEvent_lower(_ value: TypedAccessControllerPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccessControllerPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccountBlueprintEvent {
    
    case `accountWithdrawEventValue`(`value`: AccountWithdrawEvent)
    case `accountDepositEventValue`(`value`: AccountDepositEvent)
    case `accountRejectedDepositEventValue`(`value`: AccountRejectedDepositEvent)
    case `accountSetResourcePreferenceEventValue`(`value`: AccountSetResourcePreferenceEvent)
    case `accountRemoveResourcePreferenceEventValue`(`value`: AccountRemoveResourcePreferenceEvent)
    case `accountSetDefaultDepositRuleEventValue`(`value`: AccountSetDefaultDepositRuleEvent)
    case `accountAddAuthorizedDepositorEventValue`(`value`: AccountAddAuthorizedDepositorEvent)
    case `accountRemoveAuthorizedDepositorEventValue`(`value`: AccountRemoveAuthorizedDepositorEvent)
}

public struct FfiConverterTypeTypedAccountBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccountBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccountBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`accountWithdrawEventValue`(
            `value`: try FfiConverterTypeAccountWithdrawEvent.read(from: &buf)
        )
        
        case 2: return .`accountDepositEventValue`(
            `value`: try FfiConverterTypeAccountDepositEvent.read(from: &buf)
        )
        
        case 3: return .`accountRejectedDepositEventValue`(
            `value`: try FfiConverterTypeAccountRejectedDepositEvent.read(from: &buf)
        )
        
        case 4: return .`accountSetResourcePreferenceEventValue`(
            `value`: try FfiConverterTypeAccountSetResourcePreferenceEvent.read(from: &buf)
        )
        
        case 5: return .`accountRemoveResourcePreferenceEventValue`(
            `value`: try FfiConverterTypeAccountRemoveResourcePreferenceEvent.read(from: &buf)
        )
        
        case 6: return .`accountSetDefaultDepositRuleEventValue`(
            `value`: try FfiConverterTypeAccountSetDefaultDepositRuleEvent.read(from: &buf)
        )
        
        case 7: return .`accountAddAuthorizedDepositorEventValue`(
            `value`: try FfiConverterTypeAccountAddAuthorizedDepositorEvent.read(from: &buf)
        )
        
        case 8: return .`accountRemoveAuthorizedDepositorEventValue`(
            `value`: try FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccountBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`accountWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`accountDepositEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountDepositEvent.write(`value`, into: &buf)
            
        
        case let .`accountRejectedDepositEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountRejectedDepositEvent.write(`value`, into: &buf)
            
        
        case let .`accountSetResourcePreferenceEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAccountSetResourcePreferenceEvent.write(`value`, into: &buf)
            
        
        case let .`accountRemoveResourcePreferenceEventValue`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAccountRemoveResourcePreferenceEvent.write(`value`, into: &buf)
            
        
        case let .`accountSetDefaultDepositRuleEventValue`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAccountSetDefaultDepositRuleEvent.write(`value`, into: &buf)
            
        
        case let .`accountAddAuthorizedDepositorEventValue`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeAccountAddAuthorizedDepositorEvent.write(`value`, into: &buf)
            
        
        case let .`accountRemoveAuthorizedDepositorEventValue`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccountBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedAccountBlueprintEvent {
    return try FfiConverterTypeTypedAccountBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedAccountBlueprintEvent_lower(_ value: TypedAccountBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccountBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedAccountPackageEvent {
    
    case `account`(`value`: TypedAccountBlueprintEvent)
}

public struct FfiConverterTypeTypedAccountPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedAccountPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedAccountPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`account`(
            `value`: try FfiConverterTypeTypedAccountBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedAccountPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`account`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccountBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedAccountPackageEvent_lift(_ buf: RustBuffer) throws -> TypedAccountPackageEvent {
    return try FfiConverterTypeTypedAccountPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedAccountPackageEvent_lower(_ value: TypedAccountPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedAccountPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedConsensusManagerBlueprintEvent {
    
    case `roundChangeEventValue`(`value`: RoundChangeEvent)
    case `epochChangeEventValue`(`value`: EpochChangeEvent)
}

public struct FfiConverterTypeTypedConsensusManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedConsensusManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedConsensusManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`roundChangeEventValue`(
            `value`: try FfiConverterTypeRoundChangeEvent.read(from: &buf)
        )
        
        case 2: return .`epochChangeEventValue`(
            `value`: try FfiConverterTypeEpochChangeEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedConsensusManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`roundChangeEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoundChangeEvent.write(`value`, into: &buf)
            
        
        case let .`epochChangeEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEpochChangeEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedConsensusManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedConsensusManagerBlueprintEvent {
    return try FfiConverterTypeTypedConsensusManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedConsensusManagerBlueprintEvent_lower(_ value: TypedConsensusManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedConsensusManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedConsensusManagerPackageEvent {
    
    case `consensusManager`(`value`: TypedConsensusManagerBlueprintEvent)
    case `validator`(`value`: TypedValidatorBlueprintEvent)
}

public struct FfiConverterTypeTypedConsensusManagerPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedConsensusManagerPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedConsensusManagerPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`consensusManager`(
            `value`: try FfiConverterTypeTypedConsensusManagerBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .`validator`(
            `value`: try FfiConverterTypeTypedValidatorBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedConsensusManagerPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`consensusManager`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedConsensusManagerBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`validator`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedValidatorBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedConsensusManagerPackageEvent_lift(_ buf: RustBuffer) throws -> TypedConsensusManagerPackageEvent {
    return try FfiConverterTypeTypedConsensusManagerPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedConsensusManagerPackageEvent_lower(_ value: TypedConsensusManagerPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedConsensusManagerPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedFungibleResourceManagerBlueprintEvent {
    
    case `vaultCreationEventValue`(`value`: VaultCreationEvent)
    case `mintFungibleResourceEventValue`(`value`: MintFungibleResourceEvent)
    case `burnFungibleResourceEventValue`(`value`: BurnFungibleResourceEvent)
}

public struct FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedFungibleResourceManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedFungibleResourceManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`vaultCreationEventValue`(
            `value`: try FfiConverterTypeVaultCreationEvent.read(from: &buf)
        )
        
        case 2: return .`mintFungibleResourceEventValue`(
            `value`: try FfiConverterTypeMintFungibleResourceEvent.read(from: &buf)
        )
        
        case 3: return .`burnFungibleResourceEventValue`(
            `value`: try FfiConverterTypeBurnFungibleResourceEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedFungibleResourceManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`vaultCreationEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVaultCreationEvent.write(`value`, into: &buf)
            
        
        case let .`mintFungibleResourceEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMintFungibleResourceEvent.write(`value`, into: &buf)
            
        
        case let .`burnFungibleResourceEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBurnFungibleResourceEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedFungibleResourceManagerBlueprintEvent {
    return try FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent_lower(_ value: TypedFungibleResourceManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedFungibleVaultBlueprintEvent {
    
    case `fungibleVaultLockFeeEventValue`(`value`: FungibleVaultLockFeeEvent)
    case `fungibleVaultWithdrawEventValue`(`value`: FungibleVaultWithdrawEvent)
    case `fungibleVaultDepositEventValue`(`value`: FungibleVaultDepositEvent)
    case `fungibleVaultRecallEventValue`(`value`: FungibleVaultRecallEvent)
    case `fungibleVaultPayFeeEventValue`(`value`: FungibleVaultPayFeeEvent)
}

public struct FfiConverterTypeTypedFungibleVaultBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedFungibleVaultBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedFungibleVaultBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungibleVaultLockFeeEventValue`(
            `value`: try FfiConverterTypeFungibleVaultLockFeeEvent.read(from: &buf)
        )
        
        case 2: return .`fungibleVaultWithdrawEventValue`(
            `value`: try FfiConverterTypeFungibleVaultWithdrawEvent.read(from: &buf)
        )
        
        case 3: return .`fungibleVaultDepositEventValue`(
            `value`: try FfiConverterTypeFungibleVaultDepositEvent.read(from: &buf)
        )
        
        case 4: return .`fungibleVaultRecallEventValue`(
            `value`: try FfiConverterTypeFungibleVaultRecallEvent.read(from: &buf)
        )
        
        case 5: return .`fungibleVaultPayFeeEventValue`(
            `value`: try FfiConverterTypeFungibleVaultPayFeeEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedFungibleVaultBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungibleVaultLockFeeEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFungibleVaultLockFeeEvent.write(`value`, into: &buf)
            
        
        case let .`fungibleVaultWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFungibleVaultWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`fungibleVaultDepositEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFungibleVaultDepositEvent.write(`value`, into: &buf)
            
        
        case let .`fungibleVaultRecallEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFungibleVaultRecallEvent.write(`value`, into: &buf)
            
        
        case let .`fungibleVaultPayFeeEventValue`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFungibleVaultPayFeeEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedFungibleVaultBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedFungibleVaultBlueprintEvent {
    return try FfiConverterTypeTypedFungibleVaultBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedFungibleVaultBlueprintEvent_lower(_ value: TypedFungibleVaultBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedFungibleVaultBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMetadataBlueprintEvent {
    
    case `setMetadataEventValue`(`value`: SetMetadataEvent)
    case `removeMetadataEventValue`(`value`: RemoveMetadataEvent)
}

public struct FfiConverterTypeTypedMetadataBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMetadataBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMetadataBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`setMetadataEventValue`(
            `value`: try FfiConverterTypeSetMetadataEvent.read(from: &buf)
        )
        
        case 2: return .`removeMetadataEventValue`(
            `value`: try FfiConverterTypeRemoveMetadataEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMetadataBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`setMetadataEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetMetadataEvent.write(`value`, into: &buf)
            
        
        case let .`removeMetadataEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRemoveMetadataEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMetadataBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedMetadataBlueprintEvent {
    return try FfiConverterTypeTypedMetadataBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedMetadataBlueprintEvent_lower(_ value: TypedMetadataBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedMetadataBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMetadataPackageEvent {
    
    case `metadata`(`value`: TypedMetadataBlueprintEvent)
}

public struct FfiConverterTypeTypedMetadataPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMetadataPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMetadataPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`metadata`(
            `value`: try FfiConverterTypeTypedMetadataBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMetadataPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`metadata`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedMetadataBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMetadataPackageEvent_lift(_ buf: RustBuffer) throws -> TypedMetadataPackageEvent {
    return try FfiConverterTypeTypedMetadataPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedMetadataPackageEvent_lower(_ value: TypedMetadataPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedMetadataPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedMultiResourcePoolBlueprintEvent {
    
    case `multiResourcePoolContributionEventValue`(`value`: MultiResourcePoolContributionEvent)
    case `multiResourcePoolRedemptionEventValue`(`value`: MultiResourcePoolRedemptionEvent)
    case `multiResourcePoolWithdrawEventValue`(`value`: MultiResourcePoolWithdrawEvent)
    case `multiResourcePoolDepositEventValue`(`value`: MultiResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedMultiResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedMultiResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedMultiResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`multiResourcePoolContributionEventValue`(
            `value`: try FfiConverterTypeMultiResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .`multiResourcePoolRedemptionEventValue`(
            `value`: try FfiConverterTypeMultiResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .`multiResourcePoolWithdrawEventValue`(
            `value`: try FfiConverterTypeMultiResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .`multiResourcePoolDepositEventValue`(
            `value`: try FfiConverterTypeMultiResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedMultiResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`multiResourcePoolContributionEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMultiResourcePoolContributionEvent.write(`value`, into: &buf)
            
        
        case let .`multiResourcePoolRedemptionEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMultiResourcePoolRedemptionEvent.write(`value`, into: &buf)
            
        
        case let .`multiResourcePoolWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMultiResourcePoolWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`multiResourcePoolDepositEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiResourcePoolDepositEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedMultiResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedMultiResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedMultiResourcePoolBlueprintEvent_lower(_ value: TypedMultiResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNativeEvent {
    
    case `accessController`(`value`: TypedAccessControllerPackageEvent)
    case `account`(`value`: TypedAccountPackageEvent)
    case `consensusManager`(`value`: TypedConsensusManagerPackageEvent)
    case `pool`(`value`: TypedPoolPackageEvent)
    case `resource`(`value`: TypedResourcePackageEvent)
    case `roleAssignment`(`value`: TypedRoleAssignmentPackageEvent)
    case `metadata`(`value`: TypedMetadataPackageEvent)
}

public struct FfiConverterTypeTypedNativeEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNativeEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNativeEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`accessController`(
            `value`: try FfiConverterTypeTypedAccessControllerPackageEvent.read(from: &buf)
        )
        
        case 2: return .`account`(
            `value`: try FfiConverterTypeTypedAccountPackageEvent.read(from: &buf)
        )
        
        case 3: return .`consensusManager`(
            `value`: try FfiConverterTypeTypedConsensusManagerPackageEvent.read(from: &buf)
        )
        
        case 4: return .`pool`(
            `value`: try FfiConverterTypeTypedPoolPackageEvent.read(from: &buf)
        )
        
        case 5: return .`resource`(
            `value`: try FfiConverterTypeTypedResourcePackageEvent.read(from: &buf)
        )
        
        case 6: return .`roleAssignment`(
            `value`: try FfiConverterTypeTypedRoleAssignmentPackageEvent.read(from: &buf)
        )
        
        case 7: return .`metadata`(
            `value`: try FfiConverterTypeTypedMetadataPackageEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNativeEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`accessController`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedAccessControllerPackageEvent.write(`value`, into: &buf)
            
        
        case let .`account`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedAccountPackageEvent.write(`value`, into: &buf)
            
        
        case let .`consensusManager`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedConsensusManagerPackageEvent.write(`value`, into: &buf)
            
        
        case let .`pool`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTypedPoolPackageEvent.write(`value`, into: &buf)
            
        
        case let .`resource`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeTypedResourcePackageEvent.write(`value`, into: &buf)
            
        
        case let .`roleAssignment`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTypedRoleAssignmentPackageEvent.write(`value`, into: &buf)
            
        
        case let .`metadata`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTypedMetadataPackageEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNativeEvent_lift(_ buf: RustBuffer) throws -> TypedNativeEvent {
    return try FfiConverterTypeTypedNativeEvent.lift(buf)
}

public func FfiConverterTypeTypedNativeEvent_lower(_ value: TypedNativeEvent) -> RustBuffer {
    return FfiConverterTypeTypedNativeEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNonFungibleResourceManagerBlueprintEvent {
    
    case `vaultCreationEventValue`(`value`: VaultCreationEvent)
    case `mintNonFungibleResourceEventValue`(`value`: MintNonFungibleResourceEvent)
    case `burnNonFungibleResourceEventValue`(`value`: BurnNonFungibleResourceEvent)
}

public struct FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNonFungibleResourceManagerBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNonFungibleResourceManagerBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`vaultCreationEventValue`(
            `value`: try FfiConverterTypeVaultCreationEvent.read(from: &buf)
        )
        
        case 2: return .`mintNonFungibleResourceEventValue`(
            `value`: try FfiConverterTypeMintNonFungibleResourceEvent.read(from: &buf)
        )
        
        case 3: return .`burnNonFungibleResourceEventValue`(
            `value`: try FfiConverterTypeBurnNonFungibleResourceEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNonFungibleResourceManagerBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`vaultCreationEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVaultCreationEvent.write(`value`, into: &buf)
            
        
        case let .`mintNonFungibleResourceEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMintNonFungibleResourceEvent.write(`value`, into: &buf)
            
        
        case let .`burnNonFungibleResourceEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBurnNonFungibleResourceEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedNonFungibleResourceManagerBlueprintEvent {
    return try FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent_lower(_ value: TypedNonFungibleResourceManagerBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedNonFungibleVaultBlueprintEvent {
    
    case `nonFungibleVaultWithdrawEventValue`(`value`: NonFungibleVaultWithdrawEvent)
    case `nonFungibleVaultDepositEventValue`(`value`: NonFungibleVaultDepositEvent)
    case `nonFungibleVaultRecallEventValue`(`value`: NonFungibleVaultRecallEvent)
}

public struct FfiConverterTypeTypedNonFungibleVaultBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedNonFungibleVaultBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedNonFungibleVaultBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`nonFungibleVaultWithdrawEventValue`(
            `value`: try FfiConverterTypeNonFungibleVaultWithdrawEvent.read(from: &buf)
        )
        
        case 2: return .`nonFungibleVaultDepositEventValue`(
            `value`: try FfiConverterTypeNonFungibleVaultDepositEvent.read(from: &buf)
        )
        
        case 3: return .`nonFungibleVaultRecallEventValue`(
            `value`: try FfiConverterTypeNonFungibleVaultRecallEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedNonFungibleVaultBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`nonFungibleVaultWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNonFungibleVaultWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`nonFungibleVaultDepositEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleVaultDepositEvent.write(`value`, into: &buf)
            
        
        case let .`nonFungibleVaultRecallEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonFungibleVaultRecallEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedNonFungibleVaultBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedNonFungibleVaultBlueprintEvent {
    return try FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedNonFungibleVaultBlueprintEvent_lower(_ value: TypedNonFungibleVaultBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.lower(value)
}


extension TypedNonFungibleVaultBlueprintEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedOneResourcePoolBlueprintEvent {
    
    case `oneResourcePoolContributionEventValue`(`value`: OneResourcePoolContributionEvent)
    case `oneResourcePoolRedemptionEventValue`(`value`: OneResourcePoolRedemptionEvent)
    case `oneResourcePoolWithdrawEventValue`(`value`: OneResourcePoolWithdrawEvent)
    case `oneResourcePoolDepositEventValue`(`value`: OneResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedOneResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedOneResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedOneResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`oneResourcePoolContributionEventValue`(
            `value`: try FfiConverterTypeOneResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .`oneResourcePoolRedemptionEventValue`(
            `value`: try FfiConverterTypeOneResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .`oneResourcePoolWithdrawEventValue`(
            `value`: try FfiConverterTypeOneResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .`oneResourcePoolDepositEventValue`(
            `value`: try FfiConverterTypeOneResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedOneResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`oneResourcePoolContributionEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOneResourcePoolContributionEvent.write(`value`, into: &buf)
            
        
        case let .`oneResourcePoolRedemptionEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOneResourcePoolRedemptionEvent.write(`value`, into: &buf)
            
        
        case let .`oneResourcePoolWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOneResourcePoolWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`oneResourcePoolDepositEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeOneResourcePoolDepositEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedOneResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedOneResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedOneResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedOneResourcePoolBlueprintEvent_lower(_ value: TypedOneResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedOneResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedPoolPackageEvent {
    
    case `oneResourcePool`(`value`: TypedOneResourcePoolBlueprintEvent)
    case `twoResourcePool`(`value`: TypedTwoResourcePoolBlueprintEvent)
    case `multiResourcePool`(`value`: TypedMultiResourcePoolBlueprintEvent)
}

public struct FfiConverterTypeTypedPoolPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedPoolPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedPoolPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`oneResourcePool`(
            `value`: try FfiConverterTypeTypedOneResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .`twoResourcePool`(
            `value`: try FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        case 3: return .`multiResourcePool`(
            `value`: try FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedPoolPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`oneResourcePool`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedOneResourcePoolBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`twoResourcePool`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`multiResourcePool`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedPoolPackageEvent_lift(_ buf: RustBuffer) throws -> TypedPoolPackageEvent {
    return try FfiConverterTypeTypedPoolPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedPoolPackageEvent_lower(_ value: TypedPoolPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedPoolPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedResourcePackageEvent {
    
    case `fungibleVault`(`value`: TypedFungibleVaultBlueprintEvent)
    case `nonFungibleVault`(`value`: TypedNonFungibleVaultBlueprintEvent)
    case `fungibleResourceManager`(`value`: TypedFungibleResourceManagerBlueprintEvent)
    case `nonFungibleResourceManager`(`value`: TypedNonFungibleResourceManagerBlueprintEvent)
}

public struct FfiConverterTypeTypedResourcePackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedResourcePackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedResourcePackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`fungibleVault`(
            `value`: try FfiConverterTypeTypedFungibleVaultBlueprintEvent.read(from: &buf)
        )
        
        case 2: return .`nonFungibleVault`(
            `value`: try FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.read(from: &buf)
        )
        
        case 3: return .`fungibleResourceManager`(
            `value`: try FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.read(from: &buf)
        )
        
        case 4: return .`nonFungibleResourceManager`(
            `value`: try FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedResourcePackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`fungibleVault`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedFungibleVaultBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`nonFungibleVault`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`fungibleResourceManager`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.write(`value`, into: &buf)
            
        
        case let .`nonFungibleResourceManager`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedResourcePackageEvent_lift(_ buf: RustBuffer) throws -> TypedResourcePackageEvent {
    return try FfiConverterTypeTypedResourcePackageEvent.lift(buf)
}

public func FfiConverterTypeTypedResourcePackageEvent_lower(_ value: TypedResourcePackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedResourcePackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedRoleAssignmentBlueprintEvent {
    
    case `setRoleEventValue`(`value`: SetRoleEvent)
    case `setOwnerRoleEventValue`(`value`: SetOwnerRoleEvent)
    case `lockOwnerRoleEventValue`(`value`: LockOwnerRoleEvent)
}

public struct FfiConverterTypeTypedRoleAssignmentBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedRoleAssignmentBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedRoleAssignmentBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`setRoleEventValue`(
            `value`: try FfiConverterTypeSetRoleEvent.read(from: &buf)
        )
        
        case 2: return .`setOwnerRoleEventValue`(
            `value`: try FfiConverterTypeSetOwnerRoleEvent.read(from: &buf)
        )
        
        case 3: return .`lockOwnerRoleEventValue`(
            `value`: try FfiConverterTypeLockOwnerRoleEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedRoleAssignmentBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`setRoleEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetRoleEvent.write(`value`, into: &buf)
            
        
        case let .`setOwnerRoleEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSetOwnerRoleEvent.write(`value`, into: &buf)
            
        
        case let .`lockOwnerRoleEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeLockOwnerRoleEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedRoleAssignmentBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedRoleAssignmentBlueprintEvent {
    return try FfiConverterTypeTypedRoleAssignmentBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedRoleAssignmentBlueprintEvent_lower(_ value: TypedRoleAssignmentBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedRoleAssignmentBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedRoleAssignmentPackageEvent {
    
    case `roleAssignment`(`value`: TypedRoleAssignmentBlueprintEvent)
}

public struct FfiConverterTypeTypedRoleAssignmentPackageEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedRoleAssignmentPackageEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedRoleAssignmentPackageEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`roleAssignment`(
            `value`: try FfiConverterTypeTypedRoleAssignmentBlueprintEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedRoleAssignmentPackageEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`roleAssignment`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTypedRoleAssignmentBlueprintEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedRoleAssignmentPackageEvent_lift(_ buf: RustBuffer) throws -> TypedRoleAssignmentPackageEvent {
    return try FfiConverterTypeTypedRoleAssignmentPackageEvent.lift(buf)
}

public func FfiConverterTypeTypedRoleAssignmentPackageEvent_lower(_ value: TypedRoleAssignmentPackageEvent) -> RustBuffer {
    return FfiConverterTypeTypedRoleAssignmentPackageEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedTwoResourcePoolBlueprintEvent {
    
    case `twoResourcePoolContributionEventValue`(`value`: TwoResourcePoolContributionEvent)
    case `twoResourcePoolRedemptionEventValue`(`value`: TwoResourcePoolRedemptionEvent)
    case `twoResourcePoolWithdrawEventValue`(`value`: TwoResourcePoolWithdrawEvent)
    case `twoResourcePoolDepositEventValue`(`value`: TwoResourcePoolDepositEvent)
}

public struct FfiConverterTypeTypedTwoResourcePoolBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedTwoResourcePoolBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedTwoResourcePoolBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`twoResourcePoolContributionEventValue`(
            `value`: try FfiConverterTypeTwoResourcePoolContributionEvent.read(from: &buf)
        )
        
        case 2: return .`twoResourcePoolRedemptionEventValue`(
            `value`: try FfiConverterTypeTwoResourcePoolRedemptionEvent.read(from: &buf)
        )
        
        case 3: return .`twoResourcePoolWithdrawEventValue`(
            `value`: try FfiConverterTypeTwoResourcePoolWithdrawEvent.read(from: &buf)
        )
        
        case 4: return .`twoResourcePoolDepositEventValue`(
            `value`: try FfiConverterTypeTwoResourcePoolDepositEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedTwoResourcePoolBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`twoResourcePoolContributionEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTwoResourcePoolContributionEvent.write(`value`, into: &buf)
            
        
        case let .`twoResourcePoolRedemptionEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTwoResourcePoolRedemptionEvent.write(`value`, into: &buf)
            
        
        case let .`twoResourcePoolWithdrawEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTwoResourcePoolWithdrawEvent.write(`value`, into: &buf)
            
        
        case let .`twoResourcePoolDepositEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTwoResourcePoolDepositEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedTwoResourcePoolBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedTwoResourcePoolBlueprintEvent {
    return try FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedTwoResourcePoolBlueprintEvent_lower(_ value: TypedTwoResourcePoolBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TypedValidatorBlueprintEvent {
    
    case `registerValidatorEventValue`(`value`: RegisterValidatorEvent)
    case `unregisterValidatorEventValue`(`value`: UnregisterValidatorEvent)
    case `stakeEventValue`(`value`: StakeEvent)
    case `unstakeEventValue`(`value`: UnstakeEvent)
    case `claimXrdEventValue`(`value`: ClaimXrdEvent)
    case `updateAcceptingStakeDelegationStateEventValue`(`value`: UpdateAcceptingStakeDelegationStateEvent)
    case `protocolUpdateReadinessSignalEventValue`(`value`: ProtocolUpdateReadinessSignalEvent)
    case `validatorEmissionAppliedEventValue`(`value`: ValidatorEmissionAppliedEvent)
    case `validatorRewardAppliedEventValue`(`value`: ValidatorRewardAppliedEvent)
}

public struct FfiConverterTypeTypedValidatorBlueprintEvent: FfiConverterRustBuffer {
    typealias SwiftType = TypedValidatorBlueprintEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypedValidatorBlueprintEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`registerValidatorEventValue`(
            `value`: try FfiConverterTypeRegisterValidatorEvent.read(from: &buf)
        )
        
        case 2: return .`unregisterValidatorEventValue`(
            `value`: try FfiConverterTypeUnregisterValidatorEvent.read(from: &buf)
        )
        
        case 3: return .`stakeEventValue`(
            `value`: try FfiConverterTypeStakeEvent.read(from: &buf)
        )
        
        case 4: return .`unstakeEventValue`(
            `value`: try FfiConverterTypeUnstakeEvent.read(from: &buf)
        )
        
        case 5: return .`claimXrdEventValue`(
            `value`: try FfiConverterTypeClaimXrdEvent.read(from: &buf)
        )
        
        case 6: return .`updateAcceptingStakeDelegationStateEventValue`(
            `value`: try FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.read(from: &buf)
        )
        
        case 7: return .`protocolUpdateReadinessSignalEventValue`(
            `value`: try FfiConverterTypeProtocolUpdateReadinessSignalEvent.read(from: &buf)
        )
        
        case 8: return .`validatorEmissionAppliedEventValue`(
            `value`: try FfiConverterTypeValidatorEmissionAppliedEvent.read(from: &buf)
        )
        
        case 9: return .`validatorRewardAppliedEventValue`(
            `value`: try FfiConverterTypeValidatorRewardAppliedEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypedValidatorBlueprintEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`registerValidatorEventValue`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRegisterValidatorEvent.write(`value`, into: &buf)
            
        
        case let .`unregisterValidatorEventValue`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnregisterValidatorEvent.write(`value`, into: &buf)
            
        
        case let .`stakeEventValue`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeStakeEvent.write(`value`, into: &buf)
            
        
        case let .`unstakeEventValue`(`value`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeUnstakeEvent.write(`value`, into: &buf)
            
        
        case let .`claimXrdEventValue`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeClaimXrdEvent.write(`value`, into: &buf)
            
        
        case let .`updateAcceptingStakeDelegationStateEventValue`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.write(`value`, into: &buf)
            
        
        case let .`protocolUpdateReadinessSignalEventValue`(`value`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeProtocolUpdateReadinessSignalEvent.write(`value`, into: &buf)
            
        
        case let .`validatorEmissionAppliedEventValue`(`value`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorEmissionAppliedEvent.write(`value`, into: &buf)
            
        
        case let .`validatorRewardAppliedEventValue`(`value`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeValidatorRewardAppliedEvent.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTypedValidatorBlueprintEvent_lift(_ buf: RustBuffer) throws -> TypedValidatorBlueprintEvent {
    return try FfiConverterTypeTypedValidatorBlueprintEvent.lift(buf)
}

public func FfiConverterTypeTypedValidatorBlueprintEvent_lower(_ value: TypedValidatorBlueprintEvent) -> RustBuffer {
    return FfiConverterTypeTypedValidatorBlueprintEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WithdrawResourceEvent {
    
    case `amount`(`value`: Decimal)
    case `ids`(`value`: [NonFungibleLocalId])
}

public struct FfiConverterTypeWithdrawResourceEvent: FfiConverterRustBuffer {
    typealias SwiftType = WithdrawResourceEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WithdrawResourceEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`amount`(
            `value`: try FfiConverterTypeDecimal.read(from: &buf)
        )
        
        case 2: return .`ids`(
            `value`: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WithdrawResourceEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`amount`(`value`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal.write(`value`, into: &buf)
            
        
        case let .`ids`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNonFungibleLocalId.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWithdrawResourceEvent_lift(_ buf: RustBuffer) throws -> WithdrawResourceEvent {
    return try FfiConverterTypeWithdrawResourceEvent.lift(buf)
}

public func FfiConverterTypeWithdrawResourceEvent_lower(_ value: WithdrawResourceEvent) -> RustBuffer {
    return FfiConverterTypeWithdrawResourceEvent.lower(value)
}




fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Signer Callback Interface

public protocol Signer : AnyObject {
    func `sign`(`hash`: Hash)  -> [UInt8]
    func `signToSignature`(`hash`: Hash)  -> Signature
    func `signToSignatureWithPublicKey`(`hash`: Hash)  -> SignatureWithPublicKey
    func `publicKey`()  -> PublicKey
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSigner : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeSign`(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.`sign`(
                    `hash`:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterSequenceUInt8.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeSignToSignature`(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.`signToSignature`(
                    `hash`:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeSignature.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeSignToSignatureWithPublicKey`(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.`signToSignatureWithPublicKey`(
                    `hash`:  try FfiConverterTypeHash.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeSignatureWithPublicKey.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokePublicKey`(_ swiftCallbackInterface: Signer, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.`publicKey`(
                    )
            var writer = [UInt8]()
            FfiConverterTypePublicKey.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSigner.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeSign`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeSignToSignature`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeSignToSignatureWithPublicKey`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: Signer
            do {
                cb = try FfiConverterCallbackInterfaceSigner.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Signer: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokePublicKey`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSigner {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(foreignCallbackCallbackInterfaceSigner, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Signer>()
}

extension FfiConverterCallbackInterfaceSigner : FfiConverter {
    typealias SwiftType = Signer
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAccessRule: FfiConverterRustBuffer {
    typealias SwiftType = AccessRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccessRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccessRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = Decimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePreciseDecimal: FfiConverterRustBuffer {
    typealias SwiftType = PreciseDecimal?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePreciseDecimal.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePreciseDecimal.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLockFeeModification: FfiConverterRustBuffer {
    typealias SwiftType = LockFeeModification?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLockFeeModification.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLockFeeModification.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeManifestBuilderAddressReservation: FfiConverterRustBuffer {
    typealias SwiftType = ManifestBuilderAddressReservation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeManifestBuilderAddressReservation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeManifestBuilderAddressReservation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeResourceManagerRole: FfiConverterRustBuffer {
    typealias SwiftType = ResourceManagerRole?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResourceManagerRole.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResourceManagerRole.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSchema: FfiConverterRustBuffer {
    typealias SwiftType = Schema?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSchema.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSchema.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMetadataValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMetadataValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMetadataValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt64: FfiConverterRustBuffer {
    typealias SwiftType = [Int64]

    public static func write(_ value: [Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int64] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDecimal: FfiConverterRustBuffer {
    typealias SwiftType = [Decimal]

    public static func write(_ value: [Decimal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDecimal.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Decimal] {
        let len: Int32 = try readInt(&buf)
        var seq = [Decimal]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDecimal.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIndexedAssertion: FfiConverterRustBuffer {
    typealias SwiftType = [IndexedAssertion]

    public static func write(_ value: [IndexedAssertion], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIndexedAssertion.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IndexedAssertion] {
        let len: Int32 = try readInt(&buf)
        var seq = [IndexedAssertion]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIndexedAssertion.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestBuilderMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestBuilderMapEntry]

    public static func write(_ value: [ManifestBuilderMapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestBuilderMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestBuilderMapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestBuilderMapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestBuilderMapEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [MapEntry]

    public static func write(_ value: [MapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [MapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMapEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEntityType: FfiConverterRustBuffer {
    typealias SwiftType = [EntityType]

    public static func write(_ value: [EntityType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntityType.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [Instruction]

    public static func write(_ value: [Instruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Instruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Instruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInstruction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestBuilderValue: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestBuilderValue]

    public static func write(_ value: [ManifestBuilderValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestBuilderValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestBuilderValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestBuilderValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestBuilderValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeManifestValue: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestValue]

    public static func write(_ value: [ManifestValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeResourceTracker: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceTracker]

    public static func write(_ value: [ResourceTracker], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceTracker.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceTracker] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceTracker]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceTracker.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [SignatureWithPublicKey]

    public static func write(_ value: [SignatureWithPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSignatureWithPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SignatureWithPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [SignatureWithPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSignatureWithPublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionType]

    public static func write(_ value: [TransactionType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionType] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionType.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]

    public static func write(_ value: [[UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt8]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeDecimal: FfiConverterRustBuffer {
    public static func write(_ value: [String: Decimal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeDecimal.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Decimal] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Decimal]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeDecimal.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeAuthorizedDepositorsChanges: FfiConverterRustBuffer {
    public static func write(_ value: [String: AuthorizedDepositorsChanges], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeAuthorizedDepositorsChanges.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: AuthorizedDepositorsChanges] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: AuthorizedDepositorsChanges]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeAuthorizedDepositorsChanges.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeMetadataInitEntry: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetadataInitEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMetadataInitEntry.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetadataInitEntry] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetadataInitEntry]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMetadataInitEntry.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeValidatorInfo: FfiConverterRustBuffer {
    public static func write(_ value: [String: ValidatorInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeValidatorInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ValidatorInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ValidatorInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeValidatorInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeAccountDefaultDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [String: AccountDefaultDepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeAccountDefaultDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: AccountDefaultDepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: AccountDefaultDepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeAccountDefaultDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeResourcePreferenceAction: FfiConverterRustBuffer {
    public static func write(_ value: [String: ResourcePreferenceAction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceAction.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ResourcePreferenceAction] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ResourcePreferenceAction]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceAction.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeResources: FfiConverterRustBuffer {
    public static func write(_ value: [String: Resources], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeResources.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Resources] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Resources]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeResources.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeAccessRule: FfiConverterRustBuffer {
    public static func write(_ value: [String: AccessRule?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeAccessRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: AccessRule?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: AccessRule?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeAccessRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetadataValue?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetadataValue?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetadataValue?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeResourceTracker: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ResourceTracker]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeResourceTracker.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ResourceTracker]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ResourceTracker]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceTracker.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeResourcePreferenceAction: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: ResourcePreferenceAction]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeResourcePreferenceAction.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: ResourcePreferenceAction]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: ResourcePreferenceAction]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeResourcePreferenceAction.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeResources: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: Resources]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeResources.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: Resources]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: Resources]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeResources.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringOptionTypeMetadataValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MetadataValue?]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringOptionTypeMetadataValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MetadataValue?]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MetadataValue?]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringOptionTypeMetadataValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryTypeNonFungibleLocalIdSequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [String: [NonFungibleLocalId: [UInt8]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [NonFungibleLocalId: [UInt8]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [NonFungibleLocalId: [UInt8]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeCurveTypeTypeDecryptorsByCurve: FfiConverterRustBuffer {
    public static func write(_ value: [CurveType: DecryptorsByCurve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeCurveType.write(key, into: &buf)
            FfiConverterTypeDecryptorsByCurve.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CurveType: DecryptorsByCurve] {
        let len: Int32 = try readInt(&buf)
        var dict = [CurveType: DecryptorsByCurve]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeCurveType.read(from: &buf)
            let value = try FfiConverterTypeDecryptorsByCurve.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeEntityTypeSequenceTypeAddress: FfiConverterRustBuffer {
    public static func write(_ value: [EntityType: [Address]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeEntityType.write(key, into: &buf)
            FfiConverterSequenceTypeAddress.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityType: [Address]] {
        let len: Int32 = try readInt(&buf)
        var dict = [EntityType: [Address]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeEntityType.read(from: &buf)
            let value = try FfiConverterSequenceTypeAddress.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeNonFungibleLocalIdSequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleLocalId: [UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleLocalId.write(key, into: &buf)
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId: [UInt8]] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleLocalId: [UInt8]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            let value = try FfiConverterSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionarySequenceUInt8SequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [[UInt8]: [UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterSequenceUInt8.write(key, into: &buf)
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]: [UInt8]] {
        let len: Int32 = try readInt(&buf)
        var dict = [[UInt8]: [UInt8]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterSequenceUInt8.read(from: &buf)
            let value = try FfiConverterSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `buildInformation`()  -> BuildInformation {
    return try!  FfiConverterTypeBuildInformation.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_build_information($0)
}
    )
}

public func `deriveOlympiaAccountAddressFromPublicKey`(`publicKey`: PublicKey, `olympiaNetwork`: OlympiaNetwork) throws -> OlympiaAddress {
    return try  FfiConverterTypeOlympiaAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterTypeOlympiaNetwork.lower(`olympiaNetwork`),$0)
}
    )
}

public func `derivePublicKeyFromOlympiaAccountAddress`(`olympiaResourceAddress`: OlympiaAddress) throws -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address(
        FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),$0)
}
    )
}

public func `deriveResourceAddressFromOlympiaResourceAddress`(`olympiaResourceAddress`: OlympiaAddress, `networkId`: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address(
        FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `deriveVirtualAccountAddressFromOlympiaAccountAddress`(`olympiaAccountAddress`: OlympiaAddress, `networkId`: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address(
        FfiConverterTypeOlympiaAddress.lower(`olympiaAccountAddress`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `deriveVirtualAccountAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `deriveVirtualIdentityAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> Address {
    return try  FfiConverterTypeAddress.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `deriveVirtualSignatureNonFungibleGlobalIdFromPublicKey`(`publicKey`: PublicKey, `networkId`: UInt8) throws -> NonFungibleGlobalId {
    return try  FfiConverterTypeNonFungibleGlobalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key(
        FfiConverterTypePublicKey.lower(`publicKey`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `hash`(`data`: [UInt8])  -> Hash {
    return try!  FfiConverterTypeHash.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_hash(
        FfiConverterSequenceUInt8.lower(`data`),$0)
}
    )
}

public func `knownAddresses`(`networkId`: UInt8)  -> KnownAddresses {
    return try!  FfiConverterTypeKnownAddresses.lift(
        try! rustCall() {
    uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses(
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `manifestSborDecodeToStringRepresentation`(`bytes`: [UInt8], `representation`: ManifestSborStringRepresentation, `networkId`: UInt8, `schema`: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation(
        FfiConverterSequenceUInt8.lower(`bytes`),
        FfiConverterTypeManifestSborStringRepresentation.lower(`representation`),
        FfiConverterUInt8.lower(`networkId`),
        FfiConverterOptionTypeSchema.lower(`schema`),$0)
}
    )
}

public func `metadataSborDecode`(`bytes`: [UInt8], `networkId`: UInt8) throws -> MetadataValue {
    return try  FfiConverterTypeMetadataValue.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode(
        FfiConverterSequenceUInt8.lower(`bytes`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `metadataSborEncode`(`value`: MetadataValue) throws -> [UInt8] {
    return try  FfiConverterSequenceUInt8.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode(
        FfiConverterTypeMetadataValue.lower(`value`),$0)
}
    )
}

public func `nonFungibleLocalIdAsStr`(`value`: NonFungibleLocalId) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str(
        FfiConverterTypeNonFungibleLocalId.lower(`value`),$0)
}
    )
}

public func `nonFungibleLocalIdFromStr`(`string`: String) throws -> NonFungibleLocalId {
    return try  FfiConverterTypeNonFungibleLocalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str(
        FfiConverterString.lower(`string`),$0)
}
    )
}

public func `nonFungibleLocalIdSborDecode`(`bytes`: [UInt8]) throws -> NonFungibleLocalId {
    return try  FfiConverterTypeNonFungibleLocalId.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode(
        FfiConverterSequenceUInt8.lower(`bytes`),$0)
}
    )
}

public func `nonFungibleLocalIdSborEncode`(`value`: NonFungibleLocalId) throws -> [UInt8] {
    return try  FfiConverterSequenceUInt8.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode(
        FfiConverterTypeNonFungibleLocalId.lower(`value`),$0)
}
    )
}

public func `sborDecodeToStringRepresentation`(`bytes`: [UInt8], `representation`: SerializationMode, `networkId`: UInt8, `schema`: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation(
        FfiConverterSequenceUInt8.lower(`bytes`),
        FfiConverterTypeSerializationMode.lower(`representation`),
        FfiConverterUInt8.lower(`networkId`),
        FfiConverterOptionTypeSchema.lower(`schema`),$0)
}
    )
}

public func `sborDecodeToTypedNativeEvent`(`eventTypeIdentifier`: EventTypeIdentifier, `eventData`: [UInt8], `networkId`: UInt8) throws -> TypedNativeEvent {
    return try  FfiConverterTypeTypedNativeEvent.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event(
        FfiConverterTypeEventTypeIdentifier.lower(`eventTypeIdentifier`),
        FfiConverterSequenceUInt8.lower(`eventData`),
        FfiConverterUInt8.lower(`networkId`),$0)
}
    )
}

public func `scryptoSborDecodeToStringRepresentation`(`bytes`: [UInt8], `representation`: SerializationMode, `networkId`: UInt8, `schema`: Schema?) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation(
        FfiConverterSequenceUInt8.lower(`bytes`),
        FfiConverterTypeSerializationMode.lower(`representation`),
        FfiConverterUInt8.lower(`networkId`),
        FfiConverterOptionTypeSchema.lower(`schema`),$0)
}
    )
}

public func `scryptoSborEncodeStringRepresentation`(`representation`: ScryptoSborString) throws -> [UInt8] {
    return try  FfiConverterSequenceUInt8.lift(
        try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation(
        FfiConverterTypeScryptoSborString.lower(`representation`),$0)
}
    )
}

public func `testPanic`(`message`: String) throws {
    try rustCallWithError(FfiConverterTypeRadixEngineToolkitError.lift) {
    uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic(
        FfiConverterString.lower(`message`),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information() != 17662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key() != 19647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address() != 45205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address() != 11639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address() != 24509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key() != 36758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key() != 11003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key() != 61146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_hash() != 16303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses() != 16813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation() != 19578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode() != 54114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode() != 11090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str() != 10663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str() != 27404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode() != 5482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode() != 44017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation() != 11831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event() != 43789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation() != 50232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation() != 24947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic() != 25407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and() != 5785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or() != 27266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string() != 5709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type() != 40172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global() != 25808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component() != 58252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager() != 48841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager() != 55847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager() != 16959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package() != 10761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager() != 34705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual() != 44552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal() != 34745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault() != 26605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store() != 4366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault() != 30524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault() != 10507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id() != 20026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 31072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 42883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 18756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling() != 62165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 25038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than() != 16609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal() != 3170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative() != 27762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive() != 15349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero() != 27694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than() != 30546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal() != 2387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 18912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal() != 61801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root() != 6178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 35861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 31873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 26365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str() != 2403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list() != 45845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id() != 55489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile() != 31325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash() != 993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header() != 49719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash() != 63530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest() != 60823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message() != 49610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate() != 18502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit() != 58477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch() != 3828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort() != 14294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund() != 51871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort() != 44832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund() != 50194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address() != 18604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains() != 37738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any() != 20665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles() != 58282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build() != 36705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource() != 52445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method() != 19399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method() != 53674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function() != 38619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method() != 42239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method() != 39370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method() != 25488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof() != 52407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure() != 12292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced() != 27856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager() != 45955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all() != 51538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount() != 51265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles() != 49166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all() != 46129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount() != 20827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles() != 25333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller() != 47497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs() != 12341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs() != 63484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs() != 2952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof() != 29894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd() != 59721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee() != 5856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible() != 41635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone() != 54385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package() != 13228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone() != 59668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop() != 48542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata() != 4065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role() != 58550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop() != 61948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop() != 7334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop() != 49676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account() != 4369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account() != 36610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors() != 45350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length() != 10753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length() != 15824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length() != 53437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str() != 12617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id() != 42729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address() != 26038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile() != 65183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash() != 64270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash() != 51688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash() != 17757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature() != 46873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent() != 11409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash() != 60604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate() != 11188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str() != 211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key() != 33649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs() != 753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add() != 50067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str() != 50135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt() != 31353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling() != 6632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div() != 47336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal() != 35658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor() != 6297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than() != 21292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal() != 34931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative() != 11588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive() != 30868) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero() != 41566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than() != 50862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal() != 33893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul() != 35568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal() != 17368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root() != 60037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi() != 57119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round() != 22122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt() != 18565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub() != 2969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key() != 49403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign() != 21427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature() != 4246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key() != 41168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile() != 26394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash() != 60260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent() != 19540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash() != 9462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures() != 46037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash() != 20757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate() != 27682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header() != 40383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest() != 8446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key() != 57025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer() != 32547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key() != 29671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer() != 17372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message() != 55782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key() != 60073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer() != 21713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash() != 1343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str() != 9829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes() != 40875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id() != 4187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into() != 33560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth() != 31236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from() != 1186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution() != 28095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs() != 55127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses() != 5474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth() != 1239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions() != 3783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify() != 4850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate() != 42656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range() != 31430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size() != 39564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage() != 28981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation() != 52946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage() != 2069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id() != 63098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all() != 26074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all() != 40312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require() != 10110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of() != 11748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount() != 34714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of() != 30352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of() != 59472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature() != 41270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw() != 43797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new() != 37549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address() != 64771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address() != 31070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key() != 738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key() != 32432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max() != 38313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min() != 18079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new() != 15617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one() != 42470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero() != 39451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string() != 64410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes() != 17030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions() != 51039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string() != 47420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile() != 565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new() != 4284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new() != 30710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default() != 54905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new() != 60275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts() != 36478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new() != 58056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge() != 22546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile() != 58667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new() != 56154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new() != 12724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max() != 49495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min() != 4453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new() != 34846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one() != 9121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero() != 5648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new() != 47612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519() != 4005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1() != 20991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile() != 12765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new() != 36392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new() != 46196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str() != 37610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new() != 62865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default() != 1435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new() != 36594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign() != 46892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature() != 15804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key() != 9393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key() != 61195) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}